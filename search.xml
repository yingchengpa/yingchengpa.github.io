<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一篇讲解select/iocp/epoll等网络模型推荐的文章]]></title>
    <url>%2F2019%2F08%2F19%2F%E4%B8%80%E7%AF%87%E8%AE%B2%E8%A7%A3select-iocp-epoll%E7%AD%89%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[转 https://my.oschina.net/yearnfar/blog/297733 将网络的模型说的比较清晰的文章]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安防行业视频播放器的设计]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%AE%89%E9%98%B2%E8%A1%8C%E4%B8%9A%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[背景在安防行业工作了n年，基本都是在做播放器相关开发，从公司最初的一代架构，后来的二代架构，再后来的轻量2.5代架构都是核心负责人员，对于安防行业播放器的架构设计有很深的了解。安防播放器并不需要追求最新的架构和最新的技术，适合自己行业、自己公司特点的才是优秀的。笔者的开发团队长期维持在4~5人，却承载着大量第三方厂商对接、标准测试、多种码流分析、多种私有文件格式解析、高稳定性、各种系统平台支持、正常需求、奇葩需求、新技术预研、奇奇怪怪bug定位等等，有一个易接入、插件式、高稳定、小而精的播放组件是多么的重要。 架构如下是在二代开始设计时架构图，分为UI和播放库，其中除了UI的桌面客户端、decode filer中的解码插件由其他团队完成，其他都是本组负责。 演变过程在一代架构开发过程时，公司还是已接入自己公司设备为主，所以架构比较随便，能用就行，但是随之时间发展，公司平台需要接入大量第三方厂商，一代架构有几个致命的缺点：1、播放库和UI层结合太精密。一代是已ActiveX形式提供的，那么就无法在非windows平台下使用；第三方公司接入也非常不方便。2、代码耦合高。每次接入一个厂商设备，新增加代码修改必然影响之前流程。每次出版本都冒着影响主流程的风险，测试、开发风险很大。 基于此，开发了二代架构。 二代架构参考了windows的directshow的方式，使用插件式进行接入。每次接入一个厂商，只需要开发对应厂商的source filter、parse filter、decode filter、render filter，然后通过配置可以选择用哪些filter进行连接。 举例1渲染模式从一开始的ddraw方式，演变出了d3d， 主要原因是在控制云台相机转动时画面在ddraw渲染下会出现锯齿现象。所以新开发了一个d3d_filter.dll ，那么只要在显示设置上选择“d3d模式”，就自动切换为d3d渲染。 举例2解码自适应。比如播放一些标准视频文件如 avi、mp4等等，我们可以编写一个ffmpeg filter,就自动支持很多文件格式、流格式了。只是性能稍微差一些。 所以只要套上一个漂亮的UI外壳，就可以成为一个万能播放器，即可以播放主流公司、主流格式的码流文件，也可以播放一些小众公司的码流文件。 设计的关键点1、已dll、so 的形式提供。2、使用C++98。兼容一些嵌入式设备。3、能用自研模块，就用自研模块。比如跨平台日志、跨平台多线程、锁、套接字、rtsp、http、mp4解析封装、渲染……4、能小则小，不依赖第三方库。比如公司设备web客户端插件，使用activex、npapi技术，包括解码等所有组件压缩后不到800K。5、跨平台。基本支持所有平台。6、提供32位、64位版本 涉及到的一些知识信令： 国标、onvif、sip媒体控制： rtsp、rtmp流媒体传输协议： rfc3984、 ps over rtp、ts over rtp、es over rtp本地文件格式： mp4（音频mp3、mp2、aac）音视频编码格式： mpeg2、mpeg4、h264、h265、g711、g722解码库： 264、intel media sdk、h265视频渲染： ddraw、d3d、opengl、sdl、x11音频渲染： waveout、directsound 新技术智能播放器的decode 和 render模块之间增加一个IA filter 就可以变成一个智能播放器了，加入伴线、车牌识别等等智能库。 GPU解码CPU性能的提升遇到了瓶颈，GPU成了现在的热门。早期2011年左右我在尝试gpu解码，采用的是n卡的cuda库和微软的dxva2，购买了当时最强的桌面显卡GTX470，但实际测试h264的hw解码性能却非常低下。后来查找了资料了解其实虽然使用了cuda算子，但h264本身的并发性并不强，所以在性能上勉强只能支持4路1080p的hw解码。接着就是研究intel quick sync video，intel的技术和n卡原理不同，intel的芯片中单独解码单元负责h264的解码，所以性能非常强劲，当时测试16路1080P h264解码，cpu占用率15%左右，但需要消耗2G多的内存。GPU解码存在一个缺点：显存数据copy到内存性能是非常低下的。 h5播放1、推模式：flash的rtmp协议模式。无延时，falsh可能被抛弃2、拉模式：hls 。有延时，兼容性强。3、webrtc：解码库h264支持不够完美、h265还不支持。 chrome、edge早期IE 统治下，activeX无疑是首选，后来chrome、firefox崛起，使用npapi，再后来chrome放弃npapi，不知道chrome下如何实现低延时播放？ 客户端web（IPC自带）C#（国内行业项目首选开发语言）QT(海外项目)手机 NAT穿越1、turn、stun。4种NAT类型2、端口合一。信令、媒体流都使用一个端口。rtp over http，rtp over rtsp 常见问题播放卡顿使用wireshark 抓包分析I、B、P帧间隔。 rtp包乱序缓存排序 rtp丢包tcpkcpQos 包分片rtp 包大小控制在mtu字节以内tcp 注意tcp粘包，使用’$’同步位 花屏1、是否存在丢包2、保存es码流使用elecard 播放，确定是码流问题还是解码库问题 播放锯齿、撕裂使用d3d模式 ddraw死锁（低概率）ddraw老bug， ddraw所有函数调用都放置在一个线程中。 资源泄漏、死锁、崩溃、踩内存……windbg 分析IDA pro 反汇编，定位第三库bug 性能差80% cpu是解码、15%是yuv内存copy……….. 1、优化解码性能。语言层的优化、算法层的优化2、优化yuv 内存copy次数。 解码后到渲染表面只进行一次内存复制；多窗口播放1080p视频时可以先缩放再copy。 疑难问题有几个疑难问题属于三界之外：1、windows 7 系统下主题更换导致ddraw存在gdi泄漏（超低概率）2、web端ddraw 低概率出现死锁（超低概率）3、某些多显卡情况下，播放视频不流畅（某台机器）4、vista系统长时间播放存在系统性丢包（某个版本操作系统）5、轮切过程中如果锁屏，会出现黑屏（超低概率）6、第三方小公司库质量差（大坑），最后变成我们帮他们定位、修改库代码。 总之，wireshark、elecard、模拟发包器（自己写的）、vlc、ffmpeg 、cool edit、windbg这几个神器在手，问题基本都能解决。 衍生出的产品万能播放器前面提到过，套上一个UI壳，就是一个漂亮的播放器 SDC（软dc）soft decode 软dc。 客户端不当只有pc、手机，其实还有电视墙。一般做法是配一个公司的ipc配置一个dc设备用户解码输出信号dvi、vga到电视墙，但是由于安防厂商众多，有的公司不提供linux解码方式，只有windows解码库，所以在这种场景需要SDC。SDC实际是一台PC主机，安装windows系统，并有3块A卡（A卡支持1卡3输出），所以实际上有9通道输出，输出口为DVi+VGA+DP,安装上万能播放器，再带一个sip协议库，就可以介入公司平台，可以上电视墙。并且支持图像拼接、画中画、漫游、多图层等类似拼接器功能。 IA智能服务器类似架构开发，将filter更名为engine，支持算法库插件式。 转码服务器1、使用hw解码库进行转码，从高分辨率转为低分辨率2、使用第三方sdk解码，然后hw重编码为标准码流 参考的源码vlcffmpegsdlintel media sdkwebrtc 总结安防的播放器需要满足：高兼容跨平台高稳定低延时流畅播放多通道高性能低带宽足够小元数据叠加]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows的应用验证机制]]></title>
    <url>%2F2019%2F08%2F15%2Fwindows%E7%9A%84%E5%BA%94%E7%94%A8%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[windows的验证机制发现软件瑕疵的最普遍方法就是测试，常用的测试手段有如下几种： 黑盒测试 白盒测试 内建自检 压力测试 虽然以上每种测试都有它的优势和侧重点，但即使用上了以上所有测试手段，也不能保证会发现所有问题。比如某个程序有轻微的内存泄漏，就很难发现。比如有些异常需要再比较苛刻的环境下才会出现，但测试时会很难满足。…… windows操作系统的验证机制（Verifier）就是为了满足这个需求而设计的。 windows 验证机制分为驱动验证器和应用程序验证器，这里主要讲解应用程序验证器。 应用程序验证器工作原理验证器的基本设计思想是在应用程序调用内核函数时，对应用程序执行各种检查，看其是否符合windows sdk的调用条件和规范。 windows 采用的是通过修改被验证程序的输入地址表（IAT）来挂载（hook）应用程序的api调用。 系统会将被验证驱动程序的IAT表中的api函数地址替换为验证函数的地址。这样，当这个应用程序调用api函数时，便会调用对应的验证函数。 应用检测器组成位于NTDLL中的支持例程位于ntdll.dll 中，大多已 AVrf 开头 验证提供器模块安装验证工具时复制到system32目录下的多个dll文件 应用验证管理器关于管理验证程序参数的图形界面工具。 执行过程执行过程是详细讲解是比较复杂的，这里我已简单的doublefree来简单介绍下执行过程。当函数中执行free时，最终会调用到virtualfree，这时应用验证器实际调用的是AVrfVirtualFree，改函数会调用AVrfVirtualFreeSanityChecks 执行健全性检查……当第二次对同一个地址进行free时，健全性检查会验证不过，从而主动触发一个异常。 使用应用验证器下载：链接：https://pan.baidu.com/s/1JKst9CbDKTFROKL0yWsmjg 提取码：7291 ，里面的ApplicationVerifier.x86.msi 和 ApplicationVerifier.amd64.msi 验证项目目前的验证器设计了6个类别，19个验证项目。 basics COM 正确使用组件对象模型（COM） Exceptions 检查非法访问异常 handles 正确使用句柄 Heaps 正确使用堆 Locks 正确使用同步对象 Memory 合理使用虚拟内存 RPC 正确使用rpc Threadpool 正确使用内存池 Tls 正确使用线程局部存储 Compatibility(兼容性) FilesPaths 正确读取公共目录和使用有个api HighVersionLie 读取版本信息的方式 Interactive-service 验证交互式系统服务 KernelMode-DriverInstall 正确安装内核态驱动程序 hangs hangs 检测可能导致程序僵死的情况 lowRes（低资源模拟） lowRes 模拟低资源情况，对分配资源请求返回失败 LuaPriv LuaPriv 判断在管理员权限可以运行的程序是否也可以在受限账号下正常运行 杂项 DangerousAPIs 检查使用危险api的情况 DirtyStacks 检测使用未初始化局部变量的情况 TimeRoolOver 强制GetTickCount api快速重新计数，已考验是否处理该异常 打印 PrintAPI 正确使用打印API PrintDriver 验证打印驱动程序 服务 Service 验证系统服务 doublefree操作举例安装应用验证安装后，找到appverif.exe doublefree代码123int *p = new int[100];delete []p;delete []p; 不开启应用验证时，程序不会出现异常。 开启应用验证“file” –&gt;”add application” —&gt;”xxx.exe” (不要在.exe 运行时操作)，选择“heaps” 启动 .exe ,然后执行doublefree 程序崩溃。使用windbg可以查看异常堆栈1234567891011121314151617180:000&gt; kvChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.004feafc 6ade80c8 6aded258 00000007 07041000 vrfcore!VerifierStopMessageEx+0x5b8004feb20 0fdcdfbe 00000007 0fdc1cac 07041000 vrfcore!VerifierDisableVerifier+0x598004feb78 0fdcbb9f 00000007 0fdc1cac 07041000 verifier!VerifierStopMessage+0x8e004febe4 0fdc89bd 07041000 00000000 0a8607ec verifier!VerifierDisableFaultInjectionExclusionRange+0x44af004fec48 0fdc8b15 07041000 0a6d6e70 00000000 verifier!VerifierDisableFaultInjectionExclusionRange+0x12cd004fec6c 0fdc8d90 07041000 0a6d6e70 004fed04 verifier!VerifierDisableFaultInjectionExclusionRange+0x1425004fec88 0fdcadd0 07041000 0a6d6e70 0a8607ec verifier!VerifierDisableFaultInjectionExclusionRange+0x16a0004feca4 77b72fa1 07040000 01001002 0a6d6e70 verifier!VerifierDisableFaultInjectionExclusionRange+0x36e0004fed14 77ad2735 0a6d6e70 08ba3c35 00000000 ntdll!RtlpNtSetValueKey+0x3cf1004fee60 77ad2302 00000000 0a6d6e70 00000111 ntdll!RtlGetCurrentServiceSessionId+0xf5004feeb4 6adead3b 07040000 00000000 0a6d6e70 ntdll!RtlFreeHeap+0x222004feed4 71de3c1b 07040000 00000000 0a6d6e70 vrfcore!VerifierSetAPIClassName+0x16b004fef20 00181660 0a6d6e70 004ff758 0a6d6e70 MSVCR90!free+0xcd004fef40 78409479 004ff758 004fef68 7840965b TraceMe!CTraceMeDlg::OnBnClickedButton1+0x40 (CONV: thiscall) [c:\users\b41-cx\documents\visual studio 2008\projects\traceme\traceme\tracemedlg.cpp @ 195]004fef4c 7840965b 000003e9 00000039 00000000 mfc90!_AfxDispatchCmdMsg+0x3b 个人常用方法 一般用这个工具来分析踩内存 可以在测试环境中验证服务 注意点 只能检查native代码 程序序正常退出才行，强行杀进程不能得到正确的报告 只能做Run-time检测。尽量使用程序的所有功能已保证检测到更多代码 开启检测时，性能会下降，内存会升高，不要在生产环境中使用。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[普通感冒]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%99%AE%E9%80%9A%E6%84%9F%E5%86%92%2F</url>
    <content type="text"><![CDATA[普通感冒时指流感病毒以外的病毒引起的急性上呼吸道感染。几个误解： 感冒是着凉引起的。挨冻是不会引起感冒的，会流鼻涕。 吃感冒药能治疗感冒的。打点滴、感冒药只能缓解感冒的症状，但是会拖长感冒治愈的时间。 抗生素能治疗感冒。抗生素是杀菌的，不是杀病毒的。 免疫力强的人不会感冒。只要感冒病毒进入鼻腔，几乎都会得，除非你的免疫系统不活跃。 感冒大都是通过手揉眼睛、挖鼻子，将病毒带入鼻腔的；还有就是通过其他人的唾沫传入的。所以 勤洗手，可以降低50%的概率 在人群多的地方带口罩]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[癌的简单介绍]]></title>
    <url>%2F2019%2F08%2F05%2F%E7%99%8C%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[外来性的毒性物质，物体本身没有危害，但是被身体的酶分解后会变成有毒物质，（比如酒精危害不大，但是被分解后的乙醛毒性很大 ）；物理射线都会导致基因受损 。 dna本身有修复功能，如果修复工作能在细胞下次分裂之前完成修复，就没有什么问题；但是如果在修复还没完成就进行有丝分裂，这时dna就会携带有错误的基因，所以对于有丝分裂频繁的细胞就会因为这个时间差而导致错误，高发位置就是在上皮细胞，比如膜啊、皮肤啊，经常暴露在环境和消化液中； 还有的情况不是修复时间不够，而是修复功能有问题，就是负责修复的酶本身就存在问题；还有的就是50%的癌症源自P53基因发生变异，P53基因是细胞修复的质检员，工作是：控制在修复完成时才能进行下次有丝分裂，同时如果dna损失过大可以引导细胞自杀。黄曲酶素专门破坏P53基因，一点点的黄曲酶素可能就会花掉你一辈子创造的财富。 形成癌细胞并非易事，需要受损细胞几十代的变异，需要10年以上时间，苯芭比妥给肝癌细胞更好的生长环境；焦油给了肺癌细胞好的环境；过量的雌性激素会给乳腺癌细胞和卵巢细胞更好的环境。 1/3人在某个时间点会最终患癌 ，大家可能会将癌症归于环境、遗传，但事实上细胞修复时发生的随机性错误也是需要考虑的。 了解了大概原理后，其实癌症发生是随机的，饮食、环境、遗传固然是一个原因，但是细胞有些分裂导致的随机错误是谁都无法避免的。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高度近视]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%AB%98%E5%BA%A6%E8%BF%91%E8%A7%86%2F</url>
    <content type="text"><![CDATA[一般建议： 高度近视眼患者定期进行扩瞳眼底检查（至少一年一次），早期发现小裂孔，可通过激光来防治视网膜脱离。 避免强度过大的体育锻炼或劳动，猛而强的撞击易诱发裂孔形成。 控制血压、血糖，避免其他原因引起的视网膜病变。 一旦出现眼部不适症状，及时至医院就诊。 视网膜脱离：是高度近视眼常见且严重的并发症之一。高度近视视网膜变性变薄，同时玻璃体变性，产生液化或后脱离，有玻璃体条索与变性的视网膜相粘连，如果眼球仅受到轻微震动或外伤，就有可能由于条索的牵拉，引起视网膜破裂，形成裂孔，这时液化的玻璃体可经裂孔流入视网膜下，使视网膜脱离。 黄斑病变：黄斑是视网膜上视觉最敏锐的部位。高度近视可形成脉络膜新生血管膜导致黄斑出血，患者因此出现视力突然明显降低、视物变形或中心固定暗点。高度近视眼球后部显著增长，由于黄斑中心区域玻璃体或黄斑前膜的前后方向牵引，可形成黄斑劈裂，甚至继发性黄斑裂孔，黄斑裂孔同样也可以引起视网膜脱离。 青光眼：高度近视合并开角型青光眼比正常眼多6～8倍。但近视眼合并的青光眼，易于漏诊及延误治疗。因为高度近视，随着眼球变长变大，眼球壁变薄变软，通常所测眼压偏低。同时对应出现的视力减退和视野缺损，一般也只认为是近视眼眼底病变所致。 鉴于高度近视的严重危害性，建议各位宝宝们： 高度近视的宝宝们应定期至眼科行扩瞳眼底检查，以期及早发现周边部视网膜裂孔，一旦发现，可通过激光光凝裂孔周围以预防视网膜脱离的发生。 视网膜脱离后会出现眼前幕样黑影遮挡感、闪光感、视力下降等，黄斑出血后会出现视力突然降低、视物变形或中心固定暗点等，一旦出现以上及其他眼部不适症状，及时至眼科就诊。 避免剧烈体育运动或其他体力劳动，避免眼球受到外伤，因强烈的震动或外力撞击容易使原本薄弱的视网膜发生裂孔。 青光眼是高度近视的并发症之一，应定期测量眼压及检查视野，以免忽略了青光眼的诊治。 由于眼底的变性萎缩，高度近视往往不能完全矫正，验光配镜时适当低矫也可提高一些视力，并易于被患者接受。 ---------- 以上摘自网络]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[近视--后半球]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%BF%91%E8%A7%86-%E5%90%8E%E5%8D%8A%E7%90%83%2F</url>
    <content type="text"><![CDATA[眼睛前半球的问题医学界都有成熟的解决办法。 看不清可以带眼镜。 不想带眼睛，可以做角膜手术 度数高，无法做角膜手术，可以植入人工晶状体 白内障可以换掉原来的晶状体 角膜坏了可以移植 但是如果后半球出了问题，几乎没法解决的，因为它已经涉及到神经跟视觉信号处理部分了。 所以我们只要有这个意识，就是保护好后半个眼球，那么眼睛上的问题总会有完美的解决办法。 后半球重要的问题就是视网膜脱落。图片中阿慕斯勒方格，使用一只眼睛对着黑点，如果看到的直线是有扭曲的，就说明你的眼睛已经存在严重问题了，需要马上去医院。中国人的这个发病率是万分之二。视网膜脱落对于高度近视人就更高了，建议： 需要避免头部做剧烈运动，比如拳击、蹦极、赛车、跳水。 定期进行扩瞳眼底检查（至少一年一次）]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[近视--前半球]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%BF%91%E8%A7%86-%E5%89%8D%E5%8D%8A%E7%90%83%2F</url>
    <content type="text"><![CDATA[眼睛大致分为前半球和后半球，本次重点讲前半球，下次讲后半球。 我们平时提到的近视、远视都是说的是前半球。 对于一个没有成年的孩子来说，如果双方父母视力都是600度以上的高度近视，那么大概率来说，小孩是高度近视的可能性是非常非常高的。如果父母懂得科学的方法，那么就可以让小孩成年前原来增加1000度，变为只增加200度，坚持到20岁，眼睛定型了就算是大功告成了。那么下面说下有效的保护方法： 在户外待足够长的时间。并不需要运动，只要静坐在那里就有效果，时间&gt;40分钟 使用阿托品类的眼药。浓度0.01%，一旦使用了这个药，就要有毅力，坚持下去。 使用ok 镜。 在小孩3、4岁的时候就一直坚持到眼睛定型，就不会让自己的孩子成为高度近视。这之外的其他方法对于缓慢近视发展是无效的，比如眼保健操、眼睛按摩椅、防蓝光灯等。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[饮食中游离糖背后的科学奥秘]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%A5%AE%E9%A3%9F%E4%B8%AD%E6%B8%B8%E7%A6%BB%E7%B3%96%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%91%E5%AD%A6%E5%A5%A5%E7%A7%98%2F</url>
    <content type="text"><![CDATA[问：什么是“游离糖”？ 答：“游离糖”是指厂商、厨师或消费者添加到食品中的单糖和双糖，加上蜂蜜、糖浆和果汁中天然存在的糖。单糖有一个糖分子，而且包括葡萄糖、半乳糖和果糖。双糖有两个糖分子。消费最广的双糖是蔗糖或砂糖。 问：所以建议不针对其它类型的糖？ 答：是的。世卫组织的建议只针对游离糖。它们不包括完整水果和蔬菜中的糖。后面这种糖有时称为内源性糖。这些糖由一层植物细胞壁包裹，消化起来更为缓慢，进入血流所需的时间比游离糖更长。 问：食品标签不显示“游离糖”，但有“添加糖”，那是什么？ 答：“添加糖”一词在美国和其它一些国家使用广泛，不过“添加糖”的定义还没有达成普遍共识。多数时候，“添加糖”是指与游离糖相同的一组糖，但“游离糖”一词更为精确。例如，尚不清楚浓缩果汁中是否含有添加糖，但其中肯定含有游离糖。还有原糖、非精制糖和天然糖。这些都是游离糖。 问：比较大的影响是什么？ 答：一个是龋齿（蛀牙），一个是不健康的体重增加（即，超重和肥胖）。肥胖会催生其它非传染性疾病：2型糖尿病、某些癌症（如，绝经后乳腺癌、结肠直肠癌），并在一定程度上造成心血管疾病。 水果非常不建议榨汁喝。 摘自： http://www.who.int/bulletin/volumes/92/11/14-031114/zh/]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[发烧]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%8F%91%E7%83%A7%2F</url>
    <content type="text"><![CDATA[发烧 病毒、病菌入侵会刺激细胞释放出前列腺素E2。E2会把“正常体温”的设定值给调高了， 让身体觉得体内热量不足，于是就要增加产热和减少散热。肌肉运动是增加产热的一种快速方法，因此发烧的人会不由自主地颤抖。为了减少散热，皮肤的血管收缩，那里的血液被送到体内深处，因此发烧的人会觉得发冷。扑热息痛（对乙酰氨基酸）、阿司匹林（乙酰水杨酸）等药物能够抑制E2的合成，因为他们是有效的退烧药。 吃了退烧药，或者病好了，体温恢复正常， 身体需要把多余的热量散发出去，就会出汗。所以退烧会导致出汗，但是许多人却本末倒置，以为是出汗导致了退烧，所以平时都是这样的土方法：发烧后多穿衣服，多盖被子，捂出汗来病就好了。 理论上，温度升高能加速某些免疫能力。初步的临床实验也表明发烧可能有些好处。比如，小孩患水痘，从发烧、出疹到完全结痂，大约一周，如果使用了退烧药，这个病程反而要多一天。 当然体温过高也是有害的。如果是高烧（肛门温度&gt;41度），会对细胞、组织造成损伤。当体温达到42度时，神经元就无法对体温做进一步的控制。因此一旦高烧，必须采取手段让体温下降。但是平时我们的土方法“捂热”，反而增加了体温，加重了病情。 如果是一般的发烧，未必就要急着吃药退烧。在通常情况下，吃退烧药只是让病人觉得舒服一些，无助于身体恢复，反而可能还会有所延误。至于“xx退热颗粒”“xx清热颗粒” 之类的传统药物，是否真有退烧的疗效很值得怀疑，服用他们也是有害无益。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[咳嗽]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%92%B3%E5%97%BD%2F</url>
    <content type="text"><![CDATA[咳嗽 咳嗽不是病，而是一种保护机制 为什么感冒的咳嗽不能随便吃药 如何正确处理儿童感冒后的咳嗽问题 简单回答：对于成年来说，如果不影响正常生活，不用特地的吃药；如果明显影响到睡眠，可以吃现代医学的止咳药；如果暂时没有药，可以含一块糖。 感冒之后还在咳嗽，说明粘膜并没有完全修复，还有致病源在上面，身体还在不断的清除他们。所以最好不要用什么药来终止身体的自我保护机制，特别是儿童。 如果咳得太厉害，影响到睡眠，那就可以吃一些止咳药，休息不好，受到的损失会更大。现代医学止咳药都是通过抑制神经起作用。比如吗啡，这个不仅止咳，连疼痛也止住，但是吗啡会成瘾，普通人不能使用。还有就是对吗啡做了化学调整的”可待因“，它的成瘾性略低，但现代医院也不允许使用。 安全的药是“右美沙芬” “苯丙哌林”“盐酸那可叮”“喷托维林”。 但以上这些抑制神经止咳的药对孩子还是风险过高，所以如果孩子不到6岁，最好的办法是吃一块糖。因为糖分混合着水会促进粘膜生层一层保护层，避免粘膜被病菌侵扰。 这个效果立竿见影，当然棒棒糖效果更好。棒棒糖可以算是缓慢释放糖分的止咳药，一根棒棒糖的止咳效果大约和15分钟不停的喝梨水，糖水效果差不多。 不论什么情况下，都不要用带“复方”开头的药物，也不吃那些药品名称里面包含了疗效的药物，比如“止咳水”“止咳糖浆”“克咳片”等，因为他们不安全，或者里面普通含有“可带因”“吗啡”等已经被禁的成分。 以上仅针对普通咳嗽，至于咳嗽带血、伴有呕吐，发烧，就需要立即就医。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[食用油的选择]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%A3%9F%E7%94%A8%E6%B2%B9%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[先说结论： 炒菜用精炼油，不要用初榨油，也不要用小作坊榨出来的油 精炼油只要不是动物油、椰子油、棕榈油，植物类的油都差别不大，主要是口味不同。首选菜籽油 转基因油即健康又便宜又实惠。 初榨油中含多酚类和维生素，所以不适合炒菜；同时不是精炼的油，杂质较多，在高温作用下容易产生致癌物质，所以也不适合炒菜。 食用油需要长时间保存，就需要精炼，一般会进行脱水、脱酸、脱色、脱臭、托蜡，最终目标就是让油中之有脂肪酸，含量为99.5%，所以基本没有其他什么营养物质，更别提什么清除自由基、抗衰老的功能了。如果纯度不高，遇到高温就容易产生致癌物质方而不安全。 99.5%都是脂肪酸，那么他们是有区别的。对人体的好处就是 单不饱和脂肪酸&gt;多不饱和脂肪酸&gt;饱和脂肪酸。 植物油差别不大，其中菜籽油、橄榄油、芝麻油都比较好，但菜籽油价格最便宜。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事故报告（2018/05/12）]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BA%8B%E6%95%85%E6%8A%A5%E5%91%8A%EF%BC%882018-05-12%EF%BC%89%2F</url>
    <content type="text"><![CDATA[时间2018/05/12持续： 30分钟 事故描述少量玩家玩家登陆不上 事故原因某台网关服务业务线程出现异常，出现僵死。但是tcp端口仍正常，slb健康检查正常，所以部分玩家请求会转发到该异常网关。 总结定位花费比较长时间。网关健康检查不完整；对于tcp正常，但业务线程异常，会上报消息堆积（但是某个服务缺失该功能）保存dump，找到原因修复bug 感受线上问题的修复其实并不难，难的其实是找到异常的服务；比如线上运行了几百个服务，如果能快速定位到根源服务；某个服务异常，导致其他服务雪崩，如何在雪崩的消息中找到有用的线索……. 服务如何部署、如何规划、哪些信息需要中心汇总、哪些信息需要及时预警……都要和业务结合起来进行调整，不能抛离业务。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事故报告（2018/01/26）]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BA%8B%E6%95%85%E6%8A%A5%E5%91%8A%EF%BC%882018-01-26%EF%BC%89%2F</url>
    <content type="text"><![CDATA[时间2018/01/26持续： 10分钟 事故描述用户无法登陆 事故原因手动执行redis删除大key命令，导致redis性能不足。其他接口redis访问超时 总结低级失误，关闭线上服务给开发人员的写操作权限。]]></content>
      <categories>
        <category>事故报告</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事故报告（2017/09/26）]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BA%8B%E6%95%85%E6%8A%A5%E5%91%8A%EF%BC%882017-09-26%EF%BC%89%2F</url>
    <content type="text"><![CDATA[时间2017/09/26 持续：5分钟 事故描述钉钉预警网关服务消息堆积1000+； 移动网关服务负载较高，导致用户连接失败 事故原因单台网关使用完成端口，套接字数量2.6w，阿里云cpu 100% 处理方式slb新挂载n台服务进行分流 总结服务状态监控预警很有必要，发现问题+处理问题 5分钟。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事故报告 (2017/09/07)]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BA%8B%E6%95%85%E6%8A%A5%E5%91%8A-2017-09-07%2F</url>
    <content type="text"><![CDATA[时间2017年9月7日 持续 半小时 事故描述服务升级，线上运行一会就出现崩溃；立刻保存dump分析原因。 事故原因编译器版本从vc6切换到vs2013，ms的函数保护严格，对原来的输入错误会产生异常；比如vs2013 版CString 函数转换特殊字符大小写，对于某些特殊字符产生异常，而vc6 不会 总结 结构化异常保护： 即使异常，程序仍能继续运行 无状态服务 ： 即使程序重启，仍不影响用户正常业务]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Teach Yourself Programming in Ten Years]]></title>
    <url>%2F2019%2F07%2F30%2FTeach-Yourself-Programming-in%2F</url>
    <content type="text"><![CDATA[Teach Yourself Programming in Ten Years http://norvig.com/21-days.html]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[超人类革命]]></title>
    <url>%2F2019%2F07%2F30%2F%E8%B6%85%E4%BA%BA%E7%B1%BB%E9%9D%A9%E5%91%BD%2F</url>
    <content type="text"><![CDATA[时间2019/07/30 概要1归根结底，最后都回到一个问题：到底是要让人变得更加像人-----或者说，使人变得更加像人所以变得更好--------还是反过来使人失去人的本质，甚至人工制造出一种新的物种，即后人类？ 什么是超人类主义？1超人类主义是利用科技进步---对当前人类的体能、智力、情感和道德等方方面面进行改善的浩大工程。超人类主义运动的一个最本质的特征就是它打算从传统的医疗模式，即以“修复”和治疗疾病为主要目的的治疗方式升级到“高级”模式，即改善甚至“增强”人类。 本书的目的：1完成黑格尔给哲学定下的首要任务：“理解现在存在的东西。”尽可能准确地描绘出现实。 书本结构 古典人文主义、超人类主义和后人类主义之间的关系 反对和支持超人类主义运动的各大主要论点 “共享经济”背后隐藏的政治哲学 对监管的反思 总结大致翻阅即可。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tcmalloc vs2013编译]]></title>
    <url>%2F2019%2F07%2F24%2Ftcmalloc-vs2013%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[下载https://github.com/gperftools/gperftools 编译tcmalloc 编译比较简单，有现成的工程。默认是使用vs2015编译，需要降级，并同时去掉“constexpr”关键字的使用。 使用可以参考 “README_windows.txt” dll 版选择“release-patch”编译出lib、dll在自己的项目中包含libtcmalloc_minimal.lib，并在“强制服号引用”设置“__tcmalloc” 静态库(md) 版选择“release-patch” ,项目输出修改为 “lib” 编译出 libtcmalloc_minimal.lib。 在自己的项目中包含libtcmalloc_minimal.lib，并在“强制服号引用”设置“__tcmalloc” 静态库(mt) 版选择“release-override” 编译出 libtcmalloc_minimal.lib。 将libtcmalloc_minimal 工程添加到自己的项目中，然后在“通用属性”–“引用” 中添加libtcmalloc_minimal 在“预处理器定义中增加 “PERFTOOLS_DLL_DECL=” 总结jemalloc 在windows下无法简单的替换项目中的malloc、free，但是tcmalloc却可以很方便的替换。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jemalloc vs2013编译]]></title>
    <url>%2F2019%2F07%2F23%2Fjemalloc-vs2013%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[下载https://github.com/jemalloc/jemalloc 选择master 说明本地解压后查看 jemalloc-master\msvc\ReadMe.txt12345678910111213141516171819202122How to build jemalloc for Windows=================================1. Install Cygwin with at least the following packages: * autoconf * autogen * gawk * grep * sed2. Install Visual Studio 2015 or 2017 with Visual C++3. Add Cygwin\bin to the PATH environment variable4. Open &quot;x64 Native Tools Command Prompt for VS 2017&quot; (note: x86/x64 doesn&apos;t matter at this point)5. Generate header files: sh -c &quot;CC=cl ./autogen.sh&quot;6. Now the project can be opened and built in Visual Studio: msvc\jemalloc_vc2017.sln 安装cygwinhttp://www.cygwin.com/ setup-x86.exe 环境配置cygwin 默认安装完后，安装jemalloc说明在vs2013 的命令行下执行 sh -c “CC=cl ./autogen.sh” ，提示123autoconf./autogen.sh: line 5: autoconf: command not foundError 0 in autoconf 需要安装 autoconf2.5 、automake vs2015 工程降级 修改 jemalloc_vc2015.sln 修改jemalloc.vcxproj 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;Project DefaultTargets=&quot;Build&quot; ToolsVersion=&quot;12.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt; &lt;ItemGroup Label=&quot;ProjectConfigurations&quot;&gt; vs2013 打开工程，修改平台工具集为“Visual Studio 2013 (v120)” 编译报错static 正常；dll 库时报错12341&gt;arena.obj : error LNK2001: 无法解析的外部符号 _test_hooks_arena_new_hook1&gt;malloc_io.obj : error LNK2001: 无法解析的外部符号 _test_hooks_libc_hook1&gt;pages.obj : error LNK2001: 无法解析的外部符号 _test_hooks_libc_hook1&gt;prof.obj : error LNK2001: 无法解析的外部符号 _test_hooks_libc_hook 添加 test_hooks.c 到工程中，重新编译 测试能用，但是windows下替换malloc、free还不是很方便，下次尝试用下tcmalloc。 工程地址链接：https://pan.baidu.com/s/1WsmfkgNSlIp_CYApYGUJ5Q提取码：sgev]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SLB支持wss]]></title>
    <url>%2F2019%2F07%2F18%2FSLB%E6%94%AF%E6%8C%81wss%2F</url>
    <content type="text"><![CDATA[背景原本用boost::asio 做了一个支持tcp、ws、wss协议的网关，一个端口同时支持三种协议，区分的方法比较简单： 判断三次握手之后的第一字节的数据报文 0x16：wss // ssl协议的头 ‘G’：ws ‘H’: tcp //私有协议也有一个握手报文 现在担心自己ssl解析性能不够优秀，所以打算使用阿里slb的ssl解析 配置方法配置比较简单，使用“性能保障型SLB”，然后在https中设置。 出现的问题健康检测异常由于不支持http的HEAD命令，所在在代码中增加对HEAD的处理，直接返回200ok，并主动关闭链接 https返回502使用 curl https://xxx.xx.com:1235 -v 提示502。需要支持http的GET命令。修改代码对GET的支持。 slb一个端口无法支持多个协议原来的服务12345端口是可以同时支持tcp、ws、wss协议的，经过slb需要配置三个端口： tcp ： 12345 — &gt;12345 http: 12346 — &gt; 12345 https:12347 —&gt; 12345 巨不爽！！ 测试数据使用 https://blog.csdn.net/zt3032/article/details/80492146 文章中测试https的结果。 slb123456789101112131415161718192021222324252019-07-18,16:27:57 0.002:0.003:0.057:0.000:0.057:0.063:0.0632019-07-18,16:27:58 0.001:0.003:0.048:0.000:0.048:0.055:0.0552019-07-18,16:27:59 0.002:0.005:0.051:0.000:0.051:0.057:0.0572019-07-18,16:28:00 0.002:0.003:0.050:0.000:0.050:0.055:0.0552019-07-18,16:28:01 0.002:0.003:0.049:0.000:0.049:0.054:0.0542019-07-18,16:28:02 0.002:0.003:0.052:0.000:0.052:0.058:0.0582019-07-18,16:28:03 0.002:0.003:0.050:0.000:0.050:0.056:0.0562019-07-18,16:28:04 0.002:0.003:0.051:0.000:0.051:0.057:0.0572019-07-18,16:28:05 0.002:0.003:0.050:0.000:0.050:0.057:0.0572019-07-18,16:28:06 0.001:0.003:0.049:0.000:0.049:0.055:0.0552019-07-18,16:28:07 0.001:0.003:0.048:0.000:0.048:0.053:0.0532019-07-18,16:28:08 0.002:0.003:0.052:0.000:0.052:0.058:0.0582019-07-18,16:28:09 0.001:0.003:0.049:0.000:0.049:0.055:0.0552019-07-18,16:28:11 0.001:0.003:0.049:0.000:0.049:0.055:0.0552019-07-18,16:28:12 0.001:0.003:0.052:0.000:0.052:0.058:0.0582019-07-18,16:28:13 0.002:0.003:0.049:0.000:0.049:0.055:0.0552019-07-18,16:28:14 0.002:0.003:0.049:0.000:0.049:0.055:0.0552019-07-18,16:28:15 0.002:0.003:0.053:0.000:0.053:0.059:0.0592019-07-18,16:28:16 0.001:0.003:0.050:0.000:0.050:0.055:0.0552019-07-18,16:28:17 0.002:0.003:0.048:0.000:0.048:0.053:0.0532019-07-18,16:28:18 0.001:0.003:0.056:0.000:0.056:0.061:0.0612019-07-18,16:28:19 0.002:0.003:0.050:0.000:0.050:0.056:0.0562019-07-18,16:28:20 0.001:0.003:0.048:0.000:0.048:0.053:0.0532019-07-18,16:28:21 0.002:0.003:0.051:0.000:0.051:0.057:0.0572019-07-18,16:28:22 0.002:0.004:0.051:0.000:0.051:0.058:0.058 自己做解析123456789101112131415161718192021222324252019-07-18,17:57:04 0.002:0.002:0.073:0.000:0.073:0.074:0.0742019-07-18,17:57:06 0.002:0.002:0.071:0.000:0.071:0.072:0.0722019-07-18,17:57:07 0.002:0.002:0.072:0.000:0.072:0.072:0.0722019-07-18,17:57:08 0.002:0.002:0.072:0.000:0.072:0.073:0.0732019-07-18,17:57:09 0.002:0.002:0.072:0.000:0.072:0.072:0.0722019-07-18,17:57:10 0.002:0.002:0.075:0.000:0.075:0.076:0.0762019-07-18,17:57:11 0.002:0.002:0.075:0.000:0.075:0.076:0.0762019-07-18,17:57:12 0.002:0.002:0.074:0.000:0.074:0.075:0.0752019-07-18,17:57:13 0.002:0.002:0.074:0.000:0.074:0.075:0.0752019-07-18,17:57:14 0.002:0.002:0.072:0.000:0.072:0.073:0.0732019-07-18,17:57:15 0.002:0.002:0.075:0.000:0.075:0.076:0.0762019-07-18,17:57:16 0.001:0.002:0.072:0.000:0.072:0.072:0.0722019-07-18,17:57:17 0.001:0.002:0.074:0.000:0.074:0.075:0.0752019-07-18,17:57:19 0.002:0.002:0.072:0.000:0.072:0.073:0.0732019-07-18,17:57:20 0.001:0.003:0.072:0.000:0.072:0.073:0.0732019-07-18,17:57:21 0.002:0.002:0.070:0.000:0.070:0.071:0.0712019-07-18,17:57:22 0.001:0.002:0.071:0.000:0.071:0.072:0.0722019-07-18,17:57:23 0.002:0.002:0.071:0.000:0.071:0.072:0.0722019-07-18,17:57:24 0.001:0.002:0.070:0.000:0.070:0.071:0.0712019-07-18,17:57:25 0.002:0.002:0.071:0.000:0.071:0.072:0.0722019-07-18,17:57:26 0.001:0.002:0.071:0.000:0.071:0.072:0.0722019-07-18,17:57:27 0.002:0.002:0.071:0.000:0.071:0.071:0.0712019-07-18,17:57:28 0.001:0.002:0.072:0.000:0.072:0.073:0.0732019-07-18,17:57:29 0.001:0.002:0.070:0.000:0.070:0.071:0.0712019-07-18,17:57:30 0.002:0.002:0.083:0.000:0.083:0.084:0.084 总结 https返回502 其实我的测试工具不正确； 如果直接用wss测试工具是不会返回502的。 slb性能视乎会好些，也不能排除ecs的性能不够，仅做参考。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[奶是妈的好]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%A5%B6%E6%98%AF%E5%A6%88%E7%9A%84%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[配方奶是无法复制母乳的，是因为母乳中含有许多微量活性元素、还含有消化酶，可以帮助婴儿消化、吸收； 母乳中含有免疫球蛋白、巨噬细胞、淋巴细胞，能够帮助消灭肠道细菌；含有生长因子，刺激小肠细胞繁殖； 母亲还能将接触到的病菌、病毒抗体通过乳汁传给婴儿。等等。 配方奶虽然可以添加免疫蛋白或乳铁蛋白，或是其他活性物质，但是婴儿的胃酸最终都会杀死它们。而母乳的活性物质会被乳汁脂肪包装、保护起来，躲过胃酸，最终抵达肠道。 但母乳也有不足， 一是缺少维生素D，母乳婴儿应每天补充维生素D制剂； 二是缺少铁，前4~6个月婴儿体内有铁储备，之后就需要通过辅食补充铁； 三是从饮食、药物摄入的毒素以及多种传染病也会通过母乳传递给婴儿。 特别是传统医学里面的下奶、通奶的中草药，这些未知的药物毒素就会传递个婴儿。 总之，母乳喂养的婴儿消化系统、呼吸系统、糖尿病、免疫系统等方面的疾病及肥胖风险都降低了。世界卫生组织建议哺乳期为两年，前6个月纯母乳喂养。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[乙肝]]></title>
    <url>%2F2019%2F07%2F17%2F%E4%B9%99%E8%82%9D%2F</url>
    <content type="text"><![CDATA[我国有9300w乙肝病毒携带者，得了乙肝如果不治疗，任其发展下去，20%的人会转变成肝硬化，这20%肝硬化病人中还会有20%最终会发展为肝癌。如果再加上有喝酒，甚至是酗酒的习惯，得肝癌的比例就更高了。 如果已经确认是乙肝患者了，那唯一要注意的就是三个字——抗病毒。 现在也只有这一种方法可以控制病情的发展，最好的情况下，可以在人生之后几十年中跟健康人没有太大区别。 那么，怎么确定谁是携带者还是病人呢？ 主要看三个指标： 第一个是两对半的检查： 第二个是乙肝病毒 DNA 的检查；检测病毒的活跃程度。 第三个是转氨酶的检查；转氨酶只有肝细胞有，血液中转氨酶数量越多，肝细胞破坏的越严重 怎么治疗呢？ 一种是干扰素的治疗，它是通过打针的方式，疗程一般要1年的时间。国产的干扰素1周打3针，1年下来估计花费6000块钱。进口的干扰素1周打1针，省时间，但是费钱，大约1年下来需要5万块钱。用干扰素治疗，时间比较短，但是效果不好，1年后平均有60%的患者检查指标可以变成正常。 另外一种方式就是口服抗病毒药，正规医院直接开的就是“恩替卡韦”这个药，这也是乙肝抗病毒药物中最好的一种。在治疗指南上，建议要持续吃4年，而且还要外加3年的巩固期，加起来是7年的时间，所以花的钱比干扰素要多。但是效果也会好很多，平均来看，经过1年的治疗以后，乙肝病毒 DNA 检测不到的概率是90%，转氨酶变成正常的概率是80%，所以比干扰素要好很多。如果按照指南上说，吃了4年，几乎两项都能变正常，那就是比例超过95%了。如果再巩固3年，7年下来之后，有部分患者就可以在医生的监督下停药了，还有极少数的患者在之后的一生里也没有吃药，也没有再复发。 有一个误区就是，乙肝病毒携带者可以通过治疗去除病毒，彻底治愈。这个说法，起码现在全世界是没有医生，没有人能做到的。 还有任何中成药、中药，或者奇奇怪怪的疗法，保健品，护肝药，都没有抗病毒作用，保不齐还会有肝毒性，所以都不要采纳 。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[大蒜能杀菌吗]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%A4%A7%E8%92%9C%E8%83%BD%E6%9D%80%E8%8F%8C%E5%90%97%2F</url>
    <content type="text"><![CDATA[大蒜能杀菌的“说法”是有根有据的，也有相关的研究，说大蒜里面包含大蒜素有抑制细菌生长的特性，之后就被各种误导性文章给宣传了，那么我们从科学的思维来分析下这个问题。 1、细菌在胃里，被胃黏液保护着， 大蒜需要经过胃酸洗礼，能不能接触的到胃里的微生物都不一定。比如喝下去的几亿个益生菌，经过胃酸再到肠道就不到100w个了。 2、一公斤大蒜含量0.1克大蒜素。 我们已另一种抗生素（青霉素）为例，如果一个人感染，每天用量是100w个单位青霉素，大概每天是0.6g，持续几天用药，可以治疗感染。那大蒜素也是一样的用量，那每天要吃6公斤。现在医学就是将有效成分提炼、浓缩到一个胶囊里才可以治病。不管是大蒜、还有其他任何食物都不可能对某种疾病有疗效，就是因为里面的有效成分太低了。类似的还有青蒿素，都是要提取才可以。 3、我们继续假设，有方案可以提取，那么吃了它能治疗细菌感染吗？大蒜之所谓分泌大蒜素，从某个角度考虑，它是在分泌一些毒素来杀害或警告要吃掉它的动物和微生物，所以大蒜素很可能是把肠道里所有的微生物都杀死。人体肠道微生物不是都是有害的，大部分还是有益的，如果都杀了， 那么你可能会拉肚子、口臭、身体消瘦等。你会天天吃青霉素吗？ 所以大蒜就是一种调味食品。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[减肥]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%87%8F%E8%82%A5%2F</url>
    <content type="text"><![CDATA[减肥不但让人看着精神，而且确实可以全面降低各种患病的风险。那如何减肥呢？ 1）、减肥靠锻炼、靠运动？从实际效果看，增加运动量来减肥效果是最差的。因为运动耗能特别慢，可是运动之后，马上又想吃饭，只要吃上两口，这效果就变负了。比如每周计划减掉1公斤脂肪，那么折合热量是3850大卡，那么每天就要减去550大卡。550大卡合算到运动，相当于慢跑1小时，每天坚持1小时慢跑是有点难度的，而且在运动后你还不能有进食。即使我们在毅力上可以控制运动后只喝水，但是饥饿的身体是不会欺骗自己的，你会不知不觉的在之后的一日三餐中多吃一点。运动减肥还有一个问题，就是消耗脂肪效率。人体在开始的一个月慢跑1小时消耗550大卡，但是身体适应能力很强，当身体适应了这个强度，那么脂肪的燃烧效率就会降低，所以你要经常改变自己的运动强度和节奏。长期运动即使无法减肥，但是它会让你身体各项指标都增强。 减肥效果最好的就是营养均衡的少吃，想要做到少吃，最需要的是意志力；同时你要考虑的是那些营养均衡的饮食法，否则就是对身体有害。 你一旦走上运动减肥这条路，实际上是给自己增加减肥难度，因为你是在完成减肥和增强体质两项任务，就需要更多的毅力了。如果身边有朋友是通过运动减肥下来，并且没有反弹的话，其他也可以隐射出这个人的意志力是非常强的。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[升高]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%8D%87%E9%AB%98%2F</url>
    <content type="text"><![CDATA[成年后身高就定了，什么训练方法，什么药都不管用。 身高70%是由基因决定的，剩下的30%就是在骨骺线完全闭合之前的营养、锻炼、睡眠，这些因素决定。对身高影响最大的骨头就是大腿和小腿骨的长度，只要它们的骨骺线闭合了，那就基本决定身高了。骨骺线女生在16岁，男生在18岁左右，基本都会闭合，所以成年后不可能增高。想要增高，就只能抓紧在这个时间点前，多跑多跳，这些活动能促进生长激素分泌，配合骨骼生长，就能长高个儿。还有就是注意多睡觉，睡觉时的生长激素分泌量也远高于清醒的时候。 成年后严格地说也不是完全没有增高方法，那就是通过手术。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事故报告(2019/07/12)]]></title>
    <url>%2F2019%2F07%2F17%2F%E4%BA%8B%E6%95%85%E6%8A%A5%E5%91%8A-1%2F</url>
    <content type="text"><![CDATA[事故时间2019/7/12 11：37 ~ 12：15 ，持续38分钟 事故描述移动用户无法登陆 事故原因根本原因：数据库硬盘物理损坏，RAID修复过程中IO超时。 事故总结短时间的IO超时，目前的服务器是能够承受的，但是长时间的IO超时带来的雪崩问题是需要总结的。 事实上我们的服务至少要把故障时间缩短为IO故障时间，比如IO故障5分钟，那么用户的故障时间也应该为5分钟，但目前的效果却是花费了35分钟的时间才恢复。 服务器的通讯库模型采用多线程竞争消费方式： tcp层将帧数据合并为一个用户请求包，丢入一个消息池 用户层启动n个消费线程，竞争方式去消息池取消息处理 这样设计的好处是每个线程的能力都得到最大的发挥，或者当一个线程出现问题时，其他线程仍然可以正常工作。 实际上如果IO发生长时间超时，用户发现登陆失败，就会不断的重试登陆，最后导致的结果是：消息池的消息堆积越来越多。即使当IO恢复后，消费线程仍然在处理之前堆积着的请求消息，从而故障的恢复时间变的延后。 处理方法 在tcp丢入消息池时给每个消息打一个时间戳 消费线程在处理某些IO消息时，判断当前时间和消息时间戳是否 &gt; n(s),超过则丢弃 这样当IO恢复时，服务也能快速恢复。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[问题的分析方法]]></title>
    <url>%2F2019%2F07%2F12%2F%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前面的文章中，总结了工作中一些常见问题的分析方法，总的来说工具是次要的，科学的分析方法是最重要的。当出现一个问题时，我们应该把问题正确的写下来： 问题是什么 假设问题的原因 证实每个问题的假设 预测实验的结果 观察实验的结果 有实验得出结论 科学方法最主要的目的就是让你能够准确地知道事情的真相，而不会误入歧途。 历史文章中列举了一些常见问题的分析过程： 内存泄漏 内存碎片 踩内存 死锁 崩溃 高cpu 优化情况下的dump分析 想对windbg调试有深入的了解，我推荐的书籍是： 《软件调试》 《高级软件调试》 《格蠹汇编》]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内存碎片分析]]></title>
    <url>%2F2019%2F07%2F12%2F%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[背景在上篇文章中进程状态可视化方案搭建了可视化界面，对于目前运行环境下的几百个服务器状态就非常清晰了，比如服务的虚拟内存，这时就发现一个服务存在问题： 红色线为virtual Bytes ，大概在1.4G左右绿色线为Private Bytes ， 大概在350M左右 那么应该是出现了严重的内存碎片（Fragmentation)。 往事在众多疑难问题定位过程中，我一直对刚参加工作时分析的一个内存碎片问题印象非常深刻，因为这个问题锻炼了我坚韧的耐力和大幅度技能的提升。 刚工作的时候被分配到一个视频组件组，主要功能就是网络收流、报文解析、音视频解码、视频渲染、音频同步播放，和当时的视频播放软件最大的区别就是多窗口，最大支持128个视频流同时播放。 当时一个大版本发布之后，长时间运行（1天）组件就会出现内存申请失败，这个问题刚好就交给我处理，当时整个公司都没有人会用分析dump，大家都是用vs进行调试，还有代码的回滚是不可能的，这个版本合入太多功能，其他团队、客户都等着这个版本呢。所以我的思路 第一步是减少问题复现的时间，通过3天左右的观察、验证，找到了业务流程，写了一个测试demo，将原来需要1天才复现的问题，减少到只需要2个小时左右。 在观察、验证的3天时间，查资料，找原因，把《windows核心编程》 内存方面仔细研读，上网找资料。大概可以锁定是内存碎片导致，而不是内存泄漏。 进行二分法对模块进行分解测试。所以短时间内我又要把整个组件的模块设计、流程学习一遍。 建立execl对测试结果数据进行分析 3~4 步骤坚持了1周左右。 大家可能都觉得应该能找到问题了吧？ 结论是 no， 没找到原因。 我们可以梳理下内存碎片的原因，大致就是 a、b 两个大小内存随机申请，最后会导致一个连续内存会被a、b大小内存随机分裂，最后有一个更大的C就无法申请到内存。如果采用二分划分，那么很有可能我们把C给排除了，把a、b 模块保留，这时候程序当然稳定运行，execl表格体现出来的就是这个a、b模块正常，但实际是存在问题的。 现实的程序远比上面的例子复杂的多，模块、开源库、第三方依赖都得考虑，这也是当时整理了1周左右的数据仍然定位不到原因。 问题的分析已经过去了1周半，却没有任何进展，手上堆积的事情也越来越多，这1周半几乎都是7~23点，身体、精神也吃不消，所以就换了一个同事重新整理execl；一周过后也是没有头绪。在这一周中，我赶完落后的项目进度，然后继续查找资料，在网上看到了一本《软件调试》的书籍，学习堆的知识，这一周客户、boss都催的紧，粗略的看完“堆”章节，里面有句话吸引到了我：123456789Heap中有两个参数1、HeapDeCommitFreeBlockThreshold2、HeapDecommitTotalFreeThreshold考虑到应用程序很可能还会立刻申请内存并减少与内存管理器的交互次数，内存释放时需要同时满足两个条件才能被立即解除提交1、释放的堆块超过HeapDeCommitFreeBlockThreshold的值（比如4KB）2、堆上的总空闲空间达到HeapDecommitTotalFreeThreshold（比如64K）否则，堆管理器会将这个块加到空闲块列表中，并更新堆管理器的总空闲值。 刚好我们的组件中有一个大小申请65535大小的空间，会不会因为刚好没到64K导致的？ 立刻把模块中的65535修改为65535+1， 经过验证后，程序还真稳定了……….其实也没根本解决问题，只是怀疑，所以内心一直觉的有所欠缺。 工作实在太忙，能力也有限，解决之后也没时间总结这个问题，还有好多事情要加班干呢……… 之后的windows上项目基本就很少出现内存碎片的问题，所以就没有这方面的分析经验。 问题再次分析刚好有程序又出现了类似问题，所以试着用dump来分析。首先我对出现问题的程序代码一点不熟悉，所以我很难去构建复现条件，只能暂时通过dump来分析。 上面截图显示了7天的内存变化，很稳定，有查看了30天的内存，基本也是一样，virtual size 还足够，Private Bytes也不高，所以问题的紧急程度不高，估摸着程序再继续运行一个月也没问题。保存了fulldump。 基础知识我们大致要了解内存申请的过程，commit、reserv、virtual size、Private Bytes的概念。堆的三个重要结构体：HEAP、Segment、Enty。不了解的话，可以先照猫画虎 来按步骤分析一遍。 dump下载下载提取码：ykgb windbgheap -s加载dump信息，输入1234567891011121314151617181920212223242526270:000&gt; !heap -sSEGMENT HEAP ERROR: failed to initialize the extentionLFH Key : 0x58b8f7f8Termination on corruption : DISABLED Heap Flags Reserv Commit Virt Free List UCR Virt Lock Fast (k) (k) (k) (k) length blocks cont. heap -----------------------------------------------------------------------------002a0000 00000002 1246976 510132 1246976 261431 2450 1382 0 5d6 LFH External fragmentation 51 % (2450 free blocks) Virtual address fragmentation 59 % (1382 uncommited ranges)00590000 00001002 3136 1636 3136 860 6 3 0 471b LFH External fragmentation 52 % (6 free blocks)00490000 00001002 256 4 256 1 1 1 0 0 004d0000 00001002 1280 420 1280 122 50 2 0 0 LFHVirtual block: 032f0000 - 032f0000 (size 00000000)Virtual block: 05310000 - 05310000 (size 00000000)00910000 00001002 1280 556 1280 136 4 2 2 0 LFH00b20000 00001002 64 12 64 4 2 1 0 0 00110000 00001002 64 4 64 2 1 1 0 0 03120000 00001002 64 4 64 2 1 1 0 0 00520000 00011002 256 4 256 1 2 1 0 0 032b0000 00001002 256 4 256 1 2 1 0 0 034d0000 00001002 3328 1996 3328 1050 49 3 0 6 LFH External fragmentation 52 % (49 free blocks)05420000 00001002 64 16 64 13 1 1 0 0 00960000 00001002 1088 212 1088 77 2 2 0 0 ----------------------------------------------------------------------------- 也可以看出 002a0000 的resevr 比 commit 大了很多。 ps:里面有“Virtual block:” 代表的是超过508K的内存是使用HeapVirtualAlloc申请的，其中（size 00000000）指的是找不到HEAP_VIRTUAL_ALLOC_ENTRY的结构体定义（不知道怎么解决）。 !heap -a 002a0000打印该堆段所有的内存信息，（截取一部分）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Segment80 at 54790000: Flags: 00000000 Base: 54790000 First Entry: 54790040 Last Entry: 55760000 Total Pages: 00000fd0 Total UnCommit: 00000b0f Largest UnCommit:00000000 UnCommitted Ranges: (9) Heap entries for Segment80 in Heap 002a0000 address: psize . size flags state (requested size) 54790000: 00000 . 00040 [101] - busy (3f) 54790040: 00040 . 40000 [101] - busy (3fff8) Internal 547d0040: 40000 . 40000 [101] - busy (3fff8) Internal 54810040: 40000 . 40000 [101] - busy (3fff8) Internal 54850040: 40000 . 00fa0 [100] 54850fe0: 00fa0 . 00020 [111] - busy (1d) 54851000: 0063d000 - uncommitted bytes. 54e8e000: 00000 . 01000 [100] 54e8f000: 01000 . 40000 [101] - busy (3fff8) Internal 54ecf000: 40000 . 40000 [101] - busy (3fff8) Internal 54f0f000: 40000 . 40000 [101] - busy (3fff8) Internal 54f4f000: 40000 . 40fe0 [100] 54f8ffe0: 40fe0 . 00020 [111] - busy (1d) 54f90000: 000fe000 - uncommitted bytes. 5508e000: 00000 . 40000 [100] 550ce000: 40000 . 01000 [101] - busy (ff8) Internal 550cf000: 01000 . 40000 [100] 5510f000: 40000 . 20000 [101] - busy (1fff8) Internal 5512f000: 20000 . 10000 [101] - busy (fff8) Internal 5513f000: 10000 . 03fe0 [100] 55142fe0: 03fe0 . 00020 [111] - busy (1d) 55143000: 0000b000 - uncommitted bytes. 5514e000: 00000 . 40000 [100] 5518e000: 40000 . 40000 [101] - busy (3fff8) Internal 551ce000: 40000 . 00fe0 [100] 551cefe0: 00fe0 . 00020 [111] - busy (1d) 551cf000: 001ff000 - uncommitted bytes. 553ce000: 00000 . 40840 [100] 5540e840: 40840 . 40000 [101] - busy (3fff8) Internal 5544e840: 40000 . 00400 [101] - busy (3f8) Internal 5544ec40: 00400 . 003a0 [100] 5544efe0: 003a0 . 00020 [111] - busy (1d) 5544f000: 000be000 - uncommitted bytes. 5550d000: 00000 . 01000 [100] 5550e000: 01000 . 40000 [101] - busy (3fff8) Internal 5554e000: 40000 . 40fe0 [100] 5558efe0: 40fe0 . 00020 [111] - busy (1d) 5558f000: 0000e000 - uncommitted bytes. 5559d000: 00000 . 00800 [100] 5559d800: 00800 . 10000 [101] - busy (fff8) Internal 555ad800: 10000 . 10000 [101] - busy (fff8) Internal 555bd800: 10000 . 407e0 [100] 555fdfe0: 407e0 . 00020 [111] - busy (1d) 简单的含义123456789Segment80 at 54790000: ----- 第80个堆块链表 Flags: 00000000 Base: 54790000 First Entry: 54790040 Last Entry: 55760000 Total Pages: 00000fd0 Total UnCommit: 00000b0f Largest UnCommit:00000000 UnCommitted Ranges: (9) ------ 有9个未提交的内存 123456789address : psize . size [flags] state (requested size) &lt;debug flags&gt;堆块地址 前一堆块大小 当前堆块大小 状态 状态描述 用户实际分配的大小 哪种堆调试支持5544efe0: 003a0 . 00020 [111] - busy (1d)5544efe0: enty 的地址： 5544efe0+8 就是内存实际地址003a0: 上一个内存块的大小0020: 当前堆块大小busy： 使用中1d: 实际分配的大小 那么把所有链表统计一下大概出现了 1300多次的uncommitted bytes，其中大致浏览存在着1000多次的40000内存busy状态，基本上每个uncommitted 的内存附件都有一个40000的内存，那么是否可以怀疑是40000导致的呢？40000的堆块大小实际用户申请大小是 3fff8，刚好是256K-8 。逐一查看内存内容也没有找到任何线索。 至此dump的分析导致为此，剩下的过程就需要查看是哪里申请了这么大的内存？ 代码review 用gflags打开栈回溯，问题复现后，通过内存地址进行栈回溯找到内存申请的代码 总结问题其实没有被定位，后续有时间会继续跟踪此问题。事实上即使找到内存申请的地方，也不一定能解决。实际对于这种大块(&gt;4KB)的内存申请应该需要谨慎，写代码中也应该尽量避免大块内存的申请，可以考虑使用内存池；windows本身是有低块堆来解决小内存的申请，但申请的内存大小有限；偷懒可以直接使用jemalloc/tcmalloc库 本文只是提供了一种分析思路。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进程状态可视化方案]]></title>
    <url>%2F2019%2F07%2F10%2F%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[背景当出现问题时，我们收集无法查看历史的进程信息，比如前一小时的cpu利用率、内存使用量等信息。本方案结合大数据的elk系统提供可视化的报表数据。 elk = Elasticsearch Logstash Kibana 搭建一套集中式日志系统。 每个进程定时5s上报进程状态到elk系统，然后通过kibana进行报表输出。 状态上报协议udp + json 每个进程接入组件后，组件会定时启动一个线程以5s间隔上报进程状态，通过udp协议，json负载的格式。 采集方式使用windows性能计数器api：API介绍： 1、PdhOpenQuery：获取性能监视器数据查询句柄； 2、PdhAddCounter：添加计数器； 3、PdhCollectQueryData：查询性能监视器数据； 4、PdhGetFormattedCounterValue：获取指定计数器数值； 参考代码： https://blog.csdn.net/sqcfj/article/details/7307148 进程关键状态信息进程已处理消息数作为后台服务器，通过该数值可以评估该台服务器的负载 进程消息队列堆积数服务器采用生产、竞争消费模式设计，当消费线程无法处理时，生产队列会发生堆积，所以需要定时上报生产者队列当前数量，已评估服务器是否正常。 比如堆积 &gt;300 时，钉钉警告 ; &gt; 1000 并持续上涨时，需及时进行问题分析 进程cpu1pdh: \\Process(&quot;calc&quot;)\\% Processor Time 建议值80以内。获取的是该进程在单核下的cpu值。 进程handle count1pdh: \\Process(&quot;calc&quot;)\\Handle Count 内核对象数量。如果程序稳定，handle应该维持在一个稳定区间，持续上涨说明存在handle leak 进程提交内存1pdh: \\Process(&quot;calc&quot;)\\Private Bytes 提交内存，如果持续上涨，说明存在 memory leak 进程虚拟内存（保留空间）1pdh: \\Process(&quot;calc&quot;)\\Virtual Bytes 保留内存，vitrual bytes 和 private byte 一般保持一个相对稳定的比例关系。大Virtual size（比如1.0G）时如果他们的比例大于 &gt;2 时，需要考虑是否存在严重的内存碎片，仅参考意义 进程ID1pdh: \\Process(&quot;calc&quot;)\\ID Process 进程id号，如果发生变化则说明服务存在重启 进程客户端数量统计服务器当前tcp的连接数 进程的磁盘空间其他进程日志导致磁盘满，导致服务异常， 当磁盘空间&lt;1.0G时上报告警 和钉钉对接状态的上报只解决了历史的信息查询，对于当前紧急问题需要及时通知到钉钉群。 elk 系统和告警中心进行对接负载中的json中携带 “level” 字段，当 = “warn” 时elk转发消息给告警中心，告警中心处理钉钉消息 组件直接发送钉钉通过json中的 “level” = “warn” 时，组件直接发送告警信息到指定钉钉群 kibana报表自己是报表白痴，所以操作方式自己作为笔记写下来：1234567visualize选择“line”选择“hallgame”(自定义的）过滤器Metrics 的Y-Axis 选择“Max”, Field 选择”tcCpu”(举例)，lable 填写 &quot;cpu利用率&quot;Buckets 的X-Axis 选择”Data Histogram“Buchets 的Split Series 选择”terms“，Filed 选择&quot;svraddr&quot;(代表不同的进程）， order by 默认（指得是排序），size 填20均可然后运行，就可以看到所有服务的 cpu利用率了。 效果在kibana中配置报表消息，可看到如下效果：]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[electron学习]]></title>
    <url>%2F2019%2F07%2F05%2Felectron%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[介绍主要讲我第一次使用electron的感受，简直是非常糟心！ 安装步骤安装node.js设置npm代理1npm --registry https://registry.npm.taobao.org info underscore electron 项目npm install时经常会下载卡死，然后报错误，很是麻烦，即使设置了代理也是很慢，所以很不想用electron,要经常尝试 npm install。 安装electron123npm install -g electron --verbose--verbose 查看安装进度 输入“electron” doc ： https://electronjs.org/docs?utm_source=default_app 查看文档 repository: github 资源 api demo 如上可看可不看，我是从官网开始入门的： https://electronjs.org/ 学习下载 electron api demo下载 electron-quick-start按照提示一步步都还算正常 参考api demo尝试 糟糕的开始 自己在electron-quick-start 上怎么验证都没有任何反应，index.html、renderer.js 验证了很多次就是不行。无奈只能去github 找到electron-api-demos-master 源码下载查看，并比较了相关代码，并没有发现自己哪里有写错。上网搜索electron 提供的其他示例“simple-samples”，也未找到相关原因。 调试在main.js 中增加 ，12// Open the DevTools. mainWindow.webContents.openDevTools(); 提示”const {BrowserWindow} = require(‘electron’).remote “ 这行“Uncaught ReferenceError: require is not defined”， 还有如下提示12For more information and help, consulthttps://electronjs.org/docs/tutorial/security. 打开提示网站将网站看完，并看到“Disable the remote module”，并去electron api demo 中查找main.js 中窗口的对应设置，发现需要增加 “nodeIntegration: true” 12345678910function createWindow () &#123; // Create the browser window. mainWindow = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; preload: path.join(__dirname, &apos;preload.js&apos;), nodeIntegration: true &#125; &#125;) 测试验证增加之后，点击‘new-window’ 按钮，并弹出了一个新的对话框。 总结别人的demo是由浅入深，electron第一个demo就困了我一天，这坑也太大了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[禅与摩托车维修艺术]]></title>
    <url>%2F2019%2F07%2F04%2F%E7%A6%85%E4%B8%8E%E6%91%A9%E6%89%98%E8%BD%A6%E7%BB%B4%E4%BF%AE%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[时间2019/07/04 ~/07/24 介绍去年在某网站上看到有人推荐这本书，刚好自己也骑了一段时间的摩托，所以就买了这本书。今天翻开看了几页，还是非常有意思的。至于这本书有多好看，你自己来感受吧！ 书看了100多页，手贱google了一下“斐德洛”，奉劝大家不要google“斐德洛”，带着好奇看完吧。 这并不是一本如何修理摩托车的书，而是一本人生哲理书。123456在这次旅行中，我想应该注意一点，更深入地研究，看看是否能够了解究竟是什么把人和人的工作分离开来，进而了解20世纪的人究竟出了什么问题。我并不想仓促行事，因为仓促本身就是20世界最要不得的态度，当你做某件事情的时候，一旦要求快，就表示你再也不关心它，而想去做别的事。所以我想慢慢来，用我找到被剪断了的销子的态度，有了这种态度才能发现原因，这样才能仔细而且透彻地进行这件事，除此之外，别无他法。 摘录12345678骑摩托车旅游和其他的方式完全不同。坐在汽车里，你只是被局限在一个小空间之内，因为已经习惯了，你意识不到从车窗向外看风景和看电视差不多。你只是个被动的观众，景物只能呆板地从窗外飞驰而过。而摩托车可就不同了。它没有什么车窗玻璃在面前阻挡你地视野，你会感到自己和大自然紧密的结合在了一起。你就处在景致之中，而不再是观众，你能感受到那中身临其境的震撼。脚下飞驰而过的是实实在在的水泥公路，和你走过的土地没有什么两样。它结结实实地躺在那儿，虽然因为车速快而显得模糊，但是你可以随时停车，及时感受它的存在，让那份踏实感深深印在你的脑海中。 123如果人类所有已知的知识体系是一个巨大的体系，那么心灵的高山地带就出现在这个体系的最高处，它是所有思想当中最抽象也是最普遍的。很少有人到此一游，因为你不能从这一趟旅程当中获得任何实质上的利益。但是就像我们周遭的这一片高山区，它有它庄严的美感，所以对某些人来说，即使费劲九牛二虎之力到此一游也是值得的。来到心灵的高山地带，一个人必须习惯不稳定的稀薄空气，还有大量的问题以及各种假设的答案。这种情形会不断地扩大，一直到这个人几乎无法控制，因为迟疑是否接近它，因为他害怕很可能会在其中迷失，而且永远找不到出路。 结束坚持看了200页左右，等过个3、4年再来看吧。关于民哲的书籍，自身能力、知识还达不到理解的程度，看下去收获不会太大。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蛋白质]]></title>
    <url>%2F2019%2F07%2F03%2F%E8%9B%8B%E7%99%BD%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[蛋白质即使有某种神奇的功效，吃它也不能让它直接进入人体发挥作用，而是会再胃肠中被消化成氨基酸，再被人体吸收，所以不管吃的是什么蛋白质，结局都一样，都是消化成了组成蛋白质的氨基酸。组成蛋白质的氨基酸共有20种。有的蛋白质（鸡蛋、牛奶、肉类的蛋白质）含有全部的20种氨基酸，叫做完全蛋白质，营养价值高；而有的蛋白质（植物蛋白）则是不完全蛋白，缺某种氨基酸，营养价值较差；胶原蛋白缺少色氨酸和半胱胺酸，是不完全蛋白，因此营养价值不高。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[黄疸]]></title>
    <url>%2F2019%2F07%2F03%2F%E9%BB%84%E7%96%B8%2F</url>
    <content type="text"><![CDATA[黄疸通常是肝脏等器官有疾病的症状，但是婴儿则不然。90%的新生儿在出生一天后会开始出现黄疸；这是因为新生儿红细胞数量多，更新快，因此胆红素高，但是肝脏功能还不完善，处理能力很低。一般持续两周左右黄疸消失。黄疸一般来说是无害的，但是持续时间过长，有可能会造成脑损伤。因此需要治疗，国际流行方法使用的是光疗，使用蓝光照射婴儿皮肤；少数婴儿是疾病引起的，比如胆道锁闭，这就需要手术。国内的一些医院，夸大了黄疸的严重性，需要用药，对此是没有西药的，所以就只能用中药“茵（陈）栀（子）黄（芩）”。目前并没有科学依据和临床试验能证明有效，反而增加了婴儿肝脏、肾脏的药物损害。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[妙趣横生-博弈论]]></title>
    <url>%2F2019%2F07%2F03%2F%E5%A6%99%E8%B6%A3%E6%A8%AA%E7%94%9F-%E5%8D%9A%E5%BC%88%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[时间2019/06/29 ~ 2019/07/03 感想看了1/3 看不下去了，主要是没有大块的时间来阅读消化，里面讲了很多博弈的例子。剩下的估计要等以后有时间再看了。摘录了其中比较好的观点：1博弈论中最重要的教训：一个人必须理解对方的想法。在本性上，人们都倾向于以自我为中心，只关注自己的理解和自身的需要。但策略的艺术要求，不要以自我为中心，要理解他人的立场、观念以及看重什么，并运用这种理解来指导工作。 1人与人之间的博弈，对于我们普通大众来说，能够做到更加成熟，充满宽容和对他人的理解就很不错了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[信息来源介绍]]></title>
    <url>%2F2019%2F07%2F03%2F%E4%BF%A1%E6%81%AF%E6%9D%A5%E6%BA%90%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[收集了自己仅几年看到、听到、经历过的一些科学健康方法，信息来源： 卓老板聊科技（得到app、喜马拉雅） 方舟子书籍、音频节目（企鹅fm） 哈弗家庭医生全书（推荐家中必备） 默沙东诊疗手册（app、web） 科普中国（app） 丁香园 科普书籍《肠子的小心思》 《众病之王-癌》 google 比较喜欢 卓老板聊科技 的节目，听的多了，知识的收获只是一小部分，更多的学习到科学的思维方式，并让其成为日常生活思考的一部分，这对于我是收获最大的。 后面的内容会摘抄一些对我个人有帮助的一些知识。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[几种语言的http服务框架]]></title>
    <url>%2F2019%2F06%2F25%2F%E5%87%A0%E7%A7%8D%E8%AF%AD%E8%A8%80%E7%9A%84http%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[介绍刚好需要做一个http服务，所以简单的研究了下几种语言http框架的入门使用 C++libevent+http https://github.com/yingchengpa/httpsvr 自己写了一个多线程版本的，封装了大部分功能，只要注册指定 uri的回调处理就可以了。 性能、并发性良好。 mongoose之前在某个服务里面使用，主要用于获取配置，调用频率不高，使用简单 pythonFlask使用vs2019 创建一个flask工程，然后按照提示使用pip 安装flask，就可以实现一个简单的http服务。使用起来还是挺简单的。没验证过性能、并发性如何。 gogin使用起来和flask差不多。go就是需要科学上网比较麻烦 luaopenrestrynginx.conf 配置文件12345678910111213141516171819202122232425262728293031323334 server &#123; listen 8090; server_name localhost; # 获取post 请求的body lua_need_request_body on; # 对于开发研究，可以对代码 cache 进行关闭，这样不必每次都重新加载 nginx。 lua_code_cache off; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; location /v1.0/open/ai &#123; default_type text/html; content_by_lua_file ai.lua; &#125; location /v1.0/open/action &#123; default_type text/html; content_by_lua_block &#123; dofile(&quot;action.lua&quot;) &#125; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 12345在解压根目录下创建 ai.lua、action.lua 内容如下local data = ngx.req.get_body_data()local method = ngx.req.get_method()ngx.say(&quot;the method is &quot;, method) 12nginx lua api：https://github.com/openresty/lua-nginx-module#nginx-api-for-lua 其他语言比如.net、java、js 应该有更多http服务框架，这部分不了解！]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[魔鬼经济学（4）]]></title>
    <url>%2F2019%2F06%2F21%2F%E9%AD%94%E9%AC%BC%E7%BB%8F%E6%B5%8E%E5%AD%A6%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读书时间2019/06/21~2019/06/28 讲的是作者博客里面有趣的问题，快速的就看完了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[参数错误导致异常]]></title>
    <url>%2F2019%2F06%2F19%2F%E5%8F%82%E6%95%B0%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[背景某游戏钉钉联系我说出现dump导致模板异常，因为模板是我负责的，所以就顺便看了下 dump链接：https://pan.baidu.com/s/1pyrJXtv26zLvhvfS3Ts2rA提取码：48fo 分析过程查看异常点1234567891011121314151617181920212223240:034&gt; .ecxr;kveax=0631f54c ebx=09798e18 ecx=00000003 edx=00000000 esi=740cbc8c edi=0631f5eceip=754bc54f esp=0631f54c ebp=0631f59c iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000202KERNELBASE!RaiseException+0x58:754bc54f c9 leave *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 0631f59c 73d69339 e06d7363 00000001 00000003 KERNELBASE!RaiseException+0x58 (FPO: [Non-Fpo])0631f5dc 7402ee11 0631f5ec 740cbc8c 740db540 msvcr120!_CxxThrowException+0x5b (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]*** WARNING: Unable to verify checksum for cfddsvr.exe0631f5f0 009f89ea 0070f490 0731e5f8 0070f498 mfc120!AfxThrowInvalidArgException+0x19 (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\except.cpp @ 228]0631f608 00940e55 0999e748 00000008 00000000 cfddsvr!CHwTable::SetBottom+0xda (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_gametplserver1.0\tcghw1.0\trunk\tcghw\tcghw.cpp @ 849]0631f624 009610bb 0999e748 37cbe17c 00000000 cfddsvr!CGameTable::OnSetBottom+0x185 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_cfddsvr\common\cfdd\cfddtbl.cpp @ 880]0631f6fc 00960a48 071f8bb8 09998398 007047d8 cfddsvr!CGameServer::OnSetBottom+0x55b (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_cfddsvr\cfddsvr\server.cpp @ 709]0631f76c 00968ed4 071f8bb8 09998398 0070f498 cfddsvr!CGameServer::OnRequest+0x1f8 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_cfddsvr\cfddsvr\server.cpp @ 68]0631f794 0096da9d 00000000 02950748 029c18e0 cfddsvr!CIocpWorker::DoWorkLoop+0xa40631f7ac 0096da6b 0631f7ec 73d7c01d 0070f490 cfddsvr!CBaseWorker::WorkerThreadProc+0x2d0631f7b4 73d7c01d 0070f490 a7e5bfa1 00000000 cfddsvr!CBaseWorker::WorkerThreadFunc+0xb0631f7ec 73d7c001 00000000 0631f804 769c343d msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]0631f7f8 769c343d 029c18e0 0631f844 77109802 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]0631f804 77109802 029c18e0 e12c35d8 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])0631f844 771097d5 73d7bfb4 029c18e0 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])0631f85c 00000000 73d7bfb4 029c18e0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 出错代码1234567891011121314void CHwTable::SetBottom(LPSET_BOTTOM pSetBottom)&#123; memcpy(m_nBottomIDs, pSetBottom-&gt;nBottomIDs, sizeof(m_nBottomIDs)); for(int i = 0; i &lt; m_nBottomCards; i++)&#123; int shape = CalculateCardShape(m_nBottomIDs[i]); int value = CalculateCardValue(m_nBottomIDs[i]); m_nCardsLayIn[m_nBanker][shape * m_nLayoutMod + value]--; int x = GetCardNO(m_nBottomIDs[i]); m_aryCard[x].nStatus = CS_BOTTOM; //---- 849 m_aryCard[x].nChairNO = m_nBanker; &#125;&#125; 心中猜测应该就是 x 计算错误，导致m_aryCard(CArray)异常了 !analyze -v 查看异常原因12345678EXCEPTION_RECORD: (.exr -1)ExceptionAddress: 754bc54f (KERNELBASE!RaiseException+0x00000058) ExceptionCode: e06d7363 (C++ EH exception) ExceptionFlags: 00000001NumberParameters: 3 Parameter[0]: 19930520 Parameter[1]: 0631f5ec Parameter[2]: 740cbc8c 是一个C++异常，很符合MFC的CArray的行为，具体查看原因 123456780:034&gt; dd 740cbc8c l4740cbc8c 00000000 00000000 00000000 740cbc9c0:034&gt; dd 740cbc9c l2740cbc9c 00000005 740cbc700:034&gt; dd 740cbc70 l2740cbc70 00000001 740e0d380:034&gt; da 740e0d38 + 8740e0d40 &quot;.PAVCInvalidArgException@@&quot; 明显的一个 “InvalidArgException” 说明有的同学想看下CHwTable::SetBottom 中x 的参数内容，但是却看不到，其实是因为模板（publish_gametplserver1.0）层是开启了代码优化，所以看不到内容； 可以切换到上层CGameTable::OnSetBottom 这里查看成员变量的值（这个模块是没有开启优化的）]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[转义字符导致hiredis异常]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%BC%E8%87%B4hiredis%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[背景C++ 在使用redis时使用的是hiredis库，在项目中碰到一个问题，某天钉钉提示服务catch error，于是就分析保存的dump dump 路径链接：https://pan.baidu.com/s/1CdhOVKwtP5fabTyab8UTDw提取码：8ull 分析过程.ecxr加载符号文件，然后‘.ecxr’ ‘kv’1234567891011121314151617181920212223242526270:018&gt; .ecxr*** WARNING: Unable to verify checksum for actiksvr.exeeax=00000005 ebx=004f7228 ecx=00000001 edx=00000005 esi=e298348b edi=1002002beip=7457211c esp=062ff8a8 ebp=062ff8d4 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010202msvcr120!TrailDownVec+0x14f:7457211c 8a16 mov dl,byte ptr [esi] ds:002b:e298348b=??0:018&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 062ff8b4 011a36d6 1002002b e298348b 004f7228 msvcr120!TrailDownVec+0x14f (FPO: [3,0,2]) [f:\dd\vctools\crt\crtw32\string\i386\memcpy.asm @ 844]062ff8d4 011a2da2 00000003 e298348b 004f7228 actiksvr!sdscatlen+0x56062ff92c 011a2ae3 062ff940 0bf7d158 062ff968 actiksvr!redisvFormatCommand+0x242062ff944 011a2472 0052ce80 0bf7d158 062ff968 actiksvr!redisvAppendCommand+0x13062ff958 01181e31 0052ce80 0bf7d158 e298348b actiksvr!redisAppendCommand+0x12062ffa48 011820ca 0c6c2335 062ffa5c e2983443 actiksvr!CRedisMaster::SetPlayerInfo+0x1a1 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_gamechannel\actiksvr\redismaster.cpp @ 71]062ffa80 01189135 0c6c2335 062ffb00 e298327f actiksvr!CRedisMaster::SetPlayerInfo+0x6a (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_gamechannel\actiksvr\redismaster.cpp @ 42]062ffcbc 0118975a 07660e78 0f2f9490 03dfa5d0 actiksvr!CSockServer::OnLogon+0x215 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_gamechannel\actiksvr\socksvr.cpp @ 553]062ffd0c 0118eb84 07660e78 0f2f9490 001df010 actiksvr!CSockServer::OnRequest+0x2aa (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_gamechannel\actiksvr\socksvr.cpp @ 227]062ffd34 0119367d 00000000 04d611d0 03db0be0 actiksvr!CIocpWorker::DoWorkLoop+0xa4062ffd4c 0119364b 062ffd8c 7458c01d 001df008 actiksvr!CBaseWorker::WorkerThreadProc+0x2d062ffd54 7458c01d 001df008 53e9f2fa 00000000 actiksvr!CBaseWorker::WorkerThreadFunc+0xb062ffd8c 7458c001 00000000 062ffda4 7702336a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]062ffd98 7702336a 03db0be0 062ffde4 77559902 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]062ffda4 77559902 03db0be0 c036ffd3 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])062ffde4 775598d5 7458bfb4 03db0be0 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])062ffdfc 00000000 7458bfb4 03db0be0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 因为有类似经验（看过hiredis解析代码），猜测应该就是有特殊字符（比如 % 等）导致 查看参数通过 ‘local’ 查看CSockServer::OnLogon 对应代码的参数，发现 其中imei 字符串中包含了 ‘%’ ,然后再编写demo验证，问题必现。 解决方法知道原因，解决方法就很多了， 可以用标准的redis方法void redisCommand(redisContext c, const char *format, …); 我使用的是替换法：1234inline void redis_cmd_escape(std::string &amp;str)&#123; replace_all(str, &quot;%&quot;, &quot;%%&quot;);&#125;]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开启代码优化分析dump]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%BC%80%E5%90%AF%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90dump%2F</url>
    <content type="text"><![CDATA[背景前面都是讲解程序未开启优化时的问题定位。当程序未开启优化时，通过‘local’，‘watch’,’kv’ 的参数信息都是正确的，所以很容易可以通过变量的内容确定问题的原因。 但是如果开启了程序优化功能，那么编译器会优化代码的结构，windbg还是按照原来的方法来解析变量，那么大多情况会出现不正确的，比如最重要的this指针，未优化时都是固定在ecx寄存器中，但是开启了优化后就需要自己来查找对应的this地址。 前段时间川麻服务出现崩溃，就遇到了这么一个问题。 dump信息下载链接：链接：https://pan.baidu.com/s/1nQOksK2QLUZsQsl7PhgDCw提取码：4c1o c/c++的调用约定C 语言： cdecl、stdcall、fastcall、naked、pascal。 C++ 语言： cdecl、stdcall、fastcall、naked、pascal、thiscall，比 C 语言多出一种 thiscall 调用方式。 thiscall 调用方式是唯一一种不能显示指定的修饰符。它是C++类成员函数缺省的调用方式。由于成员函数调用还有一个this指针，因此必须用这种特殊的调用方式。 thiscall调用方式意味着： （1）参数从右向左压入栈。 （2）如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压入栈后被压入栈。参数个数不定的，由调用者清理堆栈，否则由函数自己清理堆栈。 可以看到，对于参数个数固定的情况，它类似于stdcall，不定时则类似于cdecl。 分析dump下载指定的dump，并使用windbg打开，加载好符号文件。输入命令：”.ecxr” ,显示异常上下文：123456789101112131415160:043&amp; .ecxreax=0000ffff ebx=00435a18 ecx=04921dc4 edx=060de888 esi=0d7ed468 edi=00000001eip=00b9d4e7 esp=070efde8 ebp=070efdf4 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010202xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x37:00b9d4e7 ff30 push dword ptr [eax] ds:002b:0000ffff=????????0:043&amp; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 070efdf4 00bf54dc 00435f8c 070efe74 0c8bc458 xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x37 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_xzmosvr\gamesvr\commonbase\commonbaseserver.cpp @ 218]070efe88 733dc01d 00000000 76fc49d0 00000000 xzmoSvr!CMainServer::SoapThreadProc+0x29c (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_gametplserver2.0\tcgame2.0\trunk\tcgsvr.cpp @ 9565]070efec0 733dc001 00000000 070efed8 75ad338a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]070efecc 75ad338a 04981c78 070eff18 77b89f72 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]070efed8 77b89f72 04981c78 75257f9b 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])070eff18 77b89f45 733dbfb4 04981c78 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])070eff30 00000000 733dbfb4 04981c78 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 大致可以猜测是访问非法指针导致的异常。然后查看代码：123456789101112131415BOOL CCommonBaseServer::DealApplyBaseWelfareEx(LPSOAP_SERVICE pSoapService, IXYSoapClientPtr&amp;amp; pSoapClient, LPCONTEXT_HEAD lpContext, LPREQUEST lpRequest)&#123; BOOL bResult = __super::DealApplyBaseWelfare(pSoapService, pSoapClient, lpContext, lpRequest); LPAPPLY_BASEWELFARE_EX lpApplyWelfare = (LPAPPLY_BASEWELFARE_EX)lpRequest-&amp;pDataPtr; if (bResult &amp;amp;&amp;amp; lpApplyWelfare &amp;amp;&amp;amp; 0 &lt;= lpApplyWelfare-&amp;nSoapReturn) &#123; if (m_pDataStats) &#123; m_pDataStats-&gt;m_datastats_onapplywelfare(lpApplyWelfare-&amp;nRoomID, lpApplyWelfare-&amp;nUserID); ---------&amp; 这行出现问题 &#125; &#125; return bResult;&#125; 并查看异常期间的参数信息： 刚开始主程序分析就以为是m_pDataStats = NULL 导致崩溃，原因可能是多线程导致，接着就开始review代码。 但是reivew之后发现m_pDataStats是不能为NULL的（除非进程关闭），然后又是一阵思考、联想、分析…….. 无果。接着猜测是否是踩内存导致（这个review代码难度就有点大了)……… 但实际这个dump发生异常的原因不是因为m_pDataStats = NULL导致，而是某个指针的值=0x0000ffff导致，这个在dump中有明确说明：12xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x37:00b9d4e7 ff30 push dword ptr [eax] ds:002b:0000ffff=???????? ds:002b::0000ffff 在访问0000ffff地址时发生异常！！！！！！ 但为何看this指针中的m_pDataStats 明明是 NULL啊？ 这就是代码开启优化的原因导致this指针不正确。 如何找到正确的this指针地址呢？通过汇编代码，看优化后的入参方式.使用命令“alt+7”可以打开汇编代码：函数原型：1BOOL CCommonBaseServer::DealApplyBaseWelfareEx(LPSOAP_SERVICE pSoapService, IXYSoapClientPtr&amp;amp; pSoapClient, LPCONTEXT_HEAD lpContext, LPREQUEST lpRequest) 首先我们先查看下this 指针存放在哪里12340:043&gt; dv /V this@ecx @ecx this = 0x04921dc4表明是放置在 ecx寄存器中 然后查看汇编代码：1234567891011121314151617181920212223242526 xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare:00b9d4b0 55 push ebp00b9d4b1 8bec mov ebp, esp00b9d4b3 53 push ebx00b9d4b4 56 push esi00b9d4b5 8b7514 mov esi, dword ptr [ebp+14h]00b9d4b8 8bd9 mov ebx, ecx --- 临时保存00b9d4ba 57 push edi00b9d4bb 56 push esi00b9d4bc ff7510 push dword ptr [ebp+10h]00b9d4bf ff750c push dword ptr [ebp+0Ch]00b9d4c2 ff7508 push dword ptr [ebp+8]00b9d4c5 e806b10300 call xzmoSvr!CMainServer::DealApplyBaseWelfare (00bd85d0)00b9d4ca 8bf8 mov edi, eax00b9d4cc 8b461c mov eax, dword ptr [esi+1Ch]00b9d4cf 85ff test edi, edi00b9d4d1 741e je xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x41 (00b9d4f1)00b9d4d3 85c0 test eax, eax00b9d4d5 741a je xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x41 (00b9d4f1)00b9d4d7 83784000 cmp dword ptr [eax+40h], 000b9d4db 7c14 jl xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x41 (00b9d4f1)00b9d4dd 8b8bf8af0000 mov ecx, dword ptr [ebx+0AFF8h] --- 被重新赋值00b9d4e3 85c9 test ecx, ecx00b9d4e5 740a je xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x41 (00b9d4f1) -- 崩溃的地方00b9d4e7 ff30 push dword ptr [eax]00b9d4e9 ff7004 push dword ptr [eax+4] 可以看到ecx的地址被临时保存到ebx中，在后续出现异常之前，ecx又被赋值成了其他值，通过之前异常的寄存器信息可以看到ebx的值1234560:043&amp; .ecxreax=0000ffff ebx=00435a18 ecx=04921dc4 edx=060de888 esi=0d7ed468 edi=00000001eip=00b9d4e7 esp=070efde8 ebp=070efdf4 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010202xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x37:00b9d4e7 ff30 push dword ptr [eax] ds:002b:0000ffff=???????? ebx=00435a18， 使用’watch’查看this指针内容： 可以确定m_pDataStats 不仅指针有效，而且里面的内容也是正确的。所以异常并不是m_pDataStats异常导致。 那么问题就是lpApplyWelfare 这个指针导致。 这时候查看入参lpRequest 内容 pDataPtr=0x0000ffff和dump提示的异常指针内容相符，所以可以确定是这个指针导致的。 所以重新对lpRequest进行代码review，发现问题的本质原因：__super::DealApplyBaseWelfare(pSoapService, pSoapClient, lpContext, lpRequest);在执行过程中，会将lpRequest 指针post到B线程中执行，而B线程是会释放lpRequest指针的。 所以在低概率情况下，会出现多线程崩溃问题。 修改方式：先copy内存到局部变量，再执行super逻辑。 结论因为开启了代码优化，导致一开始在分析dump时走向了错误的道路，浪费了时间。在碰到开启代码优化时，查找正确的指针就变的有点困难。 所以不是很建议新上线的服务开启代码优化，反而增加了问题定位的难度。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ini 解析器]]></title>
    <url>%2F2019%2F06%2F13%2Fini-%E8%A7%A3%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[介绍windows 的ini读取使用 GetPrivateProfileInt等函数，需要切换到跨平台接口 比较对象 windows函数 iniDoc类 simpleini boost 属性树 测试数据 10w 次读操作 ini 大小10k 库 读性能 (ms) boost 属性树 85658 windows 自带 8600 iniDoc 28094 simpleini 34641 10w次读操作 ini大小1k 库 读性能 (ms) boost 属性树 – windows 自带 7672 iniDoc 5718 simpleini – 结论性能瓶颈应该在模式设计上，除windows以外的库，都是先把ini文件读入内存，然后解析所有的key、value；而windows应该是先查找到文件位置然后只获取附近的key、value即可。 暂时采用iniDoc，并在代码中尽量规避频繁读写ini文件。只要配置文件不要过大，完全可以用inidoc替换]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[消息队列 性能比较]]></title>
    <url>%2F2019%2F06%2F13%2F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[介绍windows下使用的是postthreadmessage、getmessage,考虑要跨平台，所以打算自己实现消息队列 无锁队列原理CAS操作——Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的CPU指令都支持CAS的原子操作。 CAS的原子指令：12345678bool compare_and_swap (int *accum, int *dest, int newval)&#123; if ( *accum == *dest ) &#123; *dest = newval; return true; &#125; return false;&#125; GCC的CAS： 123bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...) windows 的CAS： 123InterlockedCompareExchange ( __inout LONG volatile *Target, __in LONG Exchange, __in LONG Comperand); C++11中的CAS 123456template&lt; class T &gt;bool atomic_compare_exchange_weak( std::atomic* obj, T* expected, T desired );template&lt; class T &gt;bool atomic_compare_exchange_weak( volatile std::atomic* obj, T* expected, T desired ); 无锁队列就是基于CAS来实现的。 备选方案std::list + std::mutexboost::lockfree::queueboost::lockfree::spsc_queue测试性能方法 生产500w数据 消费500w数据 串行消费耗时 测试机器1windows i5-7500 @3.4GHz 测试代码写的有点乱123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;mutex&gt;#include &lt;list&gt;#include &lt;thread&gt;#include &lt;boost/lockfree/queue.hpp&gt;#include &lt;boost/lockfree/spsc_queue.hpp&gt;#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;int g_count = 0;std::mutex g_oMutex;std::list&lt;int&gt; g_oList;boost::lockfree::queue&lt;int&gt; g_queue(512);boost::lockfree::spsc_queue&lt;int, boost::lockfree::capacity&lt;5000000&gt; &gt; spsc_queue;int g_max = 5000000;int GetMs()&#123; const boost::posix_time::ptime now = boost::posix_time::microsec_clock::local_time(); // Get the time offset in current day const boost::posix_time::time_duration td = now.time_of_day(); int hh = td.hours(); int mm = td.minutes(); int ss = td.seconds(); int ms = td.total_milliseconds(); return ms;&#125;void func_producer()&#123; for (int i = 0; i &lt; g_max; i++) &#123; //g_oMutex.lock(); //g_oList.push_back(i); //g_oMutex.unlock(); spsc_queue.push(i); &#125;&#125;void func_consume()&#123; for (int i = 0; i &lt; g_max; i++) &#123; /*g_oMutex.lock(); g_oList.pop_front(); g_oMutex.unlock(); g_count++;*/ int n; if (spsc_queue.pop(n)) &#123; g_count++; &#125; &#125;&#125;int main()&#123; int dwTime = GetMs(); std::thread t2(func_producer); t2.join(); std::thread t1(func_consume); t1.join(); int diff = GetMs() - dwTime; printf(&quot;lost time is %d ,count is %d \n&quot;, diff, g_count); //system(&quot;pause&quot;); return 0;&#125; 结论 队列 时间(ms) windows 未验证 list+mutex 766 lockfree::queue 1156 lockfree::spsc_queue 47 单生产单消费模式下lockfree::spsc_queue 的确最优秀，但是我们的服务采用的是多生产单消费模式，所以还是暂时先用list+mutex]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vs2019 创建linux项目]]></title>
    <url>%2F2019%2F06%2F13%2Fvs2019-%E5%88%9B%E5%BB%BAlinux%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[背景计划将公司的部分稳定服务切换到linux环境下 以前linux下的开发方式是 ssh + samb + source insight + makefile + g++。在windows下用 source insight看代码，然后ssh到centos 服务器上，然后执行编译。 现在看到vs2019也可以编译，所以尝试试试。 安装centos略 安装gcc略 安装gdbserveryum install gdb-gdbserver vs2019创建linux项目可参考 https://blog.csdn.net/zyzmzm_/article/details/89044885 注意点x64 x86 切换即使gcc支持了32位版本编译，vs2019 中将解决方案平台切换为x86，也会提示错误，尝试解决不了。 规避方法就是再创建一个基于x64解决方案平台命名为(xx86)，然后在c++、lib 的“其他选项”中增加gcc x86编译选项“-m32”，这样编出来的程序是32位的 无法远程调试在“属性”“调试”，修改“调试模式”为 gdbserver 无法远程调试即使设置了gdbserver调试，仍然无法调试， 请“关闭防火墙”。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[魔鬼经济学（3）]]></title>
    <url>%2F2019%2F05%2F31%2F%E9%AD%94%E9%AC%BC%E7%BB%8F%E6%B5%8E%E5%AD%A6%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读书时间2019/05/11 ~ 2019/06/18 像魔鬼一样思考承认自己不知道下次当你面对不懂的问题时，请直说“我不知道”。当然，可以加一句—-“但或许我可以找到答案。”然后尽你所能寻找答案。你会惊讶地发现人们是多么欢迎你的坦诚。 你的问题是什么吸取两个广义的经验： 关于解决问题的一般方式。 1小林尊重新定义了问题。他的对手问了什么问题呢？基本是：我怎样才能让吃更多的热狗？小林尊问了一个不同的问题：我怎么样才能让热狗更容易下咽？这个问题引导他进行实验，不断优化策略。在重新定义问题后，他才发现了一系列新的答案。 我们接受或拒绝接受的极限 1请仔细考虑忽视一些虚无的障碍，如果事先就给自己下判定无法做到，那就是难上加难。 真相在问题的根源面对人们已经研究过的问题并找出新的解决途径，需要思考者真正具有独创精神。为什么能做到这点的人少之又少？或许因为，我们多数人在寻找答案时都倾向于最接近、最显而易见的的原因。很难说这是后天形成的习惯，还是祖先遗留的基因所致。 像孩子一样思考1寻找乐趣、浅显思考、不惧惯俗---这些都是孩子们惯常的行为，而至少我们认为，成年人若能保留住这些特质，将会受益匪浅。 尽管如此，我们并不是建议你以8岁小孩为榜样重塑一切行为习惯。这样做产生的问题肯定比它能解决的多。然而如果我们能够把一部分童年的直觉带到成人世界里，那不是很好吗？那样，我们会说更多忠于自己的话，问更多我们在乎的问题，甚至能够甩掉一部分最危险的成人特质：虚伪。 想象你是一名魔术师，那么最难欺骗的反而是儿童。 爱吃糖的孩子12如果又魔鬼式思考者赖以生存的真言，那就是：人们会对诱因做出反应。了解一个情形中针对每个当事人奏效的诱因，是解决问题的根本。诱因并不总是那么容易找到，经济、社会、道德、法律等，它们作用于不同的方向，力度也不相同。但如果你像进行魔鬼式思考，那就必须学着成为诱因大师---好的、坏的以及丑陋的。 举例：12345在某国家森林公园里写上警示牌：‘每天，自然遗产都会遭到破坏，石化木以每年14吨的速度被偷盗......’最后的结果是，被偷盗的反而更多。公园警示牌意在传达道德信息，但或许表达出来的却是：哇，石化木快没了---那我得赶紧拿一份；或者：一年14吨？那我拿几块肯定不成问题。 1人类是复杂的动物，私下或公开场合的诱因有着微妙的差别，而且人们的行为在很大程度上受到具体环境影响。你一旦了解了诱因背后的心理因素，便可以利用自己的聪明才智建起有效的诱因机制。 如何说服不想被说服的人？或许你提出了令人不适的问题，挑战了传统，或者是碰到了不该触碰的话题。因此人们开始对你颇有微词。我们能提供给你的最佳建议其实很简单：微笑并转换话题。用开创式的思维思考并解决问题很困难，然而经验告诉我们：说服不想被说服的人，难上加难。 你先要明白说服一个人是多么困难，以及背后的原因。 与我无关，都是为了你 1每次当你试图说服他人时，请记住，你只是论点的制造者，对方的意见才重要。你的论点或许无可辩驳，逻辑无懈可击，但如果没有给对方带去共鸣则丝毫不具意义。 别以为自己的论点是完美的 1如果你掩饰了计划中的缺陷，那就是给了对方怀疑整个计划的理由。 要肯定对方论点中的合理之处 对立的观点几乎总是有价值的。你可以从中学到东西并强化自己的观点。 如果对方认为自己的观点被忽视，也不太可能用心与你交谈。 把那些辱骂留在自己心里吧 1辱骂别人只会带给你一个敌人，而非盟友。 为什么你该讲故事 12最有力的说服手段：讲故事。故事能描绘出全貌。 放弃的好处 为什么你没有放弃： 我们从小到大一直被那些想当丘吉尔的人们告诫：放弃是失败的标志。 沉没成本 人们往往把过多注意力放在了实际成本而不是机会成本 1理性的人需要学会懂得放弃。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++架构优化]]></title>
    <url>%2F2019%2F05%2F30%2F%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[背景介绍公司是一家小的游戏公司，日活百万左右，同时最高在线人数30w左右。公司的核心服务使用C++开发，生产环境是windows.游戏基础服务主要职责就是承载公司游戏的登陆、业务逻辑、通知、游戏数据结算、玩家信息统计等功能，而具体的游戏逻辑在各个游戏团队的游戏服务中负责。 游戏基础服务一旦出现问题，玩家就无法游戏，因为无法登陆、无法结算…. 所以是需要高可靠的服务。 我的主要职责就是维护基础服务的稳定运行。 以上是职责介绍，下面是刚入职时基础服务的架构。 早期的架构架构基本是按照业务单元进行分服务开发，但也不像微服务那么细微。 大致讲解： 整个架构是比较清晰的，而且按照功能进行划分，所有服务都支持横向扩展，db使用分库分表设计。所以在性能上、横向扩展都没有太大问题。 但实际在维护的过程中，还是会发现很多不合理的地方。 升级一个简单的功能，需要重启很多重要的服务。每次升级都很纠结 版本发布、代码编写很不方便 出现问题定位很费时间 问题随机、随时出现，没任何预兆………… 大量的非工作时间被白白浪费！！！！！！！！ 不合理的地方1自己的备忘录里面记录了服务大致需要整改的点有100多处 生产工具落后使用的还是VC6 编译器。无法使用c++1x的语法、写代码不方便、开源库不好支持等等 没有持续集成环境版本发布依赖领导的时间。（生产环境的版本必须由领导的机器编译），有次出现问题，问题定位5分钟，版本发布却花了3个小时。 服务无法灰度升级服务升级都要在凌晨6点升级，而且升级过程中整体服务无法使用 单个服务异常影响整体整个架构里面服务相互链接构成网状，当某个服务异常时，常常会关联其他服务出现异常 整体服务容错性不足单台block、check异常，就会导致这个节点上的所有玩家和游戏出现异常 没有健康监控功能出现问题都是玩家反馈，研发自己都不知道服务是否出现异常； 没有预警机制当性能、内存、io等不足时没有提早告知进行准备 定位方法落后采用原始的vistual stdio 调试，没有分析dump的能力 msmq 功能扩展、维护、定位麻烦服务的管理、配置落后整体架构缺陷这个涉及点比较多，后续慢慢展开。 整改原因就是想做！！ 优化点升级开发工具到vs2013服务性能监控服务消息堆积数量、进程cpu、磁盘容量、提交内存大小 数据到大数据平台。出现问题时，基本都是第一时间就能够在钉钉收到预警通知。 使用jenkins进行持续集成windbg分析的持续培训C++的优化原来都采用的MFC的CMap、CString、线程、锁等都需要替换为stl、boost类型 调整架构，支持灰度发布1目前还在持续优化中 设计的方法： 模块设计“幂等性” 服务尽量无状态这样游戏、玩家可以随机指定链接，然后引入负载均衡+域名管理，就可以方便地地给服务器导流，支持灰度升级 重试次数控制 + 熔断 redis缓存、MQ 异步 隔离设计 将影响玩家的业务和统计业务，中间搭建 actik中转服务隔离开来所有下游统计业务都需要经过actik服务进行清洗，然后才能到具体的业务服务中去 玩家隔离比如将pc、移动、微信玩家连接的服务进行隔离，减少影响面。 使用rabbitmq替换msmqrabbitmq支持AMQP协议，扩展、管理、维护都非常方便 数据库的优化分库、分表；购买新硬件、数据备份、导入导出使用mqsql 替换sql server 总结无意间看到一篇服务弹力设计的文章，总结的比我好，自己就是朝这个方向在调整！ 后续计划 引入稳定的gate服务 统一配置中心 linux化 服务go语言化 效果 基础服务稳定性提高非常明显，两年就没出现过重大事故。 升级也方便了很多，大部分都可以灰度升级。 线上出现问题也能快速定位，出现问题心不慌。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[精益产品开发]]></title>
    <url>%2F2019%2F05%2F28%2F%E7%B2%BE%E7%9B%8A%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[读书时间：2019年3月 人们认识到，遵循严格生命周期的概念，把开发分割为顺序阶段构成的过程，实施起来不现实，造成了以下直接的危害。 1、希望通过各个阶段设置关卡，严格控制，以期更早地发现问题，却滞后了集成和测试，让错误的发现延迟到最后，这是很多项目失败的根源。 2、希望一开始就能设定完整和正确的需求，这对软件产品越来越不可能，因为用户也不知道或说不清楚自己想要什么。事实上，对需求的挖掘和理解，应该是一个持续的过程，需要不断的反馈。 3、把成功定义为“遵循最初的计划和范围”。为了确保项目的“成功”而避免或拒绝进行合理的变更，却忽略了“达成商业目标才是真正的成功”。这已经成为业务成功的一个严重障碍。 4、传统产品开发方法强调控制，所以一旦流程出现问题，自然的应对就是进一步加强管控，流程本身有自我复杂化的趋势，反而会压制关键软件人员的主观能动性。 ——————————————- 《丰田之道2001》—————————————- 精益生产的两大支柱： 1、持续改进 1）、挑战现状：我们构建长远的愿景，以勇气和创造力来面对挑战和实现梦想 2）、改善：我们持续改进业务运营，不断追求创新和进化 3）、现地现物：我们践行现地现物，去源头发现事实，做出正确的决策，建立共识，最快速地达成目标。 2、尊重人 1）、我们相互尊重，竭尽全力理解对方，承担责任，建立互信。 2）、我们激励个体及其职业的提升，共享发展的机会，最大化个人和团队绩效。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[未来简史]]></title>
    <url>%2F2019%2F05%2F28%2F%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[读书时间：2019年3月 1、研究历史，就是为了挣脱过去的桎梏，让我们能看向不同的方向，并开始注意到前人无法想象或过去不希望我们想象到的可能性。观察我们走到现在的一连串意外事件，就能了解人类的每个念头和梦想是如何变成现实的，然后我们就能开始以不同的方式思考并编织出不同的梦想。研究历史并不能告诉我们应该如何选择，但至少能给我们提供更多的选项。回首过去，很多人都会认为法老时代的结束以及“上帝已死”的概念都是社会的进步，或许人文主义的崩塌也是好事。人们之所以不愿改变，是因为害怕。但历史唯一不变的事实，就是一切都会改变。 2、人文主义三大分支 1）、正统派（自由主义）：认为每个人都是独特的，拥有独一无二的内在声音、永不重复的一连串体验。每个人都像一道不同的光线，从不同的角度照亮世界，为这个宇宙增添色彩、深度和意义。因此，我们应该让每个人都尽量自由自在地体验世界、听从自己内心地声音、表达自己心中真实地想法。不管在政治、经济还是艺术中，个人的自由意志都应该比国家利益或宗教原则更为重要。个人能享有的自由越多，整个世界就会变得越美丽、丰富、有意义。自由主义政治认为，选民能做出最好得选择。自由主义艺术认为，观看作品得人觉得美，就是美。自由主义经济学者认为，顾客永远是对的。自由主义理论认为，只要感觉对了，就该去做。自由主义教育认为，我们要为自己思考，因为从内心就能找到所有答案。 2）、xx人文主义。xx认为主义走的道路则非常不同。xx主义责怪自由主义过于注重自己的感觉，而不顾他人的感受。xx主义并不鼓励自我探索，而是主张简历强有力的集体制度（比如政党和工会），为我们解读这个世界。xx主义政治认为政党能做出最好的选择。各种权威和意义仍然来自人类的体验，但个人必须听从政党和工会的决定，而不是自己的个人感觉。 3）、进化人文主义]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[魔鬼经济学（2）]]></title>
    <url>%2F2019%2F05%2F27%2F%E9%AD%94%E9%AC%BC%E7%BB%8F%E6%B5%8E%E5%AD%A6%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读书时间：2019/05/09 – 2019/05/27 魔鬼经济学==慌谬怪诞经济学？ 酒后步行比酒后驾车还要危险！ 电视把印度女性解救了出来？ 遏制气候变暖：火山喷发，用烟囱捅破天，还是架一根18英里长的管子？恐怖分子的银行账号有什么特点？ 想长寿吗？拿个诺贝尔奖吧也有一些方式是可以延长你的寿命的，但这与去医院看病毫无关系。比如你得个诺贝尔奖或者选入名人堂。但是，既没能在科学领域取得卓越的成绩，也没能成为一流的运动员，对于普通人最好就是去买份养老保险—确保你退休后每年可以领取固定数额的收入，直至你去世。养老保险提供娟娟细流般的稳定收入，使这些老人多了那么一点点动机—要努力活得更久一些。 如果你的病情很严重，去医院看病会略微提高你存活下来的概率；但如果病情并不严重，那么去看病就会提高你死亡的概率。生活中很多清形之反常、之不可理喻。 难以置信：犯罪率升高时因为电视看多了？行为经济学 疫苗、安全带和飓风：不一样的事情、一样的逻辑1看来毫无头绪的大难题，其解决方案竟如此称奇 接生时发生的产褥热 &lt;劳动法&gt;也会损害劳动者 硝酸铵养活了整个世界 没有什么医疗手段比疫苗更简单 安全带有多安全 儿童座椅的安全效应 从预防重伤的情形来看，标配安全带与2-6岁儿童用的安全座椅表现同样出色。但是从轻伤的情况看，儿童座椅的表现更好：受伤的概率大约下降了25%。儿童座椅还能带来另外一个好处，这可是无法用价格来衡量的—父母内心的安宁。 相比起儿童座椅，还有简单且便宜的方案，就是针对儿童体型设计的安全带。总所周知：政府不喜欢寻求更便宜、更简单的解决方案，相反，往往倾向于选择价格昂贵、麻烦棘手的对策。 街头妓女与百货商店圣诞老人有何相似之处可以了解到妓女的真实生活、收入情况；适合从业人员好好研究，学习！]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[醉汉的脚步]]></title>
    <url>%2F2019%2F05%2F10%2F%E9%86%89%E6%B1%89%E7%9A%84%E8%84%9A%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[读书时间2019/02/11 - 未完 摘要顶着人类的直觉破浪而行，是一件困难的事。如所要看到的那样，人类头脑至构造，是要给每一个事情找出确定理由，因为它难以接受无关或随机因素所造成的影响。因此，我们首要要认识到，成败有时并非来自于过人的能力或无能，而是来自于如经济学家艾智仁所说的“幸运的环境”。 随机过程就本性而言非常基本，再日常生活中也无所不在，但不多数人却不了解它，或者很少想到它。 一部伟大小说的创作—或说一件珠宝或一块洒上了巧克力碎块的曲奇饼，和这部小说印刷成书后在数以万计的零售店前高高堆起的书堆—或说成套的珠宝或成袋的曲奇饼，这两者间有着移到随机性和不确定性的鸿沟。之所以各领域的成功人士都几乎无例外地属于特定的一类人—-那些从不放弃的人，其原因就在于此。 许多发生在我们身上的事情—职场上、投资上以及在生活中或大或小决策方面的成功—–都是随机因素的结果，这些因素的影响一点儿也不比我们的能力、勤奋与为把握机会而做好准备的影响来得小。因此，我们所认识得现实，并不是人或环境得直接反映，而是被不可预见或不断变化的外部力量所随机化后的模糊映像。这并非说能力无关紧要—能力正是增加成功机会的因素之一—但行动与结果之间的联系，可能并非如我们所乐于相信地那么直接。因此，理解过去不容易，预测未来同样不容易。在这两种情况下，如果能超越肤浅地解释去观察问题，我们将受益匪浅。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从杭州到长白山滑野雪]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%BB%8E%E6%9D%AD%E5%B7%9E%E5%88%B0%E9%95%BF%E7%99%BD%E5%B1%B1%E6%BB%91%E9%87%8E%E9%9B%AA%2F</url>
    <content type="text"><![CDATA[心血来潮2017年初突然心血来潮想去北方滑野雪，比较了几个北方的滑雪场，再考虑到春节时机票太贵，所以决定四月去长白山天池滑雪，顺便还可以看看天池美景。长白山万达度假村的滑雪场是在3月底关闭，天池滑雪是在4月底关闭，所以4月份去滑天池雪性价比高，当时价格是500/人。具体信息可以关注微信公众号“长白山天池雪”。 交通杭州没有直达长白山的航班，只能选择上海浦东国际机场的春秋航空。事实证明最方便快捷，而且淡季出行机票价格大都在199. 周五中午从杭州出发，上沪昆高速、申嘉湖高速抵达茂莜停车场，然后bus接送到机场T2航站楼，办理登机手续。 17:50飞机起飞，20:45抵达长白山机场。 坐上万达度假村的直到bus 21：30 到达酒店。 由于刚下过雨，路上看到很多人在抓雪蛤，对我来说挺新奇的。 温度出发时还担心会太冷，淘宝了雪地靴、帽子其实都用不到；真正有用的是手套，在天池上冷风很大，不带手套手几乎瞬间就冻僵。4月的长白山温度大概在7-8度，比杭州多穿一件衣服就可以了。 之前准备的雪地靴、帽子、厚衣服完全用不到。 酒店乘坐万达度假村的bus到达万达喜来登酒店，偌大的酒店只有二三十个客人。酒店设施还是不错，只是淡季这里的交通不太方便， 礼宾给我们联系了出租车， 第二天包车出发去西坡滑雪。 滑雪第二天吃完早餐，前往长白山西坡，一路上白雪还在融化，万物都在等待着5、6月份的复苏。4月份其实风景真不怎么样，雪也没有、绿树也没有。 达到西坡门口，在滑雪窗口领了滑雪票，然后坐上景区环保车，同车的还有6个专业滑雪人士。 汽车一路盘旋从980M的海拔一直颠簸到了1700M的海拔，到达滑雪小屋。此时的风景已经和山下大不同了，一片片白茫茫的雪景，心中激动万分。这么久的等待和准备就是为了见到这样的雪景。山上并不冷，一件羊绒衫、一件冲锋衣已经足够了。换上滑雪装备，坐上雪地摩托，冲锋到了2200M的海拔给我们这两个初学者准备的雪场。之间有个插曲，滑雪最好自带好干粮（一定要有牛肉，体能消耗很大）、温水，山顶自行解决午饭问题。而我没带东西饿到不行，后来还是到了滑雪小屋吃了碗面重新上来，浪费了不少时间。雪地摩托过于刺激，期间有个大叔为了展示他的技术，我差点被他从车上甩下来。滑雪过程不多描述，体验非常不错。 休息时刻，我们去了2600M高的天池，山顶风好大，如果不带手套，一会儿就可以让你的手冻僵，所以照片拍的不多。4月的天池还都是冰，阳光很好、蓝天白云、白雪，站在天池边，凝视着这个经过几百万年岁月洗礼还如此安静的美景，感受那种空旷的美，绝对值得留恋 …… 4月份的季节长白上除了滑雪其实风景也没什么好看的，所以周日我们就在酒店休息，等待回家，本想再滑一天，无奈摔的太疼起不来了。 周日晚上20：00的飞机回到上海，然后取车开回杭州。 其实可以周五去，周六回，时间全完足够。 机场离酒店很近的…… 费用1、机票去410，回199, 加上50的机场建设费，30的保险费 总共 1500（两人）注意：春秋航空托运是要另外收费的哦。 2、酒店万达喜来登 710/晚（含双早） 总共：1420 3、交通费茂莜停车场：90杭州到浦东机场的汽油和过路费 总共：550 4、长白山交通费总共 300 5、滑雪两人 999，包含了景区门票和环保车费吃饭 100总共 1099 6、其他总共 500 两人总共 5500 左右。 景色这就是初学滑雪场，就我们两个人玩。 从下往上看，对于初学者还是比较陡的。 专业的滑道是从天池开始往下滑的，偷拍的一张。 在天池边拍的全景，中间那个冰池就是天池了。 下雨时当地居民抓的雪蛤。]]></content>
      <categories>
        <category>走走看看</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中老年人麻将消消游戏]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%B8%AD%E8%80%81%E5%B9%B4%E4%BA%BA%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[自己用cocoscreate 做的一款中老年麻将消消游戏，发现爸爸、妈妈、老婆很喜欢，有版权哦！！ 游戏入口麻将消消PC版 玩法说明通过查找最上层相同的麻将点击消除，其中左上角有三张交换牌。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[魔鬼经济学（1）]]></title>
    <url>%2F2019%2F05%2F09%2F%E9%AD%94%E9%AC%BC%E7%BB%8F%E6%B5%8E%E5%AD%A6%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读书时间2019/04/24 – 2019/05/09 摘要《教师与相扑力士有何共同点》 探讨动机的优点及阴暗面—-作弊 《为何三K党和房地产中介是一路货色》论证了信息的力量无可比拟，这种力量一旦遭到滥用，则更显露无疑 《为何毒贩还在与母亲同住》发现传统观念往往是由捏造信息、自身利益和方便之词共同构成的。其实大多毒贩并不是很有钱 《罪犯都去那儿了》分析了有关犯罪的说法哪些是真，哪些是假 《怎样才算完美的父母》从多个角度提出了一个迫切的问题：父母真的重要吗？ “童年早期的纵向研究”中与学校考试成绩相关的8个因素： 父母学历高父母在生育第一胎时的年龄为30或30岁以上出生体重低父母在家讲英语父母参加家长教师联谊会家中藏书多 以及8个无关的因素： 家庭完整父母最近搬入了条件较好的小区母亲在孩子出生后至上幼儿园之前不工作参加过启智计划定期随父母去博物馆经常被打经常看电视几乎每天都听父母读书 笼统来讲，前8个因素是对父母特点的描述，后8个因素是对父母行为的描述。高学历、事业有成、身体健康的父母所生育的子女往往能在学校取得优异成绩；但儿童是否去博物馆、是否被打、是否参加启智计划、是否经常听父母读书，或是否坐在电视机前不离身视乎并无影响。 对于喜欢钻研养儿育女之道的父母——和育儿专家—-来说，这或许是值得深思的发现。事实上，这些育儿知道视乎被严重高估了。 但这并不是说父母毫无影响，显然，父母对育儿而言关系重大。难点在于，当多数人准备拾起育儿经的时候，为时已晚，因为真正重要的因素—-身份、配偶、生活方式—–早已注定。如果你天资聪慧、踏实肯干、教育水平高、收入颇丰且配偶也条件相当，那你的孩子就有更大的概率能在生活中有所成就（正直诚实、体贴周到、富有爱心、对世界充满好奇心想必也不会有害处）。 而至于你的所作所为则并无太大影响，重要的是你本身的特质。 《完美的父母序章》分析了正式为人父母后的第一件事—给孩子起名—-究竟有多重要。 总结作者通过数据分析，理性并有理有据的证明一些有趣的观点，虽然事实并非真的如此，但也是从一个客观地角度考虑事实。对我印象比较深的，就是《怎样才算完美的父母》：儿童早期的学习成绩大概率在父母结婚时就决定了，50%是基因，剩下最重要的就是父母本身的特质，而后天的行为（比如上培训班）影响并不大。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ EH exception]]></title>
    <url>%2F2019%2F05%2F08%2FC-EH-exception%2F</url>
    <content type="text"><![CDATA[介绍某个代理服务器在压力测试时发生异常，以下是定位过程 保存dump因为提早有知道程序会出现异常，所以中间省去了很多步骤，在服务启动时就已经使用windbg attach到了服务进程上，这样一旦程序触发异常windbg立即就会捕获。dump下载：链接：https://pan.baidu.com/s/1Ntm3MRQnbMqGtLkAushSvg 提取码：nvu1 分析过程程序异常在程序运行了15小时之后，程序触发了异常，windbg 上使用 命令 !analyze -v 分析异常原因123456789101112131415161718192021222324252627282930313233343536Failed calling InternetOpenUrl, GLE=12002FAULTING_IP: KERNELBASE!RaiseException+5876dcc42d c9 leaveEXCEPTION_RECORD: ffffffff -- (.exr 0xffffffffffffffff)ExceptionAddress: 76dcc42d (KERNELBASE!RaiseException+0x00000058) ExceptionCode: e06d7363 (C++ EH exception) ExceptionFlags: 00000001NumberParameters: 3 Parameter[0]: 19930520 Parameter[1]: 026ffa68 Parameter[2]: 746dc7fcDEFAULT_BUCKET_ID: APPLICATION_FAULTSTACK_TEXT: 026ffa18 746c9339 e06d7363 00000001 00000003 KERNELBASE!RaiseException+0x58026ffa58 7470da6a 026ffa68 746dc7fc 746dd1cc msvcr120!_CxxThrowException+0x5b [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]026ffa78 009ba351 00004400 03d95cc8 03d95d20 msvcr120!operator new+0x50 [f:\dd\vctools\crt\crtw32\heap\new.cpp @ 62]026ffa8c 009c9c01 00004400 03d95cc8 009c9824 roommpsvr!std::vector&lt;unsigned char,std::allocator&lt;unsigned char&gt; &gt;::_Buy+0x41026ffad4 009c9b9f 0324d520 00621598 2cf7d616 roommpsvr!std::vector&lt;unsigned char,std::allocator&lt;unsigned char&gt; &gt;::vector&lt;unsigned char,std::allocator&lt;unsigned char&gt; &gt;+0x21026ffb08 009c2858 08cb66d8 2cf7d606 045aad60 roommpsvr!mp::MPSocket::create_ssl+0x5f026ffb9c 009c5987 026ffbf8 0000020f 026ffc18 roommpsvr!mp::WSSConnection::handle_judge_protocol+0x248026ffbac 009c5341 026ffbe8 026ffbe8 2cf7d6de roommpsvr!boost::asio::asio_handler_invoke&lt;boost::asio::detail::binder2&lt;boost::_bi::bind_t&lt;void,boost::_mfi::mf2&lt;void,mp::WSConnection,boost::system::error_code const &amp;,unsigned int&gt;,boost::_bi::list3&lt;boost::_bi::value&lt;boost::shared_ptr&lt;mp::WSSConnection&gt; &gt;,boost::arg&lt;1&gt;,boost::arg&lt;2&gt; &gt; &gt;,boost::system::error_code,unsigned int&gt; &gt;+0x17026ffc18 009b603d 00643940 045aad60 026ffc4c roommpsvr!boost::asio::detail::win_iocp_socket_recv_op&lt;boost::asio::mutable_buffers_1,boost::_bi::bind_t&lt;void,boost::_mfi::mf2&lt;void,mp::WSConnection,boost::system::error_code const &amp;,unsigned int&gt;,boost::_bi::list3&lt;boost::_bi::value&lt;boost::shared_ptr&lt;mp::WSSConnection&gt; &gt;,boost::arg&lt;1&gt;,boost::arg&lt;2&gt; &gt; &gt; &gt;::do_complete+0x101026ffc78 009b5ba7 2cf7d166 026ffcc8 2cf7d1aa roommpsvr!boost::asio::detail::win_iocp_io_service::do_one+0x17d026ffcb4 009b63fa 026ffcc8 00647e70 00647e70 roommpsvr!boost::asio::detail::win_iocp_io_service::run+0xc7026ffcd0 00b182de 2cf7d1e6 00000000 00651090 roommpsvr!boost::asio::io_service::run+0x2a026ffcf8 746dc01d 00647e70 ff4a9697 00000000 roommpsvr!boost::`anonymous namespace&apos;::thread_start_function+0x5e026ffd30 746dc001 00000000 026ffd48 769f337a msvcr120!_callthreadstartex+0x1b [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]026ffd3c 769f337a 00650900 026ffd88 77389882 msvcr120!_threadstartex+0x7c [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]026ffd48 77389882 00650900 a6a6cb5f 00000000 kernel32!BaseThreadInitThunk+0xe026ffd88 77389855 746dbfb4 00650900 ffffffff ntdll!__RtlUserThreadStart+0x70026ffda0 00000000 746dbfb4 00650900 00000000 ntdll!_RtlUserThreadStart+0x1b 查看堆栈从堆栈信息中可以看到，在mp::MPSocket::create_ssl 中new了对象，然后new.cpp@62 抛出了一个异常1234567891011void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc) &#123; // try to allocate size bytes void *p; while ((p = malloc(size)) == 0) if (_callnewh(size) == 0) &#123; // report no memory _THROW_NCEE(_XSTD bad_alloc, ); ----------&gt;&gt;&gt; @62 &#125; return (p); &#125; 查看内存信息使用工具processxp 查看对应服务的内存状态，虚拟内存、提交内存 都是很低的，不太可能会出现内存申请失败。 进一步确认原因12345678EXCEPTION_RECORD: ffffffff -- (.exr 0xffffffffffffffff)ExceptionAddress: 76dcc42d (KERNELBASE!RaiseException+0x00000058) ExceptionCode: e06d7363 (C++ EH exception) ExceptionFlags: 00000001NumberParameters: 3 Parameter[0]: 19930520 Parameter[1]: 026ffa68 Parameter[2]: 746dc7fc google 搜索 “e06d7363 (C++ EH exception)”， 查看链接：https://blogs.msdn.microsoft.com/oldnewthing/20100730-00/?p=13273按照它的步骤进一步确认C++ 异常原因：123456780:008&gt; dd 746dc7fc l4 ---&gt; 是小写的“L&quot;746dc7fc 00000000 746e3cc0 00000000 746dc80c0:008&gt; dd 746dc80c l2746dc80c 00000002 746dd1ac0:008&gt; dd 746dd1ac l2746dd1ac 00000010 74790d380:008&gt; da 74790d38 + 874790d40 &quot;.?AVbad_alloc@std@@&quot; 发现的确是 “bad_alloc@std” 导致的异常。 仔细观察物理机器的状态，发现其中一个redis服务吃了大概2G多的内存，会不会是这个原因导致服务进程在申请pagefile时失败呢？ 杀掉异常进程继续观察。 总结长时间观察程序正常。本文的目的主要是介绍如何解码c++异常的具体原因。 附其他操作1026ffa58 7470da6a 026ffa68 746dc7fc 746dd1cc msvcr120!_CxxThrowException+0x5b (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152] 123__CxxThrowException( void* pExceptionObject, // The object thrown _ThrowInfo* pThrowInfo // Everything we need to know about it 746dc7fc 其实就是_ThrowInfo 结构体的指针信息，通过watch查看1234567typedef const struct _s__ThrowInfo&#123;unsigned int attributes;_PMFN pmfnUnwind;int (__cdecl*pForwardCompat)(...);_CatchableTypeArray *pCatachableTypeArray;&#125; _ThrowInfo; 结构体中重要的成员是_CatchableTypeArray。它包含了程序运行时抛出对象的类新信息(RTTI).如果你的程序运行时抛出一个my_exception类型的对象，那么抛出的数据参数pCatchableTypeArray包含了两个重要子数据信息。一个是typeid(my_exception)，另外一个是typeid(std::exception)。 所以通过watch查看：12345(ThrowInfo*)0x746dc7fc 0x746dc7fc struct _s_ThrowInfo *-attributes 0-pmfnUnwind 0x746e3cc0-pForwardCompat 0x00000000-pCatchableTypeArray 0x746dc80c struct _s_CatchableTypeArray * 123dd 0x746dc80c 746dc80c 00000002 746dd1ac 746e3b04 eb0cc483746dc81c be575612 7478fcb0 790d68bf 047e8374 12345678910watch 中查看(_s_CatchableType*)0x746dd1ac(_s_CatchableType*)0x746dd1ac 0x746dd1ac struct _s_CatchableType *-properties 0x10-pType 0x74790d38 struct TypeDescriptor *--hash 0x746bec94-spare 0x00000000--name char [] &quot;.?AVbad_alloc@std@@&quot;-thisDisplacement struct PMD-sizeOrOffset 0n12-copyFunction 0x746dd190]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows下c++反射功能]]></title>
    <url>%2F2019%2F05%2F08%2Fwindows%E4%B8%8Bc-%E5%8F%8D%E5%B0%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[背景c++开发的软件在生产环境中运行出现一些bug，比如参数错误等问题，通过日志只能打印异常的行号或函数，但具体的结构体/类的参数内容打印却非常麻烦，无法做到一些更高级语言的反射功能。要做到能够通过变量地址就打印变量的内容信息，就需要依赖ms提供的msdia120.dll和程序编译后的pdb文件。 原理msdia120.dll 需要注册到目标机器，通过提供的接口函数可以解析pdb文件中的结构体、类，并提供这个成员变量的类型、相对的地址偏移。 效果demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;typeinfo&gt;#include &quot;tcDump.h&quot;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;list&gt;struct STTEST&#123; int a; double b; float c; short d; char szName[32]; void *p;&#125;;class CClassTest&#123;public: std::string m_strName; std::vector&lt;int&gt; m_oVec; std::map&lt;int, std::string&gt; m_oMap; //std::list&lt;int&gt; m_oList; // 不支持，慢慢完善&#125;;int _tmain(int argc, _TCHAR* argv[])&#123; if (0 == TCDUMP_INIT(&quot;ConsoleApplication1.pdb&quot;))&#123; return false; &#125; //结构体 &#123; STTEST st = &#123; 0 &#125;; st.a = 1; st.b = 1.2; st.c = 2.3; st.d = 655; memcpy(st.szName, &quot;hello world&quot;, 12); st.p = (void*)0x123456; auto json = TCDUMP(st); if (NULL == json)&#123; return false; &#125; printf(&quot;%s\n&quot;, json); &#125; //类对象 &#123; CClassTest oTest; oTest.m_strName = &quot;this is a test for string&quot;; oTest.m_oVec.push_back(6); oTest.m_oVec.push_back(7); oTest.m_oVec.push_back(8); oTest.m_oMap[0] = &quot;this is 0&quot;; oTest.m_oMap[1] = &quot;this is 1&quot;; oTest.m_oMap[2] = &quot;this is 2&quot;; auto json = TCDUMP(oTest); if (NULL == json)&#123; return false; &#125; printf(&quot;%s\n&quot;, json); &#125; return 0;&#125; 输出效果123456789101112131415161718&#123; &quot;a&quot; : 1, &quot;b&quot; : 1.2, &quot;c&quot; : 2.2999999523162842, &quot;d&quot; : 655, &quot;p&quot; : &quot;[0x00123456]&quot;, &quot;szName&quot; : &quot;hello world&quot;&#125;&#123; &quot;m_oMap&quot; : &#123; &quot;0&quot; : &quot;this is 0&quot;, &quot;1&quot; : &quot;this is 1&quot;, &quot;2&quot; : &quot;this is 2&quot; &#125;, &quot;m_oVec&quot; : [ 6, 7, 8 ], &quot;m_strName&quot; : &quot;this is a test for string&quot;&#125; 后续在每个关键函数的入口增加一个宏定义，就可以轻松的定位参数错误的问题，而省去了大量的远程调试时间。 二次开发visual studio 的安装路径下存在一个demo程序：DIA SDK 。可以通过修改其中的代码实现，当然我的百度网盘有封装后的sdk更加容易使用。 https://pan.baidu.com/s/1takuuHhxGt_WkLQWGDeacQ msdia120.dll tcDump.dll tcDump.h tcDump.lib tcDumpD.lib tcDumpD.dll 使用说明.txt]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搭建pdb服务器]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%90%AD%E5%BB%BApdb%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[背景目前使用jenkins进行每日编译、部署，但是一旦程序出现异常后，查找正确的pdb文件也是件麻烦的事情，所以希望能有微软符号服务器一样的功能。 步骤通过google 查找一些资料，自己尝试了下，还是比较简单的. 安装windbg环境变量path 中设置windbg路径。 准备一块大硬盘会保存很多历史版本的pdb，所以有必要准备一块大硬盘 测试管理员方式运行cmd 1234567symstore add /r /f d:\public_game\*.pdb /s e:\symstore /t "gamechannel"其中 'd:\public_game\*.pdb' 为编译后的pdb路径'e:\symstore' pdb服务器路径"gamechannel" 产品名称更多参数说明 symstore -help 搭建http服务我们需要提供对外访问符号文件的途径，最简便的方式就是使用IIS创建一个HTTP服务并对外开放。使用搭SII建HTTP服务器的教程网上很多，这里简述以下: 打开IIS，选择网站-&gt;右键“添加网站” 输入网站名称，如Symbols，选择刚创建的符号文件存储目录为物理路径，端口为6776 ,其他保持默认，点击确定。 在网站主页中打开MIME类型，右侧添加，文件扩展名输入PDB,MIME类型输入application/octet-stream。这一步是为了允许从该站点访问读取PDB类型的文件。 设置权限。我们创建的网站默认情况下是不允许匿名用户访问的，为了允许调试器下载符号，我们需要添加一定的权限。点击右键我们的网站-&gt;编辑权限-&gt;选择安全选项卡-&gt;添加IIS_IUSRS用户或everyone用户并赋予Read &amp; execute，List folder contents和Read三项权限。 左侧右键刚创建的网站-&gt;管理网站-&gt;重新启动。 jenkins 设置在jenkins 原本保存exe、pdb 的命令下 增加 以上命令即可 windbg 设置12SRV*e:\mylocalsymbols*http://msdl.microsoft.com/download/symbolsSRV*e:\companysymbols*http://192.168.1.7:1234/ 好了，pdb 就可以自动获取了]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[踩内存（内存溢出）的异常定位]]></title>
    <url>%2F2019%2F05%2F07%2F%E8%B8%A9%E5%86%85%E5%AD%98%EF%BC%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%89%E7%9A%84%E5%BC%82%E5%B8%B8%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[介绍某天晚上11点，钉钉预警提示某服务catch到一个异常导致服务重启，因为是上线了一个多月的服务，半夜遇到这样的问题，整个人有点懵，立刻打开电脑下载dump文件进行分析，不幸的是在分析的过程中，又连续的出现了几次崩溃，在这么反复崩溃、重启折腾了1小时左右，服务终于正常了。 分析dump下载路径：链接：https://pan.baidu.com/s/1GPzzipmxWyIr5WKNq11pIQ 提取码：6dsn 分析[11-13 20-53-03]full.dmp 使用windbg打开dmp，并加载符号文件 使用命令 .ecxr 切换到异常上下文 1234567891011121314151617181920212223242526272829303132330:061&gt; .ecxreax=00000000 ebx=dfa477a6 ecx=0000020c edx=00000000 esi=10171adc edi=dfa40000eip=77bee41b esp=08c8f51c ebp=08c8f550 iopl=0 nv up ei pl nz na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010206ntdll!RtlInitUnicodeString+0x1f3:77bee41b 8930 mov dword ptr [eax],esi ds:002b:00000000=????????0:061&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.08c8f550 77bee023 00936e28 00936e28 08c8f5b4 ntdll!RtlInitUnicodeString+0x1f3*** ERROR: Symbol file could not be found. Defaulted to export symbols for kernel32.dll - 08c8f568 774414ad 008e0000 00000000 1065fd28 ntdll!RtlFreeHeap+0x7e*** ERROR: Symbol file could not be found. Defaulted to export symbols for msvcr120.dll - 08c8f57c 70fdecfa 008e0000 00000000 1065fd28 kernel32!HeapFree+0x14*** WARNING: Unable to verify checksum for topsvr.exe08c8f590 00315e35 1065fd28 0f611df0 002cef01 msvcr120!free+0x1a08c8f5a8 00315f4a 00936e28 00000000 00000000 topsvr!redisBufferWrite+0xb508c8f5bc 003160b7 00936e28 08c8f5d0 1033f5e8 topsvr!redisGetReply+0x4a08c8f5d4 0034ae42 00936e28 0f813270 69b2eb38 topsvr!redisCommand+0x3708c8f6dc 0034ee4f 08c8f764 08c8f818 69b2ea74 topsvr!CRedisBase::RedisCommand+0x92 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\redisbase.cpp @ 217]08c8f790 0034d24a 08c8f9fc 08c8f818 69b2e5d4 topsvr!CRedisMaster::GetYQWRoomInfo+0x5f (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\redismaster.cpp @ 623]08c8f830 00378957 08c8f9fc 08c8f924 69b2e414 topsvr!CRedisMaster::GetYQWRoomInfo+0x4a (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\redismaster.cpp @ 636]08c8f9f0 0036bab4 08c8fafc 00048e0f 69b2e604 topsvr!ToPSvrThriftHandler::GetYQWRoomByNo+0xc7 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\thirdpart\thrift-0.10.0\gen-cpp\topsvrthrift_server.skeleton.cpp @ 86]08c8fbe0 0036b31f 00000000 100e3170 100e30e0 topsvr!Tcy::ToPSvr::Thrift::ToPSvrThriftProcessor::process_GetYQWRoomByNo+0x1e4 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\thirdpart\thrift-0.10.0\gen-cpp\topsvrthrift.cpp @ 1823]08c8fcec 00375429 100e3170 100e30e0 08c8fd64 topsvr!Tcy::ToPSvr::Thrift::ToPSvrThriftProcessor::dispatchCall+0x28f (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\thirdpart\thrift-0.10.0\gen-cpp\topsvrthrift.cpp @ 1742]08c8fd90 002dcf11 100e3170 0f611e08 100e30e0 topsvr!apache::thrift::TDispatchProcessor::process+0xd9 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\svn143\library\thrift-0.10.0\lib\cpp\src\thrift\tdispatchprocessor.h @ 121]08c8fe44 002cab31 0093f988 002cadde 69b2e34c topsvr!apache::thrift::server::TConnectedClient::run+0x12108c8fea8 002cf00c 69b2e334 0093fed0 0093efa8 topsvr!apache::thrift::concurrency::ThreadManager::Task::run+0x1108c8fed0 002cfcd1 0093efa8 0093fed0 69b2e2e8 topsvr!apache::thrift::concurrency::StdThread::threadMain+0x5c*** ERROR: Symbol file could not be found. Defaulted to export symbols for msvcp120.dll - 08c8ff0c 7196f33c 432a8f49 00000000 009817d8 topsvr!std::_LaunchPad&lt;std::_Bind&lt;1,void,void (__cdecl*const)(boost::shared_ptr&lt;apache::thrift::concurrency::StdThread&gt;),boost::shared_ptr&lt;apache::thrift::concurrency::StdThread&gt; &gt; &gt;::_Run+0x7108c8ff34 70ffc01d 0377f764 432a8da9 00000000 msvcp120!std::_Pad::_Release+0x6c 异常来自CRedisBase::RedisCommand,最终是kernel32!HeapFree 导致异常 使用 !analyze -v 查看错误原因 123456789101112131415SYMBOL_NAME: heap_corruption!heap_corruptionFOLLOWUP_NAME: MachineOwnerMODULE_NAME: heap_corruptionIMAGE_NAME: heap_corruptionDEBUG_FLR_IMAGE_TIMESTAMP: 0STACK_COMMAND: ~61s; .ecxr ; kbFAILURE_BUCKET_ID: HEAP_CORRUPTION_c0000005_heap_corruption!heap_corruptionBUCKET_ID: APPLICATION_FAULT_HEAP_CORRUPTION_INVALID_POINTER_WRITE_NULL_POINTER_WRITE_heap_corruption!heap_corruption 基本可以确定是 heap被破坏导致的。 heap异常对于heap异常，在溢出或被踩时不一定会在第一时间出现问题。那么如何才能让heap被破坏时就产生异常呢？ 就是通过之前介绍的 “windows的应用验证机制” 使用appverif.exe页堆有两种运行模式： 普通页堆 完全页堆 普通页堆通过填充模式（增加元数据）检测堆块异常。完全页堆则多增加了一个防护页。 普通页堆因为没有将元数据和内存分离开，那么当元数据被破坏时，异常也是无法第一时间捕获。 完全页堆的缺点是需要大量的内存，会使原来的程序内存使用量提高一个数量级。 一般建议方案是在测试环境使用普通页堆方式，然后定期的检查中使用完全页堆。只有在条件允许的生产环境下采用完全页堆方式；也可以通过检测dll或基于内存分配大小来缩小内存检测范围。 full: 普通页堆 or 完全页堆 dlls: 可以指定堆测试中包含哪些dll。dll名字包括扩展名，如果有多个dll，那么用空格来分隔dll size：可以指定测试大小指定范围内的内存 backward： 完全页堆默认防止下溢的异常； 那么这个开关增加上溢的异常检测…… 分析[11-13 21-10-08]full 开启heap检测.dmp在第二天晚上蹲点，出现异常时立刻给服务开启heap检测，服务运行几分钟后又出现崩溃。 使用windbg打开该dmp .ecxr 切换到异常上下文 1234567891011121314151617180:119&gt; .ecxr eax=22ac1000 ebx=08de9ce8 ecx=22ac1000 edx=22ac0fff esi=1c8c0fe0 edi=08de9ce0eip=00bb6e31 esp=17d7f258 ebp=17d7f2ac iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010246*** WARNING: Unable to verify checksum for topsvr.exetopsvr!Base64encode+0x1c1:00bb6e31 c60000 mov byte ptr [eax],0 ds:002b:22ac1000=??0:119&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 17d7f2ac 00bbc06e 22ac0fa8 22d3ee58 00000042 topsvr!Base64encode+0x1c1 (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\base64.cpp @ 207]17d7f50c 00bb83d1 22d3e198 22d3ed80 17d7f620 topsvr!CBillDB::MakeParam_PushPlayerInfo+0x19e (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\billdb.cpp @ 625]17d7f668 00bb8842 22d3e198 22d3e390 00000000 topsvr!CBillDB::PushBill2DB+0x351 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\billdb.cpp @ 102]17d7f718 00bec143 22d3e198 22d3e390 11588718 topsvr!CBillDB::PushBill+0xe2 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\billdb.cpp @ 154]17d7f884 00be7695 21df6fe8 22528fe0 1732cfb8 topsvr!CSockServer::OnYQWResultEx+0x4a3 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\socksvr.cpp @ 1733]17d7f91c 00c1ac94 21df6fe8 22528fe0 08de9ce8 topsvr!CSockServer::OnRequest+0x3b5 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\socksvr.cpp @ 293]17d7f944 00c1efeb 00000000 17324c40 17070c40 topsvr!CIocpWorker::DoWorkLoop+0xa417d7f95c 00c1efbb 17d7f99c 70ffc01d 08de9ce0 topsvr!CBaseWorker::WorkerThreadProc+0x2b 可以很容易看到是Base64encode导致异常 通过windbg的watch 查看入参参数，定位到原因： nikename数组只分配了128字节，但是某个玩家是156字节，导致转换溢出。 长度修改为256，服务发布后，就不再出现问题。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windbg分析内存泄漏]]></title>
    <url>%2F2019%2F05%2F07%2Fwindbg%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍本文主要介绍一种通过windbg分析内存泄漏的方法。 现象后台检测程序在某天上报了告警，大概就是某程序的提交内存达到了1.0G。登陆后台查看，该进程已经运行了90天，提交内存每天都在持续上涨，从启动到目前为止大概累计上升了800M。应该是存在内存泄漏。让运维通过工具保存了fulldump 准备工作 下载地址（提取码：11bg） 设置好系统的pdb1e:\mylocalsymbols;SRV*e:\mylocalsymbols*http://msdl.microsoft.com/download/symbols 查找堆块打印所有堆块信息1!heap -s 显示如下12345678910111213141516171819202122230:000&gt; !heap -sHEAPEXT: Unable to read ntdll!RtlpDisableHeapLookaside Heap Flags Reserv Commit Virt Free List UCR Virt Lock Fast (k) (k) (k) (k) length blocks cont. heap -----------------------------------------------------------------------------006f0000 00000002 1246976 1241928 1246976 982 236 81 0 a LFH00190000 00001002 3136 1564 3136 390 7 3 0 0 LFH External fragmentation 24 % (7 free blocks)00110000 00001002 256 4 256 1 1 1 0 0 02050000 00001002 256 176 256 1 18 1 0 0 LFH02240000 00001002 256 4 256 2 1 1 0 0 006a0000 00001002 64 12 64 4 2 1 0 0 044f0000 00001002 256 216 256 7 4 1 0 0 LFH119d0000 00001002 7424 5820 7424 134 133 4 0 c8 LFH14290000 00001003 256 4 256 2 1 1 0 bad 141d0000 00001003 256 4 256 2 1 1 0 bad 17f20000 00001003 256 4 256 2 1 1 0 bad 19030000 00001003 256 4 256 2 1 1 0 bad 191b0000 00001003 256 4 256 2 1 1 0 bad 19380000 00001003 256 4 256 2 1 1 0 bad 19300000 00001003 256 4 256 2 1 1 0 bad 155f0000 00001003 256 4 256 2 1 1 0 bad ----------------------------------------------------------------------------- 通过观察，我们知道了是006f0000堆块占用了大量内存12345HEAPEXT: Unable to read ntdll!RtlpDisableHeapLookaside Heap Flags Reserv Commit Virt Free List UCR Virt Lock Fast (k) (k) (k) (k) length blocks cont. heap -----------------------------------------------------------------------------006f0000 00000002 1246976 1241928 1246976 982 236 81 0 a LFH 查看堆块内存百分比内存持续上涨可能是某块固定大小内存被重复申请，所以统计下该堆块中各个内存大小的分配次数1!heap -stat -h 006f0000 查找堆中各个内存大小占用的百分比 123456789101112131415161718192021222324250:000&gt; !heap -stat -h 006f0000unable to resolve ntdll!RtlpStackTraceDataBase heap @ 006f0000group-by: TOTSIZE max-display: 20 size #blocks total ( %) (percent of total busy bytes) 14 23acbbe - 2c97ead8 (92.78) a4 2ba0c - 1bf2fb0 (3.63) 1000 8f5 - 8f5000 (1.16) 1a4 3b9c - 61cbf0 (0.79) 20c 15fb - 2cfdc4 (0.37) 25 b77d - 1a8511 (0.22) 64 3ba0 - 174a80 (0.19) 24 75ae - 108c78 (0.13) 11c e4a - fda18 (0.13) 84c 164 - b89b0 (0.09) 400 172 - 5c800 (0.05) 234 265 - 54684 (0.04) 1c 2c2e - 4d508 (0.04) 1c0 287 - 46c40 (0.04) c00 4b - 38400 (0.03) 20 1a12 - 34240 (0.03) 3bc ce - 30148 (0.02) 50 8da - 2c420 (0.02) 800 4c - 26000 (0.02) 2ba d2 - 23c94 (0.02) 12size #blocks total ( %) (percent of total busy bytes)14 23acbbe - 2c97ead8 (92.78) TOP 20 中显示，最多的一个大小为 0x014 的分配次数为 0x23acbbe 次， 总共大概有700M左右。基本接近内存泄漏的总数。那么我们就需要来确定这个内存是谁申请的。 定位内存来源找到了大量的内存是0x014字节大小的，但是根据这个条件我们也找不到具体的代码啊？下面是几个思路 思路1 根据大小根据内存大小（0x14）去代码中查找大小为（0x14）的类、结构体、宏等等相关代码，然后找到原因。难！！！1）、进程包含了很多其他组的dll，有的我没代码权限，无法遍历2）、结构体、类太多了，人眼遍历太难了（针对这个问题我开发了一个工具，后续章节讲解） 思路2 内存内容显示所有大小为（0x14）内存的地址，看它的地址内容有没有什么特点，比如是否有特殊的字符串、固定的二进制头？？？ 显示所有分配大小为 0x14的内存1!heap -flt s 14 12345678910111213141516171819202122232425262728290:000&gt; !heap -flt s 14 unable to resolve ntdll!RtlpStackTraceDataBase _HEAP @ 6f0000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 0071c038 0004 0000 [00] 0071c040 00014 - (busy) 0071c2e8 0004 0004 [00] 0071c2f0 00014 - (busy) 0071e498 0004 0004 [00] 0071e4a0 00014 - (busy) 0071e4f8 0004 0004 [00] 0071e500 00014 - (busy) 0071e518 0004 0004 [00] 0071e520 00014 - (busy) 0071e5f8 0004 0004 [00] 0071e600 00014 - (busy) 0071e638 0004 0004 [00] 0071e640 00014 - (busy) 0071e658 0004 0004 [00] 0071e660 00014 - (busy) 0071e798 0004 0004 [00] 0071e7a0 00014 - (busy) 007374f0 0004 0004 [00] 007374f8 00014 - (busy) 00737510 0004 0004 [00] 00737518 00014 - (busy) 00737530 0004 0004 [00] 00737538 00014 - (busy) 00737550 0004 0004 [00] 00737558 00014 - (busy) 00737570 0004 0004 [00] 00737578 00014 - (busy) 00737590 0004 0004 [00] 00737598 00014 - (busy) 007375b0 0004 0004 [00] 007375b8 00014 - (busy) 007375d0 0004 0004 [00] 007375d8 00014 - (busy) 007375f0 0004 0004 [00] 007375f8 00014 - (busy) 00737610 0004 0004 [00] 00737618 00014 - (busy) 00737630 0004 0004 [00] 00737638 00014 - (busy) 00737650 0004 0004 [00] 00737658 00014 - (busy) 00737670 0004 0004 [00] 00737678 00014 - (busy) 00737690 0004 0004 [00] 00737698 00014 - (busy) .............. .............. 随机抽查几个地址，看下地址内存 大都是这样的值，实在是看不出规律。 建议一般公司都会封装malloc、new函数，并分配一个模块号，每个内存地址头部都会携带id号，如下：1xxx_malloc(int nModleID,size_t size); 这样通过地址空间内容也可以找到分配的模块。 思路3 分配次数大小0x14的内存在90天时间内总共分配了23acbbe 次， 0x23acbbe = 37407678/(90(天)*24(小时) ≈ 17318次/小时。 这个内存几乎每小时被申请17318次。公司的服务器有个基本功能：每个小时会统计收到的消息次数，那分析下数量级在1w~3w左右的消息即可，大概是4个消息类型，然后通过代码review发现内存泄漏点123456if(total_fee)&#123; LPADD_FEE pAddFee = new ADD_FEE; ZeroMemory(pAddFee, sizeof(ADD_FEE)); pAddFee-&gt;nFee = total_fee; gdt.nTotalFee = total_fee;&#125; 结构体 ADD_FEE ,刚好是20字节1234typedef struct _tagADD_FEE&#123; int nFee; int nReserved[4];&#125;ADD_FEE, *LPADD_FEE; 完全符合！！ 问题解决 总结这个一个低级错误导致的。为了避免类视问题，引入代码静态检测1）、cppcheck2）、pclint最后选了pclint。配合jenkins，每天凌晨进行代码静态检查，并输出和上个版本的diff文件，下次就不会出现这么低级的问题。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windbg分析临界区死锁]]></title>
    <url>%2F2019%2F05%2F07%2Fwindbg%E5%88%86%E6%9E%90%E4%B8%B4%E7%95%8C%E5%8C%BA%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[介绍多线程编程中，对于资源同步导致的死锁问题，应该是开发过程中经常碰到的，同时在问题定位过程中也会花费大量的时间，这里就介绍下如何通过windbg来分析死锁问题。 资源同步windows下资源同步的方法主要是 原子访问 临界区 读写锁 旋转锁 等待函数 事件 信号量 互斥量 其中最常用的应该是临界区了（性能开销小），所以我也是拿临界区作为分析对象，其他资源同步不在此讨论。 临界区保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么 在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操 作共享资源的目的。临界区包含两个操作原语：EnterCriticalSection（） 进入临界区LeaveCriticalSection（） 离开临界区EnterCriticalSection（） 语句执行后代码将进入临界区以后无论发生什么，必须确保与之匹配的 LeaveCriticalSection（）都能够被执行到。否则临界区保护的共享资源将永远不会被释放。虽然临界区同步速度很快，但却只能用来同步本 进程内的线程，而不可用来同步多个进程中的线程。 结构体定义12345678typedef struct _RTL_CRITICAL_SECTION &#123; PRTL_CRITICAL_SECTION_DEBUG DebugInfo; LONG LockCount; LONG RecursionCount; HANDLE OwningThread; HANDLE LockSemaphore; ULONG_PTR SpinCount;&#125; RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION; 各个参数的解释如下：第一个参数：PRTL_CRITICAL_SECTION_DEBUG DebugInfo;//调试用的第二个参数：LONG LockCount;//初始化为-1，n表示有n个线程在等待第三个参数：LONG RecursionCount;//表示该临界区的拥有线程对此资源获得临界区次数，初为0第四个参数：HANDLE OwningThread;//即拥有该临界区的线程句柄第五个参数：HANDLE LockSemaphore;//实际上是一个自复位事件第六个参数：DWORD SpinCount;//旋转锁的设置，单CPU下忽略 由这个结构可以知道：临界区会记录拥有该临界区的线程句柄，即临界区是有“线程所有权”概念的。事实上它会用第四个参数OwningThread来记录获准进入临界区的线程句柄，如果这个线程再次进入，EnterCriticalSection()会更新第三个参数RecursionCount以记录该线程进入的次数并立即返回让该线程进入。其它线程调用EnterCriticalSection()则会被切换到等待状态，一旦拥有线程所有权的线程调用LeaveCriticalSection()使其进入的次数为0时，系统会自动更新临界区并将等待中的线程换回可调度状态。 问题出现服务器工作线程每5s会定时上报当前还有多少消息堆积未处理，正常情况应该都是&lt;=10左右。如果出现cpu不足、io、死锁、假死等问题导致工作线程无法正常消费，那么消息堆积数量会逐渐上升。某天在告警群里面提示某服务的消息堆积从100、400、1000、3000、5000 逐渐上升，第一感觉就是服务出问题了，立刻让运维查看服务器cpu、内存、io，均正常，而且同物理主机的其他服务正常运行，所以问题应该是该服务程序出现了某些状况，可能是死锁、也可能是死循环、也可能是长时间sleep….. 立刻保存fulldump，然后重启服务，先恢复线上服务，以免给客户带来更大损失。 分析过程下载dump下载地址(提取码：33lg) 步骤1使用windbg 打开dump，并设置好pdb、操作系统pdb；使用命令 “~*kv” 显示所有线程当前的函数调用栈，效果如下（大部分省略） 123456789101112131415161718192021222324250:021&gt; ~*kv 0 Id: 173c.16d8 Suspend: 3 Teb: 7efdd000 UnfrozenChildEBP RetAddr Args to Child 0035b6b8 775514ab 000000d0 00000000 00000000 ntdll!NtWaitForSingleObject+0x15 (FPO: [3,0,0])0035b724 77441194 000000d0 ffffffff 00000000 KERNELBASE!WaitForSingleObjectEx+0x98 (FPO: [Non-Fpo])0035b73c 77441148 000000d0 ffffffff 00000000 kernel32!WaitForSingleObjectExImplementation+0x75 (FPO: [Non-Fpo])0035b750 75777be6 000000d0 ffffffff 0e9c9dd4 kernel32!WaitForSingleObject+0x12 (FPO: [Non-Fpo])0035b7f4 75778040 0070b1b8 000000d0 00000000 sechost!ScSendResponseReceiveControls+0xea (FPO: [Non-Fpo])0035b8a8 75778553 0035b8bc 00000000 00000001 sechost!ScDispatcherLoop+0xc2 (FPO: [Non-Fpo])*** WARNING: Unable to verify checksum for MatchSvr.exe0035b8c0 012432cb 0035b8cc 0035b938 012431a0 sechost!StartServiceCtrlDispatcherA+0x68 (FPO: [Non-Fpo])0035b8dc 01218689 fc7e3c0d 00000000 00000001 MatchSvr!CNTService::StartServiceA+0x2b0035f928 01253f2a 00000001 00708280 006ff620 MatchSvr!main+0x139 (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\main.cpp @ 190]0035f968 7744338a 7efde000 0035f9b4 77bf9f72 MatchSvr!__tmainCRTStartup+0xfd (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\dllstuff\crtexe.c @ 626]0035f974 77bf9f72 7efde000 85371315 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])0035f9b4 77bf9f45 01253f92 7efde000 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])0035f9cc 00000000 01253f92 7efde000 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 1 Id: 173c.290 Suspend: 3 Teb: 7ef9f000 UnfrozenChildEBP RetAddr Args to Child 02aef948 76fa7c1d 02aef9cc 00000000 00000000 user32!NtUserGetMessage+0x15 (FPO: [4,0,0])02aef968 0122d9ad 02aef9cc 00000000 00000000 user32!GetMessageA+0xa1 (FPO: [Non-Fpo])02aef9ec 0124326d 00000000 00712b08 00000000 MatchSvr!CMainService::Run+0x7d (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\service.cpp @ 65]02aefa0c 757775a8 00000001 00712b18 00000000 MatchSvr!CNTService::ServiceMain+0xcd 步骤2观察所有线程的函数调用。 这个服务并不复杂，总共只有二十几个线程（以前分析的都是至少100个线程的dump），然后重点查看服务进程的主要工作线程（是因为工作线程不工作才导致消息堆积）。 这个服务的工作线程有4个分别是10、11、12、13， 至于怎么确定的？1、看日志。良好的编码习惯，程序中的每个线程启动、退出都会在日志中记录2、对代码逻辑的熟悉 步骤3切换到其中任意一个工作线程，比如10号线程~10skv1234567891011121314151617181920212223242526272829303132330:010&gt; ~10seax=00000000 ebx=03020f70 ecx=00000000 edx=00000000 esi=7fffffff edi=ffffffffeip=77bdf8d1 esp=03bcf10c ebp=03bcf14c iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!NtWaitForSingleObject+0x15:77bdf8d1 83c404 add esp,40:010&gt; kvChildEBP RetAddr Args to Child 03bcf10c 74a06f1f 00000330 00000001 03bcf134 ntdll!NtWaitForSingleObject+0x15 (FPO: [3,0,0])03bcf14c 74a06d40 00000330 000001a4 00000001 mswsock!SockWaitForSingleObject+0x1ba (FPO: [Non-Fpo])03bcf238 75796a28 000001a5 00000000 03bcf2ec mswsock!WSPSelect+0x3a6 (FPO: [Non-Fpo])03bcf2b8 744d7787 000001a5 00000000 03bcf2ec ws2_32!select+0x494 (FPO: [Non-Fpo])WARNING: Stack unwind information not available. Following frames may be wrong.03bcf3f4 744d75f0 000001a4 00000004 ffffffff rabbitmq_4!amqp_open_socket+0x34703bcf600 744d76ca 00720ae8 000021e0 ffffffff rabbitmq_4!amqp_open_socket+0x1b003bcf620 744d9693 00720ae8 000021e0 00000000 rabbitmq_4!amqp_open_socket+0x28a03bcf638 744d7e26 0497bdc8 00720ae8 000021e0 rabbitmq_4!amqp_parse_url+0x3c303bcf650 01250550 0497bdc8 00720ae8 000021e0 rabbitmq_4!amqp_socket_open+0x1603bcf728 01250e97 fff73d65 0070b3d8 071ca950 MatchSvr!CRabbitMQ::connect+0xd003bcf840 01250870 0071ecf4 0071ecc4 03bcfa28 MatchSvr!CRabbitMQ::_publish_str_+0x18703bcf8a4 01250100 0071ecf4 0071ecc4 03bcfa28 MatchSvr!CRabbitMQ::sendmsg+0x2003bcf908 01218d48 0071ecf4 0071ecc4 03bcfa28 MatchSvr!CRabbitmqProc::sendmsg+0x2003bcf96c 01231fbc 03bcfa28 fff7382d 0070b3d8 MatchSvr!CProducerMQ::RabbitMQPublish_log+0x28 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\producermq.cpp @ 62]03bcfd08 0122eb98 071cae70 08c6c368 007022a8 MatchSvr!CSockServer::OnGameUserArenaResult+0xc3c (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\socksvr.cpp @ 1096]03bcfda4 012392e4 071cae70 08c6c368 0070b3e0 MatchSvr!CSockServer::OnRequest+0x718 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\socksvr.cpp @ 309]03bcfdcc 0123d1bb 00000000 00715868 007141b8 MatchSvr!CIocpWorker::DoWorkLoop+0xa403bcfde4 0123d18b 03bcfe24 70ffc01d 0070b3d8 MatchSvr!CBaseWorker::WorkerThreadProc+0x2b03bcfdec 70ffc01d 0070b3d8 0d15d467 00000000 MatchSvr!CBaseWorker::WorkerThreadFunc+0xb03bcfe24 70ffc001 00000000 03bcfe3c 7744338a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]03bcfe30 7744338a 007141b8 03bcfe7c 77bf9f72 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]03bcfe3c 77bf9f72 007141b8 86be14dd 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])03bcfe7c 77bf9f45 70ffbfb4 007141b8 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])03bcfe94 00000000 70ffbfb4 007141b8 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 从中，我们看到调用栈并没有什么问题，大概意思就是收到了一个GameUserArenaResult消息，然后通过mq publish出去，然后mq模块正在进行connect。感觉没有问题，接着看11号线程 ~11skv 1234567891011121314151617181920212223240:010&gt; ~11seax=00000001 ebx=00000000 ecx=00000000 edx=00000000 esi=007124f8 edi=00000000eip=77bdf8d1 esp=03ccf4cc ebp=03ccf530 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!NtWaitForSingleObject+0x15:77bdf8d1 83c404 add esp,40:011&gt; kvChildEBP RetAddr Args to Child 03ccf4cc 77bf8e44 00000e0c 00000000 00000000 ntdll!NtWaitForSingleObject+0x15 (FPO: [3,0,0])03ccf530 77bf8d28 00000000 00000000 0070b3e0 ntdll!RtlpWaitOnCriticalSection+0x13e (FPO: [Non-Fpo])03ccf558 01216e48 007124f8 0070b3d8 030c7658 ntdll!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo])03ccf5b4 0121525e 0070b3d8 030c7658 0070b3e0 MatchSvr!JMutex::Lock+0x28 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\jmutex.cpp @ 71]03ccf60c 01214b6a 007124f8 ff873359 0070b3d8 MatchSvr!JMutexAutoLock::JMutexAutoLock+0x1e (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\jmutexautolock.h @ 39]03ccf67c 01231c00 03ccf790 ff873f3d 0070b3d8 MatchSvr!CDelaySendMsg::AddMsg+0x3a (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\delaysendmsg.cpp @ 14]03ccfa18 0122eb98 05ebbe68 088d7790 00702348 MatchSvr!CSockServer::OnGameUserArenaResult+0x880 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\socksvr.cpp @ 1071]03ccfab4 012392e4 05ebbe68 088d7790 0070b3e0 MatchSvr!CSockServer::OnRequest+0x718 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\socksvr.cpp @ 309]03ccfadc 0123d1bb 00000000 00715ff8 007154a0 MatchSvr!CIocpWorker::DoWorkLoop+0xa403ccfaf4 0123d18b 03ccfb34 70ffc01d 0070b3d8 MatchSvr!CBaseWorker::WorkerThreadProc+0x2b03ccfafc 70ffc01d 0070b3d8 0d65d177 00000000 MatchSvr!CBaseWorker::WorkerThreadFunc+0xb03ccfb34 70ffc001 00000000 03ccfb4c 7744338a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]03ccfb40 7744338a 007154a0 03ccfb8c 77bf9f72 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]03ccfb4c 77bf9f72 007154a0 86ce112d 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])03ccfb8c 77bf9f45 70ffbfb4 007154a0 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])03ccfba4 00000000 70ffbfb4 007154a0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 这个堆栈就有意思了，大概就是收到了OnGameUserArenaResult消息，然后AddMsg，进入一个AutoLock，然后RtlEnterCriticalSection，看到这个说明很可能有死锁问题。我们继续观察这个临界区的具体信息103ccf558 01216e48 007124f8 0070b3d8 030c7658 ntdll!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo]) 注意其中的第三列、第四列、第五列， 分别代表了这个函数的第一个入参、第二个入参、第三个入参， 之前看过临界区的结构体，所以使用以下命令1!cs 007124f8 12345678910110:011&gt; !cs 007124f8-----------------------------------------Critical section = 0x007124f8 (+0x7124F8)DebugInfo = 0x007184b8LOCKEDLockCount = 0x2WaiterWoken = NoOwningThread = 0x00001188RecursionCount = 0x1LockSemaphore = 0xE0CSpinCount = 0x00000000 这个临界区正在被 0x00001188 的线程占用，所以导致11s线程无法进入临界区，那么我们就去 0x00001188 线程在做什么。通过线程id显示线程号命令~~[0x00001188]12340:011&gt; ~~[0x00001188] 4 Id: 173c.1188 Suspend: 3 Teb: 7ef96000 Unfrozen Start: msvcr120!_threadstartex (70ffbfb4) Priority: 0 Priority class: 32 Affinity: 3 4号线程，然后我们切换~4skv1234567891011121314151617180:004&gt; kvChildEBP RetAddr Args to Child 02fdf4b0 77bf8e44 00000dcc 00000000 00000000 ntdll!NtWaitForSingleObject+0x15 (FPO: [3,0,0])02fdf514 77bf8d28 00000000 00000000 00713298 ntdll!RtlpWaitOnCriticalSection+0x13e (FPO: [Non-Fpo])02fdf53c 01253666 00720b68 00000000 00713df0 ntdll!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo])02fdf598 0125232e 00000000 00713df0 00713298 MatchSvr!CJMutex::Lock+0x2602fdf5f0 01250d6a 00720b68 feb63229 00000000 MatchSvr!CJAutoLock::CJAutoLock+0x1e02fdf70c 01250870 0071ecf4 0071ecdc 061b729c MatchSvr!CRabbitMQ::_publish_str_+0x5a02fdf770 01250100 0071ecf4 0071ecdc 061b729c MatchSvr!CRabbitMQ::sendmsg+0x2002fdf7d4 01218d88 0071ecf4 0071ecdc 061b729c MatchSvr!CRabbitmqProc::sendmsg+0x2002fdf838 01214ccd 061b729c feb63ded 00000000 MatchSvr!CProducerMQ::RabbitMQPublish_Award+0x28 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\producermq.cpp @ 72]02fdf8c8 012172b9 00000000 00713df0 00713298 MatchSvr!CDelaySendMsg::Thread+0x11d (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\delaysendmsg.cpp @ 46]02fdf924 70ffc01d 007124a0 0c54d31f 00000000 MatchSvr!JThread::TheThread+0x39 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\jthread.cpp @ 175]02fdf95c 70ffc001 00000000 02fdf974 7744338a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]02fdf968 7744338a 00713298 02fdf9b4 77bf9f72 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]02fdf974 77bf9f72 00713298 87ff1315 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])02fdf9b4 77bf9f45 70ffbfb4 00713298 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])02fdf9cc 00000000 70ffbfb4 00713298 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 4号线程MQ正在publish一个消息，而这个消息中有一个临界区，这个临界区可能又正在被其他线程占用。 继续查看临界区12345678910110:004&gt; !cs 00720b68 -----------------------------------------Critical section = 0x00720b68 (+0x720B68)DebugInfo = 0x0071e070LOCKEDLockCount = 0x3WaiterWoken = NoOwningThread = 0x00001590RecursionCount = 0x2LockSemaphore = 0xDCCSpinCount = 0x00000000 这个临界区正在被0x00001590 线程占用，再看看这个线程号是多少~~[0x00001590]12340:004&gt; ~~[0x00001590] 10 Id: 173c.1590 Suspend: 3 Teb: 7ef81000 Unfrozen Start: msvcr120!_threadstartex (70ffbfb4) Priority: 0 Priority class: 32 Affinity: 3 ？？？？ 怎么又回到10号线程了， 再仔细看看10s线程之前我们看的时候觉的没问题，但这里肯定是有问题的，会不会’connect’ 阻塞了呢? 带着疑问查看了下消息堆积时段的日志，有MQ断开的日志。带着猜测自己重现现场试试看，在本地启动服务，然后重启mq服务，发现问题必现。解决方法就是使用非阻塞式的connect函数，问题解决。 总结这里介绍了几个windbg的常用命令，讲解了死锁的一般分析方法，对于这类问题更多的是观察、思考。希望能带给你帮助，如果觉的有用，请帮忙打赏下吧！后续还有一些有意思的dump来分享，比如内存泄漏、死锁+崩溃、踩内存、高cpu等。现在的dump素材没有以前的多了，不然我可以把很多案例都写出来，有些问题没有案例还是挺难讲的。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[异常引起的死锁]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%BC%82%E5%B8%B8%E5%BC%95%E8%B5%B7%E7%9A%84%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[介绍一个json异常导致的死锁分析。同事某天求助帮忙分析一个死锁dump，按照之前查找临界区的方法，他已经具体定位到了某个线程，但是线程打印的堆栈信息却令他没有头绪。 准备工作dump下载地址（提取码：ndel） 步骤1按照之前的方法1）、~*kv 打印所有线程堆栈2）、遍历线程内容，找到可疑点3）、可疑线程为52、53、54…… 2通过查看临界区的OwningThread 找到线程 56切换到~56 线程。 3查看56线程堆栈（kv）1234567891011121314151617181920212223240:056&gt; kvChildEBP RetAddr Args to Child 08ccd8d4 76ddd846 00000000 00000000 00000000 user32!NtUserWaitMessage+0x15 (FPO: [0,0,0])08ccd910 76ddda5c 06f400d2 00000000 00000000 user32!DialogBox2+0x222 (FPO: [Non-Fpo])08ccd93c 76e0f7d0 76da0000 09f6fe90 00000000 user32!InternalDialogBox+0xe5 (FPO: [Non-Fpo])08ccd9f0 76e0faac 00012010 00000000 ffffffff user32!SoftModalMessageBox+0x757 (FPO: [Non-Fpo])08ccdb48 76e0fbaf 08ccdb54 00000028 00000000 user32!MessageBoxWorker+0x269 (FPO: [Non-Fpo])08ccdbb4 76e0fc2e 00000000 0084acf8 09ee8d38 user32!MessageBoxTimeoutW+0x52 (FPO: [Non-Fpo])08ccdbe8 76e0fd81 00000000 08ccdd84 0028f764 user32!MessageBoxTimeoutA+0x76 (FPO: [Non-Fpo])08ccdc08 76e0fdc6 00000000 08ccdd84 0028f764 user32!MessageBoxExA+0x1b (FPO: [Non-Fpo])*** WARNING: Unable to verify checksum for XYSoapClient.dll*** ERROR: Symbol file could not be found. Defaulted to export symbols for XYSoapClient.dll - 08ccdc24 0028cdd9 00000000 08ccdd84 0028f764 user32!MessageBoxA+0x18 (FPO: [Non-Fpo])WARNING: Stack unwind information not available. Following frames may be wrong.08ccde24 0028bf49 0000000a 00289e54 0028ba37 XYSoapClient!DllUnregisterServer+0x6bae08ccde5c 769a03bb 08ccdf14 9616d04a 00000000 XYSoapClient!DllUnregisterServer+0x5d1e08ccdee4 77d65be7 08ccdf14 77d65ac4 00000000 kernel32!UnhandledExceptionFilter+0x127 (FPO: [Non-Fpo])08ccdeec 77d65ac4 00000000 08ccfe1c 77d1c620 ntdll!__RtlUserThreadStart+0x62 (FPO: [SEH])08ccdf00 77d65951 00000000 00000000 00000000 ntdll!_EH4_CallFilterFunc+0x12 (FPO: [Uses EBP] [0,0,4])08ccdf28 77d53529 fffffffe 08ccfe0c 08cce064 ntdll!_except_handler4+0x8e (FPO: [Non-Fpo])08ccdf4c 77d534fb 08cce014 08ccfe0c 08cce064 ntdll!ExecuteHandler2+0x26 (FPO: [Uses EBP] [5,3,1])08ccdf70 77d5349c 08cce014 08ccfe0c 08cce064 ntdll!ExecuteHandler+0x24 (FPO: [5,0,3])08ccdffc 77d00143 01cce014 08cce064 08cce014 ntdll!RtlDispatchException+0x127 (FPO: [Non-Fpo])08ccdffc 00000000 01cce014 08cce064 08cce014 ntdll!KiUserExceptionDispatcher+0xf (FPO: [2,0,0]) (CONTEXT @ 00000008) 疑惑同事按照方法找到了导致死锁的线程，但从堆栈中却看不出原因，都是系统函数，有点无从下手。从这个堆栈信息大致猜测是该线程触发了一个异常并弹出了异常框导致线程阻塞（由于是服务模式所以看不到这个异常框），但是锁资源却没有释放，从而导致了其他线程也出现了死锁。接下来，我们需要从这个堆栈信息切换到异常发生时的堆栈信息。 切换异常上下文函数原型1KiUserExceptionDispatcher( PEXCEPTION_RECORD pExcptRec, CONTEXT * pContext ) KiUserExceptionDispatcher 的第二个参数其实就是上下文地址108ccdffc 00000000 01cce014 08cce064 08cce014 ntdll!KiUserExceptionDispatcher+0xf (FPO: [2,0,0]) (CONTEXT @ 00000008) 可以通过如下命令，切换上下文1.cxr 08cce064 最终得到的异常堆栈1234567891011121314151617181920212223240:056&gt; .cxr 08cce064 eax=08cce4c8 ebx=00792f90 ecx=00000003 edx=00000000 esi=00f3de44 edi=08cce570eip=7767c54f esp=08cce4c8 ebp=08cce518 iopl=0 nv up ei pl nz ac po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000212KERNELBASE!RaiseException+0x58:7767c54f c9 leave0:056&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 08cce518 6f799339 e06d7363 00000001 00000003 KERNELBASE!RaiseException+0x58 (FPO: [Non-Fpo])08cce558 00ee5f9b 08cce570 00f3de44 419ffac3 msvcr120!_CxxThrowException+0x5b (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]08cce5a0 00ee3852 08cce660 419ff9eb 00f1be7d gssssvr!Json::throwLogicError+0x7b08cce688 00ee42c4 00f1be7c 00f1be83 00792f88 gssssvr!Json::Value::find+0x8208cce6a0 00e1d5a5 00f1be7c 419fe277 09f03cd0 gssssvr!Json::Value::isMember+0x2408ccfd14 00e1bc40 007c5b50 09f04018 0084eb60 gssssvr!CGameServer::OnSendSysMsgToServer+0x985 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gssssvr\gssssvr\server.cpp @ 675]08ccfd44 00ed9124 007c5b50 09f04018 00792f90 gssssvr!CGameServer::OnRequest+0x90 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gssssvr\gssssvr\server.cpp @ 162]08ccfd6c 00eccf1b 00000000 045f7f30 008295e8 gssssvr!CIocpWorker::DoWorkLoop+0xa408ccfd84 00ecceeb 08ccfdc4 6f7ac01d 00792f88 gssssvr!CBaseWorker::WorkerThreadProc+0x2b08ccfd8c 6f7ac01d 00792f88 961623f0 00000000 gssssvr!CBaseWorker::WorkerThreadFunc+0xb08ccfdc4 6f7ac001 00000000 08ccfddc 7696336a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]08ccfdd0 7696336a 008295e8 08ccfe1c 77d29902 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]08ccfddc 77d29902 008295e8 ab5803ad 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])08ccfe1c 77d298d5 6f7abfb4 008295e8 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])08ccfe34 00000000 6f7abfb4 008295e8 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 这个堆栈信息就可以看清楚触发异常的具体代码，结合windbg的‘watch’‘local’功能查看变量信息，找到具体原因。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用CMap导致服务高CPU]]></title>
    <url>%2F2019%2F05%2F07%2F%E4%BD%BF%E7%94%A8CMap%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E9%AB%98CPU%2F</url>
    <content type="text"><![CDATA[某天某服务预警一直提示某服务性能不足，cpu已满负荷。很是纳闷，这个服务是纯内存数据，没有io操作；而且都运行了快3个月了，怎么突然就性能不足了？ 步骤1半夜从睡梦中被叫醒，先自己缕一缕思路（整个人都是懵的，基本缕不出思路），先解决线上问题， 让运维保存了一份fulldump，然后重启服务，线上正常，回去睡觉。 异常出现时需要哪些现场信息，比如日志、dump、cpu、内存状态……;因为平时有积累，比如cpu、内存信息主机是有程序在定时生成的；版本（svn、pdb、exe)是自动化编译自动保存的；…… 步骤2向运维取了当时的dump文件(提取码: q5kx)，向版本服务器获取了匹配的pdb、svn记录，获取了当时的日志、cpu、内存信息。使用windbg 打开dump，发现是一个64位dump。 步骤3加载pdb，将64位dump切换到32位，然后打印所有线程。12340:000&gt; .load wow64exts0:000&gt; !swSwitched to 32bit mode0:000:x86&gt; ~*kv 123456789101112131415161718192021222324252627282930313233 0 Id: c2c.a4c Suspend: 0 Teb: 7efdb000 Unfrozen*** ERROR: Symbol file could not be found. Defaulted to export symbols for ntdll.dll - *** ERROR: Symbol file could not be found. Defaulted to export symbols for kernel32.dll - ChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.0015f260 75dd1194 000000e4 ffffffff 00000000 ntdll_77b80000!NtWaitForSingleObject+0x150015f278 75dd1148 000000e4 ffffffff 00000000 kernel32!WaitForSingleObjectEx+0x43*** ERROR: Symbol file could not be found. Defaulted to export symbols for sechost.dll - 0015f28c 77717be6 000000e4 ffffffff e15460f0 kernel32!WaitForSingleObject+0x120015f330 77718040 0059f808 000000e4 00000000 sechost!I_ScIsSecurityProcess+0x8a70015f3e4 77718553 0015f3f8 00000000 00000001 sechost!RegisterServiceCtrlHandlerExA+0x27a*** WARNING: Unable to verify checksum for kubsvr.exe0015f3fc 001dd97b 0015f408 0015f438 001dd850 sechost!StartServiceCtrlDispatcherA+0x680015f418 001c76ad 7aed560b 0002001d 00000000 kubsvr!CNTService::StartServiceA+0x2b0015f91c 001de205 00000001 005938e0 0058cc28 kubsvr!main+0x28d (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\kubsvr\main.cpp @ 165]0015f95c 75dd338a 7efde000 0015f9a8 77bb9902 kubsvr!__tmainCRTStartup+0xfd (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\dllstuff\crtexe.c @ 626]0015f968 77bb9902 7efde000 ec718eae 00000000 kernel32!BaseThreadInitThunk+0x120015f9a8 77bb98d5 001de26d 7efde000 ffffffff ntdll_77b80000!RtlInitializeExceptionChain+0x630015f9c0 00000000 001de26d 7efde000 00000000 ntdll_77b80000!RtlInitializeExceptionChain+0x36 1 Id: c2c.dfc Suspend: 0 Teb: 7ef9d000 Unfrozen*** ERROR: Symbol file could not be found. Defaulted to export symbols for user32.dll - ChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.0265fef4 001cf23b 0265ff0c 00000000 00000000 user32!DispatchMessageW+0x5c0265ff2c 001dd91d 00000000 005a6b00 00000000 kubsvr!CMainService::Run+0x4b (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\kubsvr\service.cpp @ 68]0265ff4c 777175a8 00000001 005a6b10 00000000 kubsvr!CNTService::ServiceMain+0xcd0265ff60 75dd338a 005a6b00 0265ffac 77bb9902 sechost!I_ScIsSecurityProcess+0x2690265ff6c 77bb9902 005a6b00 ee0188aa 00000000 kernel32!BaseThreadInitThunk+0x120265ffac 77bb98d5 77717587 005a6b00 ffffffff ntdll_77b80000!RtlInitializeExceptionChain+0x630265ffc4 00000000 77717587 005a6b00 00000000 ntdll_77b80000!RtlInitializeExceptionChain+0x36................................................ 步骤4分析各个线程。从线程中可以看到总共有24个线程，其中有部分能看到代码，有部分不能看到代码。我们只能先从有代码的线程开始分析，因为这部分线程才是自己程序的主要处理模块。可以看到大多线程都在处理 CSockServer::OnPlayerLogon 函数，查看对应的代码，理了下大概逻辑：服务程序使用8个线程接收用户登陆请求，并将用户信息保存在一个全局CMap中，CMay的key是用户id，value是一个类。这个dump线程反应出来的就是当时在处理很多用户的登陆信息，没有什么异常点啊？？？？ 当时就觉的碰到坎了，认为导的dump可能不是引起cpu高时的运行栈， 后悔应该让运维多导几个dump，通过比较应该找的到高cpu时线程运行栈。暂时没辙就打开看下当时的参数信息，慢慢的就看到了CMap的大小 切换到9号线程~9s123456789101112131415160:009:x86&gt; kvChildEBP RetAddr Args to Child 0377f87c 001b3a7d 0addba3c 0377f898 0377f890 kubsvr!CMap&lt;int,int,_tagPLAYER_LOGON_MINI,_tagPLAYER_LOGON_MINI &amp;&gt;::GetAssocAt+0x61 (FPO: [Non-Fpo]) (CONV: thiscall) [c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\afxtempl.h @ 1542]0377f8a8 001bad38 0addba3c 005a1a58 200d99a8 kubsvr!CMap&lt;int,int,_tagPLAYER_LOGON_MINI,_tagPLAYER_LOGON_MINI &amp;&gt;::operator[]+0x1d (FPO: [Non-Fpo]) (CONV: thiscall) [c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\afxtempl.h @ 1589]0377f8c0 001b7a53 0addba3c 0377f8e0 798f5637 kubsvr!CMap&lt;int,int,_tagPLAYER_LOGON_MINI,_tagPLAYER_LOGON_MINI &amp;&gt;::SetAt+0x18 (FPO: [Non-Fpo]) (CONV: thiscall) [c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\afxtempl.h @ 1349]0377f920 001cfc90 1c8d1540 2008cb20 00593ee8 kubsvr!CSockServer::OnPlayerLogon+0xb3 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\kubsvr\folder.cpp @ 1602]0377f950 001d1904 1c8d1540 2008cb20 005a1a60 kubsvr!CSockServer::OnRequest+0x660 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\kubsvr\socksvr.cpp @ 166]0377f978 001d818b 00000000 005be950 005bd800 kubsvr!CIocpWorker::DoWorkLoop+0xa40377f990 001d815b 0377f9d0 7347c01d 005a1a58 kubsvr!CBaseWorker::WorkerThreadProc+0x2b0377f998 7347c01d 005a1a58 e2366994 00000000 kubsvr!CBaseWorker::WorkerThreadFunc+0xbWARNING: Stack unwind information not available. Following frames may be wrong.0377f9d0 7347c001 00000000 0377f9e8 75dd338a MSVCR120!_get_flsindex+0x6f0377f9dc 75dd338a 005bd800 0377fa28 77bb9902 MSVCR120!_get_flsindex+0x530377f9e8 77bb9902 005bd800 ef138d2e 00000000 kernel32!BaseThreadInitThunk+0x120377fa28 77bb98d5 7347bfb4 005bd800 ffffffff ntdll_77b80000!RtlInitializeExceptionChain+0x630377fa40 00000000 7347bfb4 005bd800 00000000 ntdll_77b80000!RtlInitializeExceptionChain+0x36 打开windbg菜单“view”中的“local”、“calls” 可以看到CMap的m_nCount = 0n770036,放置了大约70w用户，调用CMap.SetAt()。难道SetAt性能不好？？ 由于是前人的历史代码，我对CMap基本不熟悉，所以就抱着这个疑问写了个demo进行验证，果然，在CMap达到40w左右时，SetAt性能急剧下降，到70w左右插入可能需要10秒的时间。更换了std::map ，长期观察程序很稳定。 结论在分析高cpu时有几个操作不对的地方，1）没有让运维多导几个fulldump2）CMap性能差真没想到，吃一堑长一智，看来都得用std::map 才行 后续的任务1）全部门代码替换CMap为std::map]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[捕获异常并自动保存dump]]></title>
    <url>%2F2019%2F05%2F07%2F%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%B9%B6%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98dump%2F</url>
    <content type="text"><![CDATA[SetUnhandledExceptionFilter 捕获的异常有限，比如ctr异常、栈溢出的异常就无法捕获。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/************************************************************************//* 之所以应用程序捕获不到栈溢出异常，原因是因为新版本的CRT实现在异常处理中强制删除所有应用程序先前设置的捕获函数，如下所示：__crtUnhandledException()&#123;SetUnhandledExceptionFilter(NULL);UnhandledExceptionFilter(&amp;ExceptionPointers);&#125;解决方法是拦截CRT调用SetUnhandledExceptionFilter函数，使之无效。在X86平台下，可以使用以下代码 * //************************************************************************/void DisableSetUnhandledExceptionFilter()&#123; void *addr = (void*)GetProcAddress(LoadLibrary(_T("kernel32.dll")), "SetUnhandledExceptionFilter"); if (addr) &#123; unsigned char code[16]; int size = 0; code[size++] = 0x33; code[size++] = 0xC0; code[size++] = 0xC2; code[size++] = 0x04; code[size++] = 0x00; DWORD dwOldFlag, dwTempFlag; (void)VirtualProtect(addr, size, PAGE_READWRITE, &amp;dwOldFlag); (void)WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL); (void)VirtualProtect(addr, size, dwOldFlag, &amp;dwTempFlag); &#125;&#125;void WriteMiniDMP(struct _EXCEPTION_POINTERS *pExp)&#123; CString strDumpFile; TCHAR szFilePath[MAX_PATH]; GetModuleFileName(NULL, szFilePath, MAX_PATH); *strrchr(szFilePath, '\\') = 0; SYSTEMTIME stTime; GetLocalTime(&amp;stTime); // 保存fulldump &#123; strDumpFile.Format("%s\\[%02d-%02d %02d-%02d-%02d]full.dmp", szFilePath, stTime.wMonth, stTime.wDay, stTime.wHour, stTime.wMinute, stTime.wSecond); HANDLE hFile = CreateFile(strDumpFile, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile != INVALID_HANDLE_VALUE) &#123; MINIDUMP_EXCEPTION_INFORMATION ExInfo; ExInfo.ThreadId = ::GetCurrentThreadId(); ExInfo.ExceptionPointers = pExp; ExInfo.ClientPointers = NULL; // write the dump (void)MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, (MINIDUMP_TYPE)0x9b67, &amp;ExInfo, NULL, NULL); CloseHandle(hFile); &#125; &#125;&#125;LONG WINAPI ExpFilter(struct _EXCEPTION_POINTERS *pExp)&#123; static bool flag = false; if (!flag)&#123; // 防止多个线程同时写dump导致系统函数死锁 flag = true; WriteMiniDMP(pExp); flag = false; &#125; return EXCEPTION_EXECUTE_HANDLER;&#125;int main(int argc, char* argv[])&#123; ::SetUnhandledExceptionFilter(ExpFilter); //捕获crt的栈溢出异常 if ("10" != getOSName()) // win10 系统不生效 &#123; DisableSetUnhandledExceptionFilter(); &#125; ........&#125; 如上基本可以捕获大部分异常]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单分析minidump(2)]]></title>
    <url>%2F2019%2F05%2F07%2F%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90minidump-2%2F</url>
    <content type="text"><![CDATA[有了前几节的准备工作，我们的程序已经可以自动捕获异常了，那么我们开始通过windbg来分析dump解决实际问题。先从简单入手，CString大小写转化导致的异常（提取码ffk6）。 步骤1使用windbg打开minidump，设置好应用程序的pdb， 执行命令 “.ecxr” 、”kv” ,打印如下栈信息 1234567891011121314151617181920212223242526272829300:121&gt; .ecxreax=0e16eea8 ebx=00160768 ecx=00000000 edx=00000001 esi=0e16ef38 edi=0e16ef48eip=7c80bef7 esp=0e16eea4 ebp=0e16eef8 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206Unable to load image C:\WINDOWS\system32\kernel32.dll, Win32 error 0n2*** WARNING: Unable to verify timestamp for kernel32.dll*** ERROR: Module load completed but symbols could not be loaded for kernel32.dllkernel32+0xbef7:7c80bef7 ?? ???*** ERROR: Module load completed but symbols could not be loaded for mfc120.dll0:121&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.0e16eea0 1028bc8c e06d7363 00000001 00000000 kernel32+0xbef7*** WARNING: Unable to verify timestamp for msvcr120.dll*** ERROR: Module load completed but symbols could not be loaded for msvcr120.dll0e16eef8 005a9339 e06d7363 00000001 00000003 mfc120+0x28bc8c0e16ef38 101eee11 0e16ef48 1028bc8c 1029b540 msvcr120+0x193390e16ef4c 100566d4 00160760 0b139848 004a67d2 mfc120+0x1eee11*** WARNING: Unable to verify timestamp for BlockSvr.exe0e16ef8c 004dc703 0b224248 ec476e15 00000002 mfc120+0x566d40e16fea0 004c2bcf 0b139e10 0b167c20 001dfe60 BlockSvr!CSockServer::OnLogonUserV2+0x723 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\user.cpp @ 11713]0e16ff2c 005041e4 0b139e10 0b167c20 00160768 BlockSvr!CSockServer::OnRequest+0x90f (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\socksvr.cpp @ 424]0e16ff54 0050c04b 00000000 0b088970 0b2ec408 BlockSvr!CIocpWorker::DoWorkLoop+0xa40e16ff6c 0050c01b 0e16ffac 005bc01d 00160760 BlockSvr!CBaseWorker::WorkerThreadProc+0x2b0e16ff74 005bc01d 00160760 9835355e 00000000 BlockSvr!CBaseWorker::WorkerThreadFunc+0xb0e16ffac 005bc001 00000000 0e16ffec 7c82482f msvcr120+0x2c01d0e16ffb8 7c82482f 0b2ec408 00000000 00000000 msvcr120+0x2c0010e16ffec 00000000 005bbfb4 0b2ec408 00000000 kernel32+0x2482f 步骤2显示了应用程序的代码行号，但我们希望看到更仔细点，就需要加载windows的系统符号文件 1e:\mylocalsymbols;SRV*e:\mylocalsymbols*http://msdl.microsoft.com/download/symbols 步骤3设置后，重新“kv” 查看堆栈信息，显示如下 12345678910111213141516170:121&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 0e16eef8 005a9339 e06d7363 00000001 00000003 kernel32!RaiseException+0x53 (FPO: [Non-Fpo])0e16ef38 101eee11 0e16ef48 1028bc8c 1029b540 msvcr120!_CxxThrowException+0x5b (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]0e16ef4c 100566d4 00160760 0b139848 004a67d2 mfc120!AfxThrowInvalidArgException+0x19 (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\except.cpp @ 228]*** WARNING: Unable to verify timestamp for BlockSvr.exe0e16ef58 004a67d2 ec477f39 00000000 49bf1ce1 mfc120!ATL::CStringT&lt;char,StrTraitMFC_DLL&lt;char,ATL::ChTraitsCRT&lt;char&gt; &gt; &gt;::MakeLower+0x23 (FPO: [0,0,0]) (CONV: thiscall) [f:\dd\vctools\vc7libs\ship\atlmfc\include\cstringt.h @ 1796]0e16ef8c 004dc703 0b224248 ec476e15 00000002 BlockSvr!IsTempLogonToken+0x52 (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\main.cpp @ 2277]0e16fea0 004c2bcf 0b139e10 0b167c20 001dfe60 BlockSvr!CSockServer::OnLogonUserV2+0x723 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\user.cpp @ 11713]0e16ff2c 005041e4 0b139e10 0b167c20 00160768 BlockSvr!CSockServer::OnRequest+0x90f (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\socksvr.cpp @ 424]0e16ff54 0050c04b 00000000 0b088970 0b2ec408 BlockSvr!CIocpWorker::DoWorkLoop+0xa40e16ff6c 0050c01b 0e16ffac 005bc01d 00160760 BlockSvr!CBaseWorker::WorkerThreadProc+0x2b0e16ff74 005bc01d 00160760 9835355e 00000000 BlockSvr!CBaseWorker::WorkerThreadFunc+0xb0e16ffac 005bc001 00000000 0e16ffec 7c82482f msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]0e16ffb8 7c82482f 0b2ec408 00000000 00000000 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]0e16ffec 00000000 005bbfb4 0b2ec408 00000000 kernel32!BaseThreadStart+0x34 (FPO: [Non-Fpo]) 结论可以看到是由于CString 触发了_CxxThrowException。 服务从VC6版本切换到VS2013，CString 的MakeLower 函数检查变的更加严格，部分特殊用户名在VC6中正确转化，但是在vs2013中会抛出异常，将大小写转化函数替换为CharLower ，问题解决]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单分析minidump(1)]]></title>
    <url>%2F2019%2F05%2F07%2F%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90minidump-1%2F</url>
    <content type="text"><![CDATA[有了前几节的准备工作，我们的程序已经可以自动捕获异常了，那么我们开始通过windbg来分析dump解决实际问题。先从简单入手，一个index过大导致数组越界引发的崩溃。 1、使用windbg 打开dump，设置pdb、系统pdb。 2、设置完成后，执行命令”.ecxr”。 因为是程序自动截获异常，所以dump中已保存了异常的上下文，直接使用”.ecxr” 切换即可。1234560:135&gt; .ecxreax=0dea0048 ebx=0016ae18 ecx=7ff22000 edx=004b38e8 esi=0aba40b8 edi=0016ae10eip=004448cd esp=0ba9ebfc ebp=0ba9ec08 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246CheckSvr!CalcKubIndexByGameID+0x1d:004448cd ?? ??? 3、“kv”。打印异常上下文的栈信息123456789100:135&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 0ba9ec08 0040d9c4 0dea0048 af7220ac 0016ae10 CheckSvr!CalcKubIndexByGameID+0x1d (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\checksvr\main.cpp @ 1082]0ba9fcd4 0040bcb4 0db37c10 0db41a88 0aae48c0 CheckSvr!CSockServer::OnRefreshResultExFromKub+0x1ce4 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\checksvr\cmpaqpro.cpp @ 1081]0ba9feb4 0045ca88 0db37c10 0db41a88 0aae48c0 CheckSvr!CSockServer::OnRefreshResultEx+0x134 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\checksvr\cmpaqpro.cpp @ 419]0ba9ff2c 00477674 0db37c10 0db41a88 0016ae18 CheckSvr!CSockServer::OnRequest+0xd38 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\checksvr\socksvr.cpp @ 1931]0ba9ff54 0047e7db 00000000 0aae5e68 0a9c23a0 CheckSvr!CIocpWorker::DoWorkLoop+0xa40ba9ff6c 0047e7ab 0ba9ffac 0050c01d 0016ae10 CheckSvr!CBaseWorker::WorkerThreadProc+0x2b0ba9ff74 0050c01d 0016ae10 876c3023 00000000 CheckSvr!CBaseWorker::WorkerThreadFunc+0xb 4、异常函数为CalcKubIndexByGameID， 入参的值为0dea0048。 回到代码查看CalcKubIndexByGameID的实现， 1234int CalcKubIndexByGameID(int nGameID )&#123; return g_kub[nGameID];&#125; 明显nGameID 过大导致访问数组越界。 然后排查代码，发现nGameID未使用默认值，某些条件下使用了随机值导致。在代码编译中关闭“代码优化”，才可以使用这种方式。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何错过异常第一现场找到异常上下文]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%A6%82%E4%BD%95%E9%94%99%E8%BF%87%E5%BC%82%E5%B8%B8%E7%AC%AC%E4%B8%80%E7%8E%B0%E5%9C%BA%E6%89%BE%E5%88%B0%E5%BC%82%E5%B8%B8%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
    <content type="text"><![CDATA[介绍前面的章节都在讲解通过SetUnhandledExceptionFilter 设置程序自动捕获异常dump，这类dump通过.ecxr 命令或者 !analyze -v 就可以找到异常，但是在有些情况下（比如别人的项目），没有自动保存异常dump时应该怎么分析呢？ 现象某个新项目在测试环境出现了异常，弹出了一个异常框，这是windows下比较常见的异常框，是因为程序遇到了异常，但是没有设置用户自定异常处理函数，从而触发了windows默认异常处理函数“弹出一个异常提示框”。这种情况下：1、不要关闭对话框。使用windbg attach 到该异常程序2、通过命令 .dump /ma d:\xx.dmp 保存fulldump分析方法通过windbg打开xx.dmp,加载系统符号文件。输入命令1~*er?$t1=((ntdll!_NT_TIB*)@$teb)-&gt;StackLimit;r?$t2=((ntdll!_NT_TIB*)@$teb)-&gt;StackBase;!teb;dps@$t1@$t2 这个命令是打印所有线程的调用栈，通过查找“KiUserExceptionDispatcher”来找到异常上下文。 注意：因为如上命令会打印很多信息，所以windbg ui界面是无法显示的，好的办法是将输出都保存到日志文件中, windbg-&gt;”edit”-&gt;”open/close log file”。1在输出的log文件中查找&quot;KiUserExceptionDispatcher&quot;,如下 123456789101112044bed64 044ba000044bed68 00000000044bed6c 044bf288044bed70 77a70133 ntdll!KiUserExceptionDispatcher+0xf044bed74 014bed84044bed78 [044bedd4]044bed7c 044bed84044bed80 044bedd4044bed84 e06d7363044bed88 00000001044bed8c 00000000044bed90 769cc42d KERNELBASE!RaiseException+0x58 注意其中“[]”的内容，这个地址就是异常上下文地址，最后通过命令.cxr 044bedd4 kv 就可以找到异常点。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windbg分析准备工作]]></title>
    <url>%2F2019%2F05%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[1、可以上网的电脑。用于下载系统符号文件，没有也没有太大关系。 2、应用程序关闭优化。 关闭优化是方便通过windbg查找内存数据的准确性； 3、匹配的应用程序/dll 的pdb文件。有匹配的pdb才可以找到对应的代码行数、内存参数。很重要 4、windbg软件，32位 下载 5、设置系统符号文件路径。 1e:\mylocalsymbols;SRV*e:\mylocalsymbols*http://msdl.microsoft.com/download/symbols 6、设置应用符号文件路径 PS： win10 的windows商店有款 windbg priview 更加推荐。 下一节如何保存dump。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[肠子的小心思]]></title>
    <url>%2F2018%2F05%2F28%2F%E8%82%A0%E5%AD%90%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D%2F</url>
    <content type="text"><![CDATA[读书时间：2018年底 从嘴巴到胃的路途虽然仅仅是万里长征第一步，却是从主观的感知世界到自主神经控制的无意识世界的必经过渡，需要两个世界最大限度得集中注意力和团队合作。团队的默契合作可不是一天两天就能练成的，而是打娘胎里就开始练习了。作为练习，胎儿每天在子宫内都会吞咽下大概半升的羊水，即使有时候失败了也没什么大碍，因为胎儿整个（包括肺）都是浸在水里的，所以自然也不会担心会被“呛到”。 反酸：很好的介绍了胃酸返流的现象、原因和一些解决方法。 睡觉的时候上半身抬高30度的卧位对身体有好处。 古今中午外都适用的防吐窍门： 1、远眺 2、让自己尽量放松 3、吃生姜 4、吃晕车晕船药 5、按摩内关穴 其中生姜、晕车晕船药、内关穴对于情绪性呕吐最有效。放松和催眠可以训练神经的任性，训练的越多，神经就会变得越强健，对抗个普通的考试或者工作压力便不在话下。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微服务设计]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[读书时间：2018 微服务的主要好处：1、技术异构型在一个由多个相互协作的系统中，可以在不同的服务中使用最适合该服务的技术。微服务可以帮助我们更快的采用新技术。 2、弹性 3、扩展庞大的单块服务只能作为一个整体进行扩展。即使系统中只有一小部分存在性能问题，也需要对整个服务进行扩展。 4、简化部署在有几百万行代码行的单块应用程序中，即使只修改一行代码，也需要重新部署整个应用程序才能够发布该变更。这种部署影响很大、风险很高，因此相关干系人不敢轻易做部署。 5、与组织结构相匹配 6、可组合型 7、对可替代性的优化 很多人把城市比作生物，因为城市会时不时地发生变化。当居民对城市的使用方式有所变化，或者收到外力的影响时，城市就会相应地演化。城市规划师应该尽量去预期可能发生的变化，但是也需要明白一个事实：尝试直接对各个方面进行控制往往不会奏效。 建设团队对于一个胸痛技术愿景的主要负责人来说，执行愿景不仅仅等同于做技术决定，和你一起工作的那些自然会做这些决定。对于技术领导人来说，更重要的事情是帮助你的队友成长，帮助他们理解这个愿景，并保证他们可以积极地参与到愿景的实现和调整中来。 微服务架构本身能够提供一种很好的形式。在单块系统中，人们为某些事情负责的机会非常有限，而在微服务架构中存在多个自治的代码库，每个代码库都有着自己独立的生命周期，这就给更多人提供了对单个服务负责的机会，而当这些人在单个服务上面得到足够锻炼之后，就可以给他们更多的责任，从而帮助他们逐步达成自己的职业目标，同时通过分担职责也可以防止某一个人的负担过重。 我坚定地相信，伟大的软件来自于伟大的人。所以如果你只是担心技术问题，那么恐怕你看到的问题远远不及一半。 消息队列使用的bug系统运行起来，感觉很棒。但是在某一次发布后，我们遇到了一个很令人讨厌的问题。我们的消费者不停的崩溃、不停的崩溃、不停的崩溃。最终我们发现了问题所在。代码中存在一个bug，某一种特定请求会导致工作者崩溃。我们当时使用了事务处理队列（类似rabbitmq的持久化），如果在处理过程中崩溃，那么这个消息是不会被消费掉的，然后其他的消费者就会来消费这个消息，然后又崩溃…… 灾难性故障转移的一个典型例子。 处了代码中的bug外，我们还忘了设置一个作业最大重试次数。所以后面不但修复了bug本身，还设置了这个最大重试次数。但是我们也意识到需要又一种方法来查看甚至是重发这些有问题的消息。所以最后实现了一个消息医院（或者叫死信队列），所有失败的消息都会被发送到这里。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加密解密-软件保护的若干忠告]]></title>
    <url>%2F2018%2F05%2F28%2F%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%BF%A0%E5%91%8A%2F</url>
    <content type="text"><![CDATA[读书时间：2018 尽量开发自己的保护机制，不要过分依赖不是自己开发的任何代码。在不影响效率的情况下，保护的核心代码用虚拟机保护软件处理一下，如vmprotect等。 不要太依赖壳的保护，加密壳都能被解开或脱壳，现在许多壳转向虚拟机加密方向，多利用这方面的功能。 增加对软件自身的完整性检查 不要采用一目了然的名字来命名函数和文件 尽可能少地给用户提示信息 将注册码和安装时间记录在多个不同的地方 检查注册信息和时间的代码越分散越好 不要依赖getlocaltime()和getsystemtime（）这种众所周知的函数获取系统时间 如果有可能，可以采用联网检查注册码的方法，并且数据在网上传输时要加密 编程时在软件中嵌入反跟踪的代码，已增加安全性 在检查注册信息的时候插入大量无用的运算以误导解密者 给软件保护加入一定的随机性 如果采用注册码的保护方式，最好时一机一码 如果试用版和正式版是分开两个版本，不要仅仅使相关菜单变灰，而是彻底删除代码 如果软件中包含驱动程序，则最好将保护判断加在驱动程序中 如果采用keyfile的保护方式，则keyfile尺寸不能太小 自己设计的检查注册信息的算法不能过于简单，最好采用比较成熟的密码学算法。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[众病之王]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%BC%97%E7%97%85%E4%B9%8B%E7%8E%8B%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 那些没有经过化学或药学训练的人，可能不会意识到治疗癌症到底有多难。程度几乎——并不完全是，只是几乎——像是要找到一种溶剂，它既可以溶解掉左耳，又能使右耳完好无损。癌细胞与其前身正常细胞之间的差异，竟是如此地微小。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[卓有成效的管理者]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%8D%93%E6%9C%89%E6%88%90%E6%95%88%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 管理者的有效性，强调的是“做正确的事情，把事情做正确”；强调的是“按时做完自己该做的事情并产生成果”;强调的是把“知识转化为成果”。管理者工作的失效、乃至失败，往往是因为没有足够的时间区思考如何做正确的事情或把事情做正确。他们的时间往往被掠夺，使自己陷于日常事务和内部复杂的关系中，疲于奔命，被现实的压力牵着鼻子走，以致忽略了产生成果的方向，忽略了产生成果的外部联系。进而，随着企业规模的扩大，以及内部专业化分工体系的深化，使他们更看不到外部的机会以及协同的必要。 一、重视贡献 二、着眼明日 三、时间管理 四、有效决策 五、用人所长]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[终极算法]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%BB%88%E6%9E%81%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 https://zhuanlan.zhihu.com/p/26512893 比较好的介绍 算法五大流派： ①符号主义：使用符号、规则和逻辑来表征知识和进行逻辑推理，最喜欢的算法是：规则和决策树 ②贝叶斯派：获取发生的可能性来进行概率推理，最喜欢的算法是：朴素贝叶斯或马尔可夫 ③联结主义：使用概率矩阵和加权神经元来动态地识别和归纳模式，最喜欢的算法是：神经网络 ④进化主义：生成变化，然后为特定目标获取其中最优的，最喜欢的算法是：遗传算法 ⑤Analogizer：根据约束条件来优化函数（尽可能走到更高，但同时不要离开道路），最喜欢的算法是：支持向量机]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自控力]]></title>
    <url>%2F2018%2F05%2F28%2F%E8%87%AA%E6%8E%A7%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 我们该怎么做才能减少孩子的学习障碍发生率呢？第一：脑外伤跟病变。对应措施是，家长要注意再孩子做剧烈运动的时候给他们戴头盔保护头部；脑膜炎不要耽误治疗。 第二：就是遗传因素，所以结婚前要了解一下对方的家庭和病史。 第三：孩子在早期教育中缺少成年人的指导，所以在孩子8岁之前要尽量多花时间陪伴他们，多参与孩子的活动。 第四：贫困的家庭环境，所以对于父母来说，要尽量地让自己收入丰厚，并且稳定。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[让问题到你为止]]></title>
    <url>%2F2018%2F05%2F28%2F%E8%AE%A9%E9%97%AE%E9%A2%98%E5%88%B0%E4%BD%A0%E4%B8%BA%E6%AD%A2%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 1、我要把他提拔为销售副经理，我必须通过他才能和整个销售团队联系；从今以后我要尊重每一个销售人员，如何发现任何问题，要先和他沟通，不能随意公开批评或指责他们。 你对待员工的方式及你的一言一行，都会影响他们的情感，这一点对于调动员工的积极性和充分发挥他们的效能来说至关重要，要比你接收的任何教育、你所拥有的智慧或你在工作中积累的经验都重要的多。 在商业对话中，你能够做出的最重大的改变就是用“贡献”一词替代“成功”。在思考时，一旦你开始关注贡献，你的转变就开始了。 2、在人类所有的行为背后，潜在的基本情感动机是什么呢?“对幸福的渴望” 3、微笑只需要牵动我们面部13块肌肉，但皱眉却需要牵动112块肌肉。因为每天冲员工微笑要比皱眉容易得多。 4、深入了解员工的思想、情感和情绪，非常有利于刺激员工提高生产效率，其力量远远大于对工作环境做出的硬性改变。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[秦谜]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%A7%A6%E8%B0%9C%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 天意：统一天下民意：秦灭六国，残酷的强暴了各国人心，违逆大众民意 天意无情，民意人性，天意和民意的离合，左右了历史的动向。秦统一天下 是一部顺天逆民的历史。 天意和民意，是我们观察历史的两束光源，评价历史和历史人物的两个观点。体察天意和民意，方能通古今之变。古代社会，天意重而民意轻；现代社会，民意重而天意薄。天意超前，民意滞后；天意难测而识者少，民意可察而变数多。以史为鉴，当权者顺天重民，调和天意和民意，可谓是须臾而不可忘记。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[丑陋的中国人]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 中国人有这么多丑陋面，只有中国人才能改造中国人。我们中国人口太多，中国人的苦难是多方面的，必须每一个人都要觉醒。如果我们每一个人都成为鉴赏家，我们就能鉴赏自己，鉴赏朋友，鉴赏国家领导人物。这是中国人目前应该走的一条路，也是唯一的一条路。 中国人的陋习：1、不认真，不敬业，悠悠忽忽，吊儿郎当地“混”，是大多数中国人的生活特征。2、只我例外。 我反对闯红灯，只是反对别人闯，我自己却可以闯。3、缺少敢讲敢想的灵性4、见风转陀，人人变成了滑不溜丢的琉璃蛋。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从优秀到卓越]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%BB%8E%E4%BC%98%E7%A7%80%E5%88%B0%E5%8D%93%E8%B6%8A%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 5级领导人体系 第一级： 能力突出的个人。 用自己的智慧、知识、技能和良好的工作作风作出巨大贡献 第二级：乐于奉献的团队成员。为实现集体目标贡献个人才智，与团队成员通力合作 第三级：富有实力的经理人。组织人力资源，高效地朝既定目标前进 第四级：坚强有力的领导人。全身心投入、执著追求清晰可见，催人奋发的愿景，向更高业绩标准努力 第五级：经理人。 将个人的谦虚品质和职业化的坚定意志相结合，建立持续的卓越业绩。 我们以为会是这样的表现：将一个公司从优秀推向卓越的第一步是为公司设定一个新的方向、新的愿景和战略，然后找到合适的人，再朝这个新的方向前进。但我们发现有时情况恰恰相反。他们首先会让合适的人上车，然后才决定去向何处。用他们经典的话语来说：看，我真的不清楚应将这辆车驶向何处。但有有一点毋庸置疑：如果我们和合适的人在车上，并各就其位，而不合适的人已下车，然后我们就可以确定如何将车开向某个卓越之地。 “弱将强兵“模式： 如果在重要位置上安排能干的将军，那么他在公司内的竞争对手就会离开；但若是挑选一个能力一般的将军，那么他周围的校尉们很可能就会留下来。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中国历代政治得失]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 1、政府的组织：政府的权利分配 2、考试和选举 3、赋税制度 4、国防和兵役制度 中国社会不分阶级，却分流派。 清流： 进士、翰林院 称为清流 浊流：举人、秀才为浊流， 永远无法当大官]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[继承者们]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%BB%A7%E6%89%BF%E8%80%85%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 最佳TOP51、汉文帝 刘恒2、唐太宗 李世民不需要做什么完人，情商高点儿，学会起码的自制，就不会做的太糟。3、清太宗 皇太极4、宋太宗 赵光义5、魏文帝 曹丕 最差TOP51、西晋惠帝 司马衷2、秦二世 胡亥3、北齐 高氏4、隋炀帝 杨广5、后唐庄宗 李存勖]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[集装箱改变世界]]></title>
    <url>%2F2018%2F05%2F28%2F%E9%9B%86%E8%A3%85%E7%AE%B1%E6%94%B9%E5%8F%98%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 马儿科姆.麦克莱恩的根本性认识在于，航运业的业务是运货而不是航道。这种认识让他形成了与以往完全不同的集装箱运输的新概念。麦克莱恩认识到，降低货运成本所要求的不仅仅是一只金属箱子，而是一整套货物处理的新方法。这个系统的每一个组成部分，港口、轮船、起动机、存储设备、卡车、火车以及发货人自身的操作等等，都必须做出改变。 集装箱不是改变了航运的时间，而在在系统上 在货运装卸、码头存储提供了全面的新的认识。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最有效的五步推销法]]></title>
    <url>%2F2018%2F05%2F28%2F%E6%9C%80%E6%9C%89%E6%95%88%E7%9A%84%E4%BA%94%E6%AD%A5%E6%8E%A8%E9%94%80%E6%B3%95%2F</url>
    <content type="text"><![CDATA[读书时间2018年 很多场合，我们需要说服别人。比如，说服客户购买产品，说服风投投钱。 如果你只有一次 PPT 演讲的机会，怎么才有最大的说服力？ 第一步，提出一个当今世界的变化趋势不要首先谈论你的产品、你的顾客、你的投资者等等，任何你自己的事情都不要首先谈。第一件事是要介绍世界的趋势。 你要以一种显而易见的、不可否认的、正在发生的世界趋势来开场。这种趋势跟你的产品必须是相关的，可以为你的产品带来重大利益，或者使得你的产品具有重大的急迫性。 你要让对方意识到，这种趋势会影响到他们。如果正确反应的话，他们就能获得机会。 开场即使不能打动听众，也要获取他们的注意力，让他们愿意听你讲下去。注意力是最关键的。 第二步，提出会有赢家和输家即使对方从上面的趋势看到了机会，但是如果同时需要承担巨大风险，他们很可能会选择维持现状。 为了克服这种”风险厌恶”，你需要明确提出，这种趋势会带来大赢家和大输家。如果顺应变化，前景一片光明；如果抵抗变化，前景一片灰暗。也就是说，你要给对方提供巨大的诱因，让他们愿意参与变化。如果保持现状，他们可能会有巨大损失。 第三步，描绘美好的未来到了这个时候，你大概已经忍不住要推销自己产品了。但是，还没到时候，你需要再忍一下。如果太快引入产品，跟前面好不容易营造的上下文可能脱节，对方感到突兀的话，就前功尽弃了。 这时，你要做的是，描绘使用你的产品之后的美好未来，但不要提到你的产品。比如，你可以说”如果发生 xxx 的改变，我们的社会就会出现 xxx 的情景”。你描绘的未来应该非常诱人，同时也应该是很难达到的，否则你的产品就没有存在的理由了。 第四步，介绍克服困难、到达未来所需要的那个关键步骤最成功的推销方法，很像英雄电影或者童话故事。主角达成目标之前，总是需要学会某种技能，或者获得某种宝物。你这时要介绍的，就是那种技能或宝物。 正是因为有了前面那些上下文，你才能在这个部分谈一些细节，否则那些细节就会变得相当乏味和无趣。你这时可以详细解释，为什么传统方法无法达到美好的未来，新的方法如何克服现存的困难。 第五步，提出证据，你能让这一切变成现实既然你已经描述了未来，现在是时候告诉大家，怎样才能到达那里，也就是你的产品跟这一切到底有何相关。 因为前面你已经说了到达那里很困难，所以听众对于你的能力是有怀疑的。你必须举出证据，让人相信你能让这一切成真。 最好的证据莫过于举出一个例子，你已经帮助其他人成功了。如果你还没有成功案例，那可以演示一下产品，演示的重点应该是如何达到你描述的未来。 说服对方，一般很难只靠一次推销演讲。但是，如果你按照上面的结构来做推销，会使得你的机会最大化。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[成大事者不纠结]]></title>
    <url>%2F2017%2F05%2F28%2F%E6%88%90%E5%A4%A7%E4%BA%8B%E8%80%85%E4%B8%8D%E7%BA%A0%E7%BB%93%2F</url>
    <content type="text"><![CDATA[读书时间：2017年 破纠结最好的法门：专注于当下 为人处世忌“目光远大”，一定要“鼠目寸光”，把眼下该办的事办好。这样所有的矛盾，都会在你往前走的过程中自然化解掉了。 “未来不迎，当时不杂，过往不恋“ “不问是非，埋头业务，屁股干净，尽力协调” 一个历史人物，不管他被供奉为神，还是被描述为鬼，当你了解到更多事实的时候，你会发现，只要承认人性是多元的，他的所作所为就是可以理解的。 这个时代，过去的经验没用了，对未来的预测基本都是瞎扯，基于原来人际关系获得的所有巧妙几乎也都失效了。 迷茫时代，如何当一个明白人]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[大型网站技术架构 核心原理与案例分析]]></title>
    <url>%2F2017%2F05%2F28%2F%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[读书时间：2017年 创新的业务发展模式对网站架构逐步提出更高的要求，才使得创新的网站架构得以发展成熟。是业务成就了技术，是事业成就了人，而不是相反。所以网站架构师应该对自己技术成绩的网站事业心存感恩，并努力提高技术回馈业务，才能在快速发展的互联网领域保持持续的进步。、 网站架构设计误区： 1、一味追随大公司的解决方案 2、为了技术而技术 3、企图用技术解决所有问题技术是用来解决业务问题的， 而业务问题，也可以通过业务的手段去解决。 我们的现实生活中充斥着几乎千篇一律的人生架构模式：读重点学校，选热门专业，进稳定高收入的政府部门和企业，找门当户对的配偶，生一个孩子继续这个模式………… 但是人生不同于软件，精彩的人生绝不会来自于复制。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[打开量化投资的黑箱]]></title>
    <url>%2F2017%2F05%2F28%2F%E6%89%93%E5%BC%80%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84%E7%9A%84%E9%BB%91%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[读书时间：2017年 1、本质上，由情绪、无纪律性、激情、贪婪和恐惧驱使的决策，能够在量化投资过程被消除，而这些心理因素被许多人认为是市场投资中出现重大失误的原因。这些心理因素被例行分析和系统化的方法所取代。 一般的，衡量资产质量的指标可以分为五大类1、杠杆比率。 杠杆低的企业要比高的企业更加靠谱 2、收入来源的多样性。 具有多种潜在增长渠道的国家或公司比渠道单一的国家或公司质量要高 3、管理水平。正如你可能想到的那样，从所需要的信息角度去衡量，这是最难以量化的一类指标，但也有些指标可用来度量管理水平，如公司的财务报表中操纵性应计利润的变化。有观点认为，操纵性应计利润的变化越大，公司高层的管理能力越值得质疑。 4、欺诈风险。警示人们：有时候上市公司的高管更专注公司的财报是否漂亮，而不是兢兢业业地管理公司业务。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[环球科学]]></title>
    <url>%2F2017%2F05%2F28%2F%E7%8E%AF%E7%90%83%E7%A7%91%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[2014~2015年合辑版 读书时间：2017年 1、微生命：健康风险度量标准 如果吸两只烟，就会丢掉生命中的30分钟。锻炼20分钟，就会增加了1小时的生命。 2、《爱情疲劳的心理悖论》致命的吸引力： 似乎一开始伴侣最吸引自己的品质，到后来却成了让自己讨厌的缺点。1）、和蔼可亲的人随着时间的流逝会被看成是被动的2）、意志坚强的人，如果常常这样，便会成为固执和不可理喻3）、外向健谈的人可能成为喋喋不休的讨厌鬼4）、热切贴心的追求者变成缠人的伴侣5）、一个富有激情的冒险者会成为一个不负责任的家长6）、一个美丽动人的目标可能成为一个供养不起的情侣7）、悠闲自在让人成为一个懒散的家伙8）、有狂热兴趣爱好可能被看做工作狂 在夫妻关系中好的方法有：1）、当你的伴侣遇到好事时要一同庆祝，这比在他或她遇到困难时提供帮助更有效；2）、经常和你的伴侣做一些有新意、有挑战以及刺激的事情。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[活出生命的意义]]></title>
    <url>%2F2017%2F05%2F28%2F%E6%B4%BB%E5%87%BA%E7%94%9F%E5%91%BD%E7%9A%84%E6%84%8F%E4%B9%89%2F</url>
    <content type="text"><![CDATA[读书时间：2017年 1、一些不可控的力量可能会拿走你很多东西，但它唯一无法剥夺的是你自主选择如何应对不同处境的自由。你无法控制生命中会发生什么，但你可以控制面对这些事情时自己的情绪与行动。 2、本书认为，生活是充满意义的，人们要摒弃环境的侵扰，学会追寻生活的意义。它还强调，生活是有终极目的存在的。 3、不要只想着成功—你越想成功，就越容易失败。成功就像幸福一样，可遇而不可求。它是一种自然而然的产物，是一个人无意识地投身于某一伟大的事业时产生的衍生品，或者是为他人奉献时的副产品。幸福总会降临的，成功也同样：常常是无心插柳柳成荫。我希望你们一切行为服从良心，并用知识去实现它，总有一天你会发现，当然是相当长的时间之后—-注意，我说的是很长一段时间后！—正是由于这种不关注，成功将降临于你。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[稀缺]]></title>
    <url>%2F2017%2F05%2F28%2F%E7%A8%80%E7%BC%BA%2F</url>
    <content type="text"><![CDATA[读书时间：2017 （一）管窥会令人们想要同时做几件事情，因为这样可以节省时间，这是在“管子”视野之内获得的收益；而节省时间的同时可能会出现的问题，则出在“管子”视野之外。 有时，当我们有了管窥之见时，就会完全忽略其他事情。当我们手头有一项急需完成的工作时，就会缩短与家人共度的时光，将理财计划向后推，甚至是例行的体检也要改期。时间特别紧张时，我们就会想：“下周也能陪孩子玩。”而不会想：“孩子现在真的需要我，要等到什么时候我才能真的有时间呢？”对于我们来说，“管子”视野之外的事物并不容易看清，更容易被我们忽略，而且也更容易遗忘。注：“管子”视野，指专注于一些事情。 所谓的因小失大…………………. （二）在面对数额较小的财务问题时，穷人和富人表现没有太大区别；但数额较大的财务问题严重改变了穷人的表现，他们变得更加冲动。 需要控制自己对财务的把控力度，在多大范围内能保持理智…… 穷人的“有效”能力的确比富人要弱一些。这并不是因为穷人的能力差，而是因为他们的一部分大脑早已被稀缺所俘获了。 （大脑的一部分智力和执行力被贫穷干扰了） （三）稀缺，不仅仅会令我们入不敷出，不知如何分配资源，而且还会让我们在生活的其他方面手足无措。稀缺会使人变笨，变得更加冲动。我们不得不在执行控制力和智力被减弱的情况下，依靠更为有效的脑力去勉强度日。生活，就这样变得举步维艰起来。 （四）我们在小物件上连几毛几分钱都会计较，而在大物件上却汇金如土。这样看来，我们所谓的节俭根本派不上用场。我们会花好几个小时在网络上查找，就只是为了从150的鞋子上省去50,；但我们却不会为了一辆价值2w的汽车上省出几百元，而花费几个小时时间去做信息收集。 （五）节俭和穷人的区别。 节俭之人对金钱怀有一种保证富余的责任感，而穷人则需要随时进行权衡。 购买时，节俭之人会思考的是该商品的价格是否“实惠”，相比之下，穷人则会思考，为了付出相应的金钱，他们要放弃什么。 所以说节俭之人并不需要进行真正的权衡，他们与生活在资源充裕条件下的人一样，很难体会到1元钱的真正意义。缺乏清晰价值观会导致可以预见的失误：同样的情况下，富人会放错误，而穷人却能够避免。 （六）可能会让人认为，在资源充裕阶段，我们会精打细算，充满远见卓识。事实当然并非如此。数十年的研究显示，在资源最为充裕的时期，而且特别是在这样的时期，我们尤其容易犯下拖延的毛病。 （七）也许问题并不出在这些项目所提供的扶助内容上，而在于提供扶助的方法。就像第二次世界大战期间的轰炸机驾驶舱一样，也许我们只要通过更加优质的设计，就能提高这些项目的成功率。而更为优质的设计，需要将稀缺心里中所体现的专注力和带宽问题等根本性见解囊括进来。优化设计]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[万历十五年]]></title>
    <url>%2F2017%2F05%2F28%2F%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[读书时间：2017年 生命的真意义，要在历史上获得。 全书的精华在最后一段： 当一个人口众多的国家，各人行动全凭儒家简单粗浅而又无法固定的原则所限制，而法律又缺乏创造性，则其社会发展的程度，必然受到限制。即便是宗旨善良，也不能补助技术之不及。1587年，是为万历十五年，丁亥次岁，表面上视乎是四海升平，无事可记，实际上我们的大明帝国却已经走到了它发展的尽头。在这个时候，皇帝的励精图治或者宴安耽乐，首辅的独裁或者调和，高级将领的富于创造或者习于苟安，文官的廉洁奉公或者贪污舞弊，思想家的极端进步或者绝对保守，最后的结果，都是无分善恶，统统不能再事业上取得有意义的发展，有的身败，有的名裂，还有的人则身败名裂。因此我们的故事只好在这里作悲剧性的结束。万历丁亥年的年鉴，是为历史上一部失败的总记录。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 开始]]></title>
    <url>%2F2016%2F05%2F09%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AF%BC%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[读书笔记其实就是将自己看过的一些书，将其中有感触的东西记下来。16年前也经常看一些书，但我总感觉自己记忆力太差，看完之后过段时间几乎都想不起来，就和没看过一样，所以希望能够做一些笔记，提醒自己曾经看过。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
</search>
