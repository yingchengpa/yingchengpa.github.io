<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[魔鬼经济学（1）]]></title>
    <url>%2F2019%2F05%2F09%2F%E9%AD%94%E9%AC%BC%E7%BB%8F%E6%B5%8E%E5%AD%A6%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读书时间：2019/04/24 – 2019/05/09 摘要《教师与相扑力士有何共同点》 探讨动机的优点及阴暗面—-作弊 《为何三K党和房地产中介是一路货色》论证了信息的力量无可比拟，这种力量一旦遭到滥用，则更显露无疑 《为何毒贩还在与母亲同住》发现传统观念往往是由捏造信息、自身利益和方便之词共同构成的。其实大多毒贩并不是很有钱 《罪犯都去那儿了》分析了有关犯罪的说法哪些是真，哪些是假 《怎样才算完美的父母》从多个角度提出了一个迫切的问题：父母真的重要吗？ “童年早期的纵向研究”中与学校考试成绩相关的8个因素： 父母学历高父母在生育第一胎时的年龄为30或30岁以上出生体重低父母在家讲英语父母参加家长教师联谊会家中藏书多 以及8个无关的因素： 家庭完整父母最近搬入了条件较好的小区母亲在孩子出生后至上幼儿园之前不工作参加过启智计划定期随父母去博物馆经常被打经常看电视几乎每天都听父母读书 笼统来讲，前8个因素是对父母特点的描述，后8个因素是对父母行为的描述。高学历、事业有成、身体健康的父母所生育的子女往往能在学校取得优异成绩；但儿童是否去博物馆、是否被打、是否参加启智计划、是否经常听父母读书，或是否坐在电视机前不离身视乎并无影响。 对于喜欢钻研养儿育女之道的父母——和育儿专家—-来说，这或许是值得深思的发现。事实上，这些育儿知道视乎被严重高估了。 但这并不是说父母毫无影响，显然，父母对育儿而言关系重大。难点在于，当多数人准备拾起育儿经的时候，为时已晚，因为真正重要的因素—-身份、配偶、生活方式—–早已注定。如果你天资聪慧、踏实肯干、教育水平高、收入颇丰且配偶也条件相当，那你的孩子就有更大的概率能在生活中有所成就（正直诚实、体贴周到、富有爱心、对世界充满好奇心想必也不会有害处）。 而至于你的所作所为则并无太大影响，重要的是你本身的特质。 《完美的父母序章》分析了正式为人父母后的第一件事—给孩子起名—-究竟有多重要。 总结作者通过数据分析，理性并有理有据的证明一些有趣的观点，虽然事实并非真的如此，但也是从一个客观地角度考虑事实。对我印象比较深的，就是《怎样才算完美的父母》：儿童早期的学习成绩大概率在父母结婚时就决定了，50%是基因，剩下最重要的就是父母本身的特质，而后天的行为（比如上培训班）影响并不大。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ EH exception]]></title>
    <url>%2F2019%2F05%2F08%2FC-EH-exception%2F</url>
    <content type="text"><![CDATA[介绍某个代理服务器在压力测试时发生异常，以下是定位过程 保存dump因为提早有知道程序会出现异常，所以中间省去了很多步骤，在服务启动时就已经使用windbg attach到了服务进程上，这样一旦程序触发异常windbg立即就会捕获。dump下载：链接：https://pan.baidu.com/s/1Ntm3MRQnbMqGtLkAushSvg 提取码：nvu1 分析过程程序异常在程序运行了15小时之后，程序触发了异常，windbg 上使用 命令 !analyze -v 分析异常原因123456789101112131415161718192021222324252627282930313233343536Failed calling InternetOpenUrl, GLE=12002FAULTING_IP: KERNELBASE!RaiseException+5876dcc42d c9 leaveEXCEPTION_RECORD: ffffffff -- (.exr 0xffffffffffffffff)ExceptionAddress: 76dcc42d (KERNELBASE!RaiseException+0x00000058) ExceptionCode: e06d7363 (C++ EH exception) ExceptionFlags: 00000001NumberParameters: 3 Parameter[0]: 19930520 Parameter[1]: 026ffa68 Parameter[2]: 746dc7fcDEFAULT_BUCKET_ID: APPLICATION_FAULTSTACK_TEXT: 026ffa18 746c9339 e06d7363 00000001 00000003 KERNELBASE!RaiseException+0x58026ffa58 7470da6a 026ffa68 746dc7fc 746dd1cc msvcr120!_CxxThrowException+0x5b [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]026ffa78 009ba351 00004400 03d95cc8 03d95d20 msvcr120!operator new+0x50 [f:\dd\vctools\crt\crtw32\heap\new.cpp @ 62]026ffa8c 009c9c01 00004400 03d95cc8 009c9824 roommpsvr!std::vector&lt;unsigned char,std::allocator&lt;unsigned char&gt; &gt;::_Buy+0x41026ffad4 009c9b9f 0324d520 00621598 2cf7d616 roommpsvr!std::vector&lt;unsigned char,std::allocator&lt;unsigned char&gt; &gt;::vector&lt;unsigned char,std::allocator&lt;unsigned char&gt; &gt;+0x21026ffb08 009c2858 08cb66d8 2cf7d606 045aad60 roommpsvr!mp::MPSocket::create_ssl+0x5f026ffb9c 009c5987 026ffbf8 0000020f 026ffc18 roommpsvr!mp::WSSConnection::handle_judge_protocol+0x248026ffbac 009c5341 026ffbe8 026ffbe8 2cf7d6de roommpsvr!boost::asio::asio_handler_invoke&lt;boost::asio::detail::binder2&lt;boost::_bi::bind_t&lt;void,boost::_mfi::mf2&lt;void,mp::WSConnection,boost::system::error_code const &amp;,unsigned int&gt;,boost::_bi::list3&lt;boost::_bi::value&lt;boost::shared_ptr&lt;mp::WSSConnection&gt; &gt;,boost::arg&lt;1&gt;,boost::arg&lt;2&gt; &gt; &gt;,boost::system::error_code,unsigned int&gt; &gt;+0x17026ffc18 009b603d 00643940 045aad60 026ffc4c roommpsvr!boost::asio::detail::win_iocp_socket_recv_op&lt;boost::asio::mutable_buffers_1,boost::_bi::bind_t&lt;void,boost::_mfi::mf2&lt;void,mp::WSConnection,boost::system::error_code const &amp;,unsigned int&gt;,boost::_bi::list3&lt;boost::_bi::value&lt;boost::shared_ptr&lt;mp::WSSConnection&gt; &gt;,boost::arg&lt;1&gt;,boost::arg&lt;2&gt; &gt; &gt; &gt;::do_complete+0x101026ffc78 009b5ba7 2cf7d166 026ffcc8 2cf7d1aa roommpsvr!boost::asio::detail::win_iocp_io_service::do_one+0x17d026ffcb4 009b63fa 026ffcc8 00647e70 00647e70 roommpsvr!boost::asio::detail::win_iocp_io_service::run+0xc7026ffcd0 00b182de 2cf7d1e6 00000000 00651090 roommpsvr!boost::asio::io_service::run+0x2a026ffcf8 746dc01d 00647e70 ff4a9697 00000000 roommpsvr!boost::`anonymous namespace&apos;::thread_start_function+0x5e026ffd30 746dc001 00000000 026ffd48 769f337a msvcr120!_callthreadstartex+0x1b [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]026ffd3c 769f337a 00650900 026ffd88 77389882 msvcr120!_threadstartex+0x7c [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]026ffd48 77389882 00650900 a6a6cb5f 00000000 kernel32!BaseThreadInitThunk+0xe026ffd88 77389855 746dbfb4 00650900 ffffffff ntdll!__RtlUserThreadStart+0x70026ffda0 00000000 746dbfb4 00650900 00000000 ntdll!_RtlUserThreadStart+0x1b 查看堆栈从堆栈信息中可以看到，在mp::MPSocket::create_ssl 中new了对象，然后new.cpp@62 抛出了一个异常1234567891011void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc) &#123; // try to allocate size bytes void *p; while ((p = malloc(size)) == 0) if (_callnewh(size) == 0) &#123; // report no memory _THROW_NCEE(_XSTD bad_alloc, ); ----------&gt;&gt;&gt; @62 &#125; return (p); &#125; 查看内存信息使用工具processxp 查看对应服务的内存状态，虚拟内存、提交内存 都是很低的，不太可能会出现内存申请失败。 进一步确认原因12345678EXCEPTION_RECORD: ffffffff -- (.exr 0xffffffffffffffff)ExceptionAddress: 76dcc42d (KERNELBASE!RaiseException+0x00000058) ExceptionCode: e06d7363 (C++ EH exception) ExceptionFlags: 00000001NumberParameters: 3 Parameter[0]: 19930520 Parameter[1]: 026ffa68 Parameter[2]: 746dc7fc google 搜索 “e06d7363 (C++ EH exception)”， 查看链接：https://blogs.msdn.microsoft.com/oldnewthing/20100730-00/?p=13273按照它的步骤进一步确认C++ 异常原因：123456780:008&gt; dd 746dc7fc l4 ---&gt; 是小写的“L&quot;746dc7fc 00000000 746e3cc0 00000000 746dc80c0:008&gt; dd 746dc80c l2746dc80c 00000002 746dd1ac0:008&gt; dd 746dd1ac l2746dd1ac 00000010 74790d380:008&gt; da 74790d38 + 874790d40 &quot;.?AVbad_alloc@std@@&quot; 发现的确是 “bad_alloc@std” 导致的异常。 仔细观察物理机器的状态，发现其中一个redis服务吃了大概2G多的内存，会不会是这个原因导致服务进程在申请pagefile时失败呢？ 杀掉异常进程继续观察。 总结长时间观察程序正常。本文的目的主要是介绍如何解码c++异常的具体原因。 附其他操作1026ffa58 7470da6a 026ffa68 746dc7fc 746dd1cc msvcr120!_CxxThrowException+0x5b (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152] 123__CxxThrowException( void* pExceptionObject, // The object thrown _ThrowInfo* pThrowInfo // Everything we need to know about it 746dc7fc 其实就是_ThrowInfo 结构体的指针信息，通过watch查看1234567typedef const struct _s__ThrowInfo&#123;unsigned int attributes;_PMFN pmfnUnwind;int (__cdecl*pForwardCompat)(...);_CatchableTypeArray *pCatachableTypeArray;&#125; _ThrowInfo; 结构体中重要的成员是_CatchableTypeArray。它包含了程序运行时抛出对象的类新信息(RTTI).如果你的程序运行时抛出一个my_exception类型的对象，那么抛出的数据参数pCatchableTypeArray包含了两个重要子数据信息。一个是typeid(my_exception)，另外一个是typeid(std::exception)。 所以通过watch查看：12345(ThrowInfo*)0x746dc7fc 0x746dc7fc struct _s_ThrowInfo *-attributes 0-pmfnUnwind 0x746e3cc0-pForwardCompat 0x00000000-pCatchableTypeArray 0x746dc80c struct _s_CatchableTypeArray * 123dd 0x746dc80c 746dc80c 00000002 746dd1ac 746e3b04 eb0cc483746dc81c be575612 7478fcb0 790d68bf 047e8374 12345678910watch 中查看(_s_CatchableType*)0x746dd1ac(_s_CatchableType*)0x746dd1ac 0x746dd1ac struct _s_CatchableType *-properties 0x10-pType 0x74790d38 struct TypeDescriptor *--hash 0x746bec94-spare 0x00000000--name char [] &quot;.?AVbad_alloc@std@@&quot;-thisDisplacement struct PMD-sizeOrOffset 0n12-copyFunction 0x746dd190]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows下c++反射功能]]></title>
    <url>%2F2019%2F05%2F08%2Fwindows%E4%B8%8Bc-%E5%8F%8D%E5%B0%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[背景c++开发的软件在生产环境中运行出现一些bug，比如参数错误等问题，通过日志只能打印异常的行号或函数，但具体的结构体/类的参数内容打印却非常麻烦，无法做到一些更高级语言的反射功能。要做到能够通过变量地址就打印变量的内容信息，就需要依赖ms提供的msdia120.dll和程序编译后的pdb文件。 原理msdia120.dll 需要注册到目标机器，通过提供的接口函数可以解析pdb文件中的结构体、类，并提供这个成员变量的类型、相对的地址偏移。 效果demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;typeinfo&gt;#include &quot;tcDump.h&quot;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;list&gt;struct STTEST&#123; int a; double b; float c; short d; char szName[32]; void *p;&#125;;class CClassTest&#123;public: std::string m_strName; std::vector&lt;int&gt; m_oVec; std::map&lt;int, std::string&gt; m_oMap; //std::list&lt;int&gt; m_oList; // 不支持，慢慢完善&#125;;int _tmain(int argc, _TCHAR* argv[])&#123; if (0 == TCDUMP_INIT(&quot;ConsoleApplication1.pdb&quot;))&#123; return false; &#125; //结构体 &#123; STTEST st = &#123; 0 &#125;; st.a = 1; st.b = 1.2; st.c = 2.3; st.d = 655; memcpy(st.szName, &quot;hello world&quot;, 12); st.p = (void*)0x123456; auto json = TCDUMP(st); if (NULL == json)&#123; return false; &#125; printf(&quot;%s\n&quot;, json); &#125; //类对象 &#123; CClassTest oTest; oTest.m_strName = &quot;this is a test for string&quot;; oTest.m_oVec.push_back(6); oTest.m_oVec.push_back(7); oTest.m_oVec.push_back(8); oTest.m_oMap[0] = &quot;this is 0&quot;; oTest.m_oMap[1] = &quot;this is 1&quot;; oTest.m_oMap[2] = &quot;this is 2&quot;; auto json = TCDUMP(oTest); if (NULL == json)&#123; return false; &#125; printf(&quot;%s\n&quot;, json); &#125; return 0;&#125; 输出效果123456789101112131415161718&#123; &quot;a&quot; : 1, &quot;b&quot; : 1.2, &quot;c&quot; : 2.2999999523162842, &quot;d&quot; : 655, &quot;p&quot; : &quot;[0x00123456]&quot;, &quot;szName&quot; : &quot;hello world&quot;&#125;&#123; &quot;m_oMap&quot; : &#123; &quot;0&quot; : &quot;this is 0&quot;, &quot;1&quot; : &quot;this is 1&quot;, &quot;2&quot; : &quot;this is 2&quot; &#125;, &quot;m_oVec&quot; : [ 6, 7, 8 ], &quot;m_strName&quot; : &quot;this is a test for string&quot;&#125; 后续在每个关键函数的入口增加一个宏定义，就可以轻松的定位参数错误的问题，而省去了大量的远程调试时间。 二次开发visual studio 的安装路径下存在一个demo程序：DIA SDK 。可以通过修改其中的代码实现，当然我的百度网盘有封装后的sdk更加容易使用。 https://pan.baidu.com/s/1takuuHhxGt_WkLQWGDeacQ msdia120.dll tcDump.dll tcDump.h tcDump.lib tcDumpD.lib tcDumpD.dll 使用说明.txt]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搭建pdb服务器]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%90%AD%E5%BB%BApdb%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[背景目前使用jenkins进行每日编译、部署，但是一旦程序出现异常后，查找正确的pdb文件也是件麻烦的事情，所以希望能有微软符号服务器一样的功能。 步骤通过google 查找一些资料，自己尝试了下，还是比较简单的. 安装windbg环境变量path 中设置windbg路径。 准备一块大硬盘会保存很多历史版本的pdb，所以有必要准备一块大硬盘 测试管理员方式运行cmd 1234567symstore add /r /f d:\public_game\*.pdb /s e:\symstore /t "gamechannel"其中 'd:\public_game\*.pdb' 为编译后的pdb路径'e:\symstore' pdb服务器路径"gamechannel" 产品名称更多参数说明 symstore -help 搭建http服务我们需要提供对外访问符号文件的途径，最简便的方式就是使用IIS创建一个HTTP服务并对外开放。使用搭SII建HTTP服务器的教程网上很多，这里简述以下: 打开IIS，选择网站-&gt;右键“添加网站” 输入网站名称，如Symbols，选择刚创建的符号文件存储目录为物理路径，端口为6776 ,其他保持默认，点击确定。 在网站主页中打开MIME类型，右侧添加，文件扩展名输入PDB,MIME类型输入application/octet-stream。这一步是为了允许从该站点访问读取PDB类型的文件。 设置权限。我们创建的网站默认情况下是不允许匿名用户访问的，为了允许调试器下载符号，我们需要添加一定的权限。点击右键我们的网站-&gt;编辑权限-&gt;选择安全选项卡-&gt;添加IIS_IUSRS用户或everyone用户并赋予Read &amp; execute，List folder contents和Read三项权限。 左侧右键刚创建的网站-&gt;管理网站-&gt;重新启动。 jenkins 设置在jenkins 原本保存exe、pdb 的命令下 增加 以上命令即可 windbg 设置12SRV*e:\mylocalsymbols*http://msdl.microsoft.com/download/symbolsSRV*e:\companysymbols*http://192.168.1.7:1234/ 好了，pdb 就可以自动获取了]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[踩内存（内存溢出）的异常定位]]></title>
    <url>%2F2019%2F05%2F07%2F%E8%B8%A9%E5%86%85%E5%AD%98%EF%BC%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%89%E7%9A%84%E5%BC%82%E5%B8%B8%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[介绍某天晚上11点，钉钉预警提示某服务catch到一个异常导致服务重启，因为是上线了一个多月的服务，半夜遇到这样的问题，整个人有点懵，立刻打开电脑下载dump文件进行分析，不幸的是在分析的过程中，又连续的出现了几次崩溃，在这么反复崩溃、重启折腾了1小时左右，服务终于正常了。 分析dump下载路径：链接：https://pan.baidu.com/s/1GPzzipmxWyIr5WKNq11pIQ 提取码：6dsn 分析[11-13 20-53-03]full.dmp 使用windbg打开dmp，并加载符号文件 使用命令 .ecxr 切换到异常上下文 1234567891011121314151617181920212223242526272829303132330:061&gt; .ecxreax=00000000 ebx=dfa477a6 ecx=0000020c edx=00000000 esi=10171adc edi=dfa40000eip=77bee41b esp=08c8f51c ebp=08c8f550 iopl=0 nv up ei pl nz na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010206ntdll!RtlInitUnicodeString+0x1f3:77bee41b 8930 mov dword ptr [eax],esi ds:002b:00000000=????????0:061&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.08c8f550 77bee023 00936e28 00936e28 08c8f5b4 ntdll!RtlInitUnicodeString+0x1f3*** ERROR: Symbol file could not be found. Defaulted to export symbols for kernel32.dll - 08c8f568 774414ad 008e0000 00000000 1065fd28 ntdll!RtlFreeHeap+0x7e*** ERROR: Symbol file could not be found. Defaulted to export symbols for msvcr120.dll - 08c8f57c 70fdecfa 008e0000 00000000 1065fd28 kernel32!HeapFree+0x14*** WARNING: Unable to verify checksum for topsvr.exe08c8f590 00315e35 1065fd28 0f611df0 002cef01 msvcr120!free+0x1a08c8f5a8 00315f4a 00936e28 00000000 00000000 topsvr!redisBufferWrite+0xb508c8f5bc 003160b7 00936e28 08c8f5d0 1033f5e8 topsvr!redisGetReply+0x4a08c8f5d4 0034ae42 00936e28 0f813270 69b2eb38 topsvr!redisCommand+0x3708c8f6dc 0034ee4f 08c8f764 08c8f818 69b2ea74 topsvr!CRedisBase::RedisCommand+0x92 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\redisbase.cpp @ 217]08c8f790 0034d24a 08c8f9fc 08c8f818 69b2e5d4 topsvr!CRedisMaster::GetYQWRoomInfo+0x5f (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\redismaster.cpp @ 623]08c8f830 00378957 08c8f9fc 08c8f924 69b2e414 topsvr!CRedisMaster::GetYQWRoomInfo+0x4a (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\redismaster.cpp @ 636]08c8f9f0 0036bab4 08c8fafc 00048e0f 69b2e604 topsvr!ToPSvrThriftHandler::GetYQWRoomByNo+0xc7 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\thirdpart\thrift-0.10.0\gen-cpp\topsvrthrift_server.skeleton.cpp @ 86]08c8fbe0 0036b31f 00000000 100e3170 100e30e0 topsvr!Tcy::ToPSvr::Thrift::ToPSvrThriftProcessor::process_GetYQWRoomByNo+0x1e4 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\thirdpart\thrift-0.10.0\gen-cpp\topsvrthrift.cpp @ 1823]08c8fcec 00375429 100e3170 100e30e0 08c8fd64 topsvr!Tcy::ToPSvr::Thrift::ToPSvrThriftProcessor::dispatchCall+0x28f (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\thirdpart\thrift-0.10.0\gen-cpp\topsvrthrift.cpp @ 1742]08c8fd90 002dcf11 100e3170 0f611e08 100e30e0 topsvr!apache::thrift::TDispatchProcessor::process+0xd9 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\svn143\library\thrift-0.10.0\lib\cpp\src\thrift\tdispatchprocessor.h @ 121]08c8fe44 002cab31 0093f988 002cadde 69b2e34c topsvr!apache::thrift::server::TConnectedClient::run+0x12108c8fea8 002cf00c 69b2e334 0093fed0 0093efa8 topsvr!apache::thrift::concurrency::ThreadManager::Task::run+0x1108c8fed0 002cfcd1 0093efa8 0093fed0 69b2e2e8 topsvr!apache::thrift::concurrency::StdThread::threadMain+0x5c*** ERROR: Symbol file could not be found. Defaulted to export symbols for msvcp120.dll - 08c8ff0c 7196f33c 432a8f49 00000000 009817d8 topsvr!std::_LaunchPad&lt;std::_Bind&lt;1,void,void (__cdecl*const)(boost::shared_ptr&lt;apache::thrift::concurrency::StdThread&gt;),boost::shared_ptr&lt;apache::thrift::concurrency::StdThread&gt; &gt; &gt;::_Run+0x7108c8ff34 70ffc01d 0377f764 432a8da9 00000000 msvcp120!std::_Pad::_Release+0x6c 异常来自CRedisBase::RedisCommand,最终是kernel32!HeapFree 导致异常 使用 !analyze -v 查看错误原因 123456789101112131415SYMBOL_NAME: heap_corruption!heap_corruptionFOLLOWUP_NAME: MachineOwnerMODULE_NAME: heap_corruptionIMAGE_NAME: heap_corruptionDEBUG_FLR_IMAGE_TIMESTAMP: 0STACK_COMMAND: ~61s; .ecxr ; kbFAILURE_BUCKET_ID: HEAP_CORRUPTION_c0000005_heap_corruption!heap_corruptionBUCKET_ID: APPLICATION_FAULT_HEAP_CORRUPTION_INVALID_POINTER_WRITE_NULL_POINTER_WRITE_heap_corruption!heap_corruption 基本可以确定是 heap被破坏导致的。 heap异常对于heap异常，在溢出或被踩时是不会产生异常的，异常是在释放的时候才产生。那么如何才能让heap被破坏时就产生异常呢？ 就是通过之前介绍的 “windows的应用验证机制” 使用appverif.exe在第二天晚上蹲点，出现异常时立刻给服务开启heap检测，服务运行几分钟后又出现崩溃。 分析[11-13 21-10-08]full 开启heap检测.dmp使用windbg打开该dmp .ecxr 切换到异常上下文 1234567891011121314151617180:119&gt; .ecxr eax=22ac1000 ebx=08de9ce8 ecx=22ac1000 edx=22ac0fff esi=1c8c0fe0 edi=08de9ce0eip=00bb6e31 esp=17d7f258 ebp=17d7f2ac iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010246*** WARNING: Unable to verify checksum for topsvr.exetopsvr!Base64encode+0x1c1:00bb6e31 c60000 mov byte ptr [eax],0 ds:002b:22ac1000=??0:119&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 17d7f2ac 00bbc06e 22ac0fa8 22d3ee58 00000042 topsvr!Base64encode+0x1c1 (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\base64.cpp @ 207]17d7f50c 00bb83d1 22d3e198 22d3ed80 17d7f620 topsvr!CBillDB::MakeParam_PushPlayerInfo+0x19e (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\billdb.cpp @ 625]17d7f668 00bb8842 22d3e198 22d3e390 00000000 topsvr!CBillDB::PushBill2DB+0x351 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\billdb.cpp @ 102]17d7f718 00bec143 22d3e198 22d3e390 11588718 topsvr!CBillDB::PushBill+0xe2 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\billdb.cpp @ 154]17d7f884 00be7695 21df6fe8 22528fe0 1732cfb8 topsvr!CSockServer::OnYQWResultEx+0x4a3 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\socksvr.cpp @ 1733]17d7f91c 00c1ac94 21df6fe8 22528fe0 08de9ce8 topsvr!CSockServer::OnRequest+0x3b5 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\socksvr.cpp @ 293]17d7f944 00c1efeb 00000000 17324c40 17070c40 topsvr!CIocpWorker::DoWorkLoop+0xa417d7f95c 00c1efbb 17d7f99c 70ffc01d 08de9ce0 topsvr!CBaseWorker::WorkerThreadProc+0x2b 可以很容易看到是Base64encode导致异常 通过windbg的watch 查看入参参数，定位到原因： nikename数组只分配了128字节，但是某个玩家是156字节，导致转换溢出。 长度修改为256，服务发布后，就不再出现问题。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windbg分析内存泄漏]]></title>
    <url>%2F2019%2F05%2F07%2Fwindbg%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍本文主要介绍一种通过windbg分析内存泄漏的方法。 现象后台检测程序在某天上报了告警，大概就是某程序的提交内存达到了1.0G。登陆后台查看，该进程已经运行了90天，提交内存每天都在持续上涨，从启动到目前为止大概累计上升了800M。应该是存在内存泄漏。让运维通过工具保存了fulldump 准备工作 下载地址（提取码：11bg） 设置好系统的pdb1e:\mylocalsymbols;SRV*e:\mylocalsymbols*http://msdl.microsoft.com/download/symbols 查找堆块打印所有堆块信息1!heap -s 显示如下12345678910111213141516171819202122230:000&gt; !heap -sHEAPEXT: Unable to read ntdll!RtlpDisableHeapLookaside Heap Flags Reserv Commit Virt Free List UCR Virt Lock Fast (k) (k) (k) (k) length blocks cont. heap -----------------------------------------------------------------------------006f0000 00000002 1246976 1241928 1246976 982 236 81 0 a LFH00190000 00001002 3136 1564 3136 390 7 3 0 0 LFH External fragmentation 24 % (7 free blocks)00110000 00001002 256 4 256 1 1 1 0 0 02050000 00001002 256 176 256 1 18 1 0 0 LFH02240000 00001002 256 4 256 2 1 1 0 0 006a0000 00001002 64 12 64 4 2 1 0 0 044f0000 00001002 256 216 256 7 4 1 0 0 LFH119d0000 00001002 7424 5820 7424 134 133 4 0 c8 LFH14290000 00001003 256 4 256 2 1 1 0 bad 141d0000 00001003 256 4 256 2 1 1 0 bad 17f20000 00001003 256 4 256 2 1 1 0 bad 19030000 00001003 256 4 256 2 1 1 0 bad 191b0000 00001003 256 4 256 2 1 1 0 bad 19380000 00001003 256 4 256 2 1 1 0 bad 19300000 00001003 256 4 256 2 1 1 0 bad 155f0000 00001003 256 4 256 2 1 1 0 bad ----------------------------------------------------------------------------- 通过观察，我们知道了是006f0000堆块占用了大量内存12345HEAPEXT: Unable to read ntdll!RtlpDisableHeapLookaside Heap Flags Reserv Commit Virt Free List UCR Virt Lock Fast (k) (k) (k) (k) length blocks cont. heap -----------------------------------------------------------------------------006f0000 00000002 1246976 1241928 1246976 982 236 81 0 a LFH 查看堆块内存百分比内存持续上涨可能是某块固定大小内存被重复申请，所以统计下该堆块中各个内存大小的分配次数1!heap -stat -h 006f0000 查找堆中各个内存大小占用的百分比 123456789101112131415161718192021222324250:000&gt; !heap -stat -h 006f0000unable to resolve ntdll!RtlpStackTraceDataBase heap @ 006f0000group-by: TOTSIZE max-display: 20 size #blocks total ( %) (percent of total busy bytes) 14 23acbbe - 2c97ead8 (92.78) a4 2ba0c - 1bf2fb0 (3.63) 1000 8f5 - 8f5000 (1.16) 1a4 3b9c - 61cbf0 (0.79) 20c 15fb - 2cfdc4 (0.37) 25 b77d - 1a8511 (0.22) 64 3ba0 - 174a80 (0.19) 24 75ae - 108c78 (0.13) 11c e4a - fda18 (0.13) 84c 164 - b89b0 (0.09) 400 172 - 5c800 (0.05) 234 265 - 54684 (0.04) 1c 2c2e - 4d508 (0.04) 1c0 287 - 46c40 (0.04) c00 4b - 38400 (0.03) 20 1a12 - 34240 (0.03) 3bc ce - 30148 (0.02) 50 8da - 2c420 (0.02) 800 4c - 26000 (0.02) 2ba d2 - 23c94 (0.02) 12size #blocks total ( %) (percent of total busy bytes)14 23acbbe - 2c97ead8 (92.78) TOP 20 中显示，最多的一个大小为 0x014 的分配次数为 0x23acbbe 次， 总共大概有700M左右。基本接近内存泄漏的总数。那么我们就需要来确定这个内存是谁申请的。 定位内存来源找到了大量的内存是0x014字节大小的，但是根据这个条件我们也找不到具体的代码啊？下面是几个思路 思路1 根据大小根据内存大小（0x14）去代码中查找大小为（0x14）的类、结构体、宏等等相关代码，然后找到原因。难！！！1）、进程包含了很多其他组的dll，有的我没代码权限，无法遍历2）、结构体、类太多了，人眼遍历太难了（针对这个问题我开发了一个工具，后续章节讲解） 思路2 内存内容显示所有大小为（0x14）内存的地址，看它的地址内容有没有什么特点，比如是否有特殊的字符串、固定的二进制头？？？ 显示所有分配大小为 0x14的内存1!heap -flt s 14 12345678910111213141516171819202122232425262728290:000&gt; !heap -flt s 14 unable to resolve ntdll!RtlpStackTraceDataBase _HEAP @ 6f0000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 0071c038 0004 0000 [00] 0071c040 00014 - (busy) 0071c2e8 0004 0004 [00] 0071c2f0 00014 - (busy) 0071e498 0004 0004 [00] 0071e4a0 00014 - (busy) 0071e4f8 0004 0004 [00] 0071e500 00014 - (busy) 0071e518 0004 0004 [00] 0071e520 00014 - (busy) 0071e5f8 0004 0004 [00] 0071e600 00014 - (busy) 0071e638 0004 0004 [00] 0071e640 00014 - (busy) 0071e658 0004 0004 [00] 0071e660 00014 - (busy) 0071e798 0004 0004 [00] 0071e7a0 00014 - (busy) 007374f0 0004 0004 [00] 007374f8 00014 - (busy) 00737510 0004 0004 [00] 00737518 00014 - (busy) 00737530 0004 0004 [00] 00737538 00014 - (busy) 00737550 0004 0004 [00] 00737558 00014 - (busy) 00737570 0004 0004 [00] 00737578 00014 - (busy) 00737590 0004 0004 [00] 00737598 00014 - (busy) 007375b0 0004 0004 [00] 007375b8 00014 - (busy) 007375d0 0004 0004 [00] 007375d8 00014 - (busy) 007375f0 0004 0004 [00] 007375f8 00014 - (busy) 00737610 0004 0004 [00] 00737618 00014 - (busy) 00737630 0004 0004 [00] 00737638 00014 - (busy) 00737650 0004 0004 [00] 00737658 00014 - (busy) 00737670 0004 0004 [00] 00737678 00014 - (busy) 00737690 0004 0004 [00] 00737698 00014 - (busy) .............. .............. 随机抽查几个地址，看下地址内存 大都是这样的值，实在是看不出规律。 建议一般公司都会封装malloc、new函数，并分配一个模块号，每个内存地址头部都会携带id号，如下：1xxx_malloc(int nModleID,size_t size); 这样通过地址空间内容也可以找到分配的模块。 思路3 分配次数大小0x14的内存在90天时间内总共分配了23acbbe 次， 0x23acbbe = 37407678/(90(天)*24(小时) ≈ 17318次/小时。 这个内存几乎每小时被申请17318次。公司的服务器有个基本功能：每个小时会统计收到的消息次数，那分析下数量级在1w~3w左右的消息即可，大概是4个消息类型，然后通过代码review发现内存泄漏点123456if(total_fee)&#123; LPADD_FEE pAddFee = new ADD_FEE; ZeroMemory(pAddFee, sizeof(ADD_FEE)); pAddFee-&gt;nFee = total_fee; gdt.nTotalFee = total_fee;&#125; 结构体 ADD_FEE ,刚好是20字节1234typedef struct _tagADD_FEE&#123; int nFee; int nReserved[4];&#125;ADD_FEE, *LPADD_FEE; 完全符合！！ 问题解决 总结这个一个低级错误导致的。为了避免类视问题，引入代码静态检测1）、cppcheck2）、pclint最后选了pclint。配合jenkins，每天凌晨进行代码静态检查，并输出和上个版本的diff文件，下次就不会出现这么低级的问题。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[异常引起的死锁]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%BC%82%E5%B8%B8%E5%BC%95%E8%B5%B7%E7%9A%84%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[介绍一个json异常导致的死锁分析。同事某天求助帮忙分析一个死锁dump，按照之前查找临界区的方法，他已经具体定位到了某个线程，但是线程打印的堆栈信息却令他没有头绪。 准备工作dump下载地址（提取码：ndel） 步骤1按照之前的方法1）、~*kv 打印所有线程堆栈2）、遍历线程内容，找到可疑点3）、可疑线程为52、53、54…… 2通过查看临界区的OwningThread 找到线程 56切换到~56 线程。 3查看56线程堆栈（kv）1234567891011121314151617181920212223240:056&gt; kvChildEBP RetAddr Args to Child 08ccd8d4 76ddd846 00000000 00000000 00000000 user32!NtUserWaitMessage+0x15 (FPO: [0,0,0])08ccd910 76ddda5c 06f400d2 00000000 00000000 user32!DialogBox2+0x222 (FPO: [Non-Fpo])08ccd93c 76e0f7d0 76da0000 09f6fe90 00000000 user32!InternalDialogBox+0xe5 (FPO: [Non-Fpo])08ccd9f0 76e0faac 00012010 00000000 ffffffff user32!SoftModalMessageBox+0x757 (FPO: [Non-Fpo])08ccdb48 76e0fbaf 08ccdb54 00000028 00000000 user32!MessageBoxWorker+0x269 (FPO: [Non-Fpo])08ccdbb4 76e0fc2e 00000000 0084acf8 09ee8d38 user32!MessageBoxTimeoutW+0x52 (FPO: [Non-Fpo])08ccdbe8 76e0fd81 00000000 08ccdd84 0028f764 user32!MessageBoxTimeoutA+0x76 (FPO: [Non-Fpo])08ccdc08 76e0fdc6 00000000 08ccdd84 0028f764 user32!MessageBoxExA+0x1b (FPO: [Non-Fpo])*** WARNING: Unable to verify checksum for XYSoapClient.dll*** ERROR: Symbol file could not be found. Defaulted to export symbols for XYSoapClient.dll - 08ccdc24 0028cdd9 00000000 08ccdd84 0028f764 user32!MessageBoxA+0x18 (FPO: [Non-Fpo])WARNING: Stack unwind information not available. Following frames may be wrong.08ccde24 0028bf49 0000000a 00289e54 0028ba37 XYSoapClient!DllUnregisterServer+0x6bae08ccde5c 769a03bb 08ccdf14 9616d04a 00000000 XYSoapClient!DllUnregisterServer+0x5d1e08ccdee4 77d65be7 08ccdf14 77d65ac4 00000000 kernel32!UnhandledExceptionFilter+0x127 (FPO: [Non-Fpo])08ccdeec 77d65ac4 00000000 08ccfe1c 77d1c620 ntdll!__RtlUserThreadStart+0x62 (FPO: [SEH])08ccdf00 77d65951 00000000 00000000 00000000 ntdll!_EH4_CallFilterFunc+0x12 (FPO: [Uses EBP] [0,0,4])08ccdf28 77d53529 fffffffe 08ccfe0c 08cce064 ntdll!_except_handler4+0x8e (FPO: [Non-Fpo])08ccdf4c 77d534fb 08cce014 08ccfe0c 08cce064 ntdll!ExecuteHandler2+0x26 (FPO: [Uses EBP] [5,3,1])08ccdf70 77d5349c 08cce014 08ccfe0c 08cce064 ntdll!ExecuteHandler+0x24 (FPO: [5,0,3])08ccdffc 77d00143 01cce014 08cce064 08cce014 ntdll!RtlDispatchException+0x127 (FPO: [Non-Fpo])08ccdffc 00000000 01cce014 08cce064 08cce014 ntdll!KiUserExceptionDispatcher+0xf (FPO: [2,0,0]) (CONTEXT @ 00000008) 疑惑同事按照方法找到了导致死锁的线程，但从堆栈中却看不出原因，都是系统函数，有点无从下手。从这个堆栈信息大致猜测是该线程触发了一个异常并弹出了异常框导致线程阻塞（由于是服务模式所以看不到这个异常框），但是锁资源却没有释放，从而导致了其他线程也出现了死锁。接下来，我们需要从这个堆栈信息切换到异常发生时的堆栈信息。 切换异常上下文函数原型1KiUserExceptionDispatcher( PEXCEPTION_RECORD pExcptRec, CONTEXT * pContext ) KiUserExceptionDispatcher 的第二个参数其实就是上下文地址108ccdffc 00000000 01cce014 08cce064 08cce014 ntdll!KiUserExceptionDispatcher+0xf (FPO: [2,0,0]) (CONTEXT @ 00000008) 可以通过如下命令，切换上下文1.cxr 08cce064 最终得到的异常堆栈1234567891011121314151617181920212223240:056&gt; .cxr 08cce064 eax=08cce4c8 ebx=00792f90 ecx=00000003 edx=00000000 esi=00f3de44 edi=08cce570eip=7767c54f esp=08cce4c8 ebp=08cce518 iopl=0 nv up ei pl nz ac po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000212KERNELBASE!RaiseException+0x58:7767c54f c9 leave0:056&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 08cce518 6f799339 e06d7363 00000001 00000003 KERNELBASE!RaiseException+0x58 (FPO: [Non-Fpo])08cce558 00ee5f9b 08cce570 00f3de44 419ffac3 msvcr120!_CxxThrowException+0x5b (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]08cce5a0 00ee3852 08cce660 419ff9eb 00f1be7d gssssvr!Json::throwLogicError+0x7b08cce688 00ee42c4 00f1be7c 00f1be83 00792f88 gssssvr!Json::Value::find+0x8208cce6a0 00e1d5a5 00f1be7c 419fe277 09f03cd0 gssssvr!Json::Value::isMember+0x2408ccfd14 00e1bc40 007c5b50 09f04018 0084eb60 gssssvr!CGameServer::OnSendSysMsgToServer+0x985 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gssssvr\gssssvr\server.cpp @ 675]08ccfd44 00ed9124 007c5b50 09f04018 00792f90 gssssvr!CGameServer::OnRequest+0x90 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gssssvr\gssssvr\server.cpp @ 162]08ccfd6c 00eccf1b 00000000 045f7f30 008295e8 gssssvr!CIocpWorker::DoWorkLoop+0xa408ccfd84 00ecceeb 08ccfdc4 6f7ac01d 00792f88 gssssvr!CBaseWorker::WorkerThreadProc+0x2b08ccfd8c 6f7ac01d 00792f88 961623f0 00000000 gssssvr!CBaseWorker::WorkerThreadFunc+0xb08ccfdc4 6f7ac001 00000000 08ccfddc 7696336a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]08ccfdd0 7696336a 008295e8 08ccfe1c 77d29902 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]08ccfddc 77d29902 008295e8 ab5803ad 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])08ccfe1c 77d298d5 6f7abfb4 008295e8 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])08ccfe34 00000000 6f7abfb4 008295e8 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 这个堆栈信息就可以看清楚触发异常的具体代码，结合windbg的‘watch’‘local’功能查看变量信息，找到具体原因。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windbg分析临界区死锁]]></title>
    <url>%2F2019%2F05%2F07%2Fwindbg%E5%88%86%E6%9E%90%E4%B8%B4%E7%95%8C%E5%8C%BA%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[介绍多线程编程中，对于资源同步导致的死锁问题，应该是开发过程中经常碰到的，同时在问题定位过程中也会花费大量的时间，这里就介绍下如何通过windbg来分析死锁问题。 资源同步windows下资源同步的方法主要是 原子访问 临界区 读写锁 旋转锁 等待函数 事件 信号量 互斥量 其中最常用的应该是临界区了（性能开销小），所以我也是拿临界区作为分析对象，其他资源同步不在此讨论。 临界区保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么 在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操 作共享资源的目的。临界区包含两个操作原语：EnterCriticalSection（） 进入临界区LeaveCriticalSection（） 离开临界区EnterCriticalSection（） 语句执行后代码将进入临界区以后无论发生什么，必须确保与之匹配的 LeaveCriticalSection（）都能够被执行到。否则临界区保护的共享资源将永远不会被释放。虽然临界区同步速度很快，但却只能用来同步本 进程内的线程，而不可用来同步多个进程中的线程。 结构体定义12345678typedef struct _RTL_CRITICAL_SECTION &#123; PRTL_CRITICAL_SECTION_DEBUG DebugInfo; LONG LockCount; LONG RecursionCount; HANDLE OwningThread; HANDLE LockSemaphore; ULONG_PTR SpinCount;&#125; RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION; 各个参数的解释如下：第一个参数：PRTL_CRITICAL_SECTION_DEBUG DebugInfo;//调试用的第二个参数：LONG LockCount;//初始化为-1，n表示有n个线程在等待第三个参数：LONG RecursionCount;//表示该临界区的拥有线程对此资源获得临界区次数，初为0第四个参数：HANDLE OwningThread;//即拥有该临界区的线程句柄第五个参数：HANDLE LockSemaphore;//实际上是一个自复位事件第六个参数：DWORD SpinCount;//旋转锁的设置，单CPU下忽略 由这个结构可以知道：临界区会记录拥有该临界区的线程句柄，即临界区是有“线程所有权”概念的。事实上它会用第四个参数OwningThread来记录获准进入临界区的线程句柄，如果这个线程再次进入，EnterCriticalSection()会更新第三个参数RecursionCount以记录该线程进入的次数并立即返回让该线程进入。其它线程调用EnterCriticalSection()则会被切换到等待状态，一旦拥有线程所有权的线程调用LeaveCriticalSection()使其进入的次数为0时，系统会自动更新临界区并将等待中的线程换回可调度状态。 问题出现服务器工作线程每5s会定时上报当前还有多少消息堆积未处理，正常情况应该都是&lt;=10左右。如果出现cpu不足、io、死锁、假死等问题导致工作线程无法正常消费，那么消息堆积数量会逐渐上升。某天在告警群里面提示某服务的消息堆积从100、400、1000、3000、5000 逐渐上升，第一感觉就是服务出问题了，立刻让运维查看服务器cpu、内存、io，均正常，而且同物理主机的其他服务正常运行，所以问题应该是该服务程序出现了某些状况，可能是死锁、也可能是死循环、也可能是长时间sleep….. 立刻保存fulldump，然后重启服务，先恢复线上服务，以免给客户带来更大损失。 分析过程下载dump下载地址(提取码：33lg) 步骤1使用windbg 打开dump，并设置好pdb、操作系统pdb；使用命令 “~*kv” 显示所有线程当前的函数调用栈，效果如下（大部分省略） 123456789101112131415161718192021222324250:021&gt; ~*kv 0 Id: 173c.16d8 Suspend: 3 Teb: 7efdd000 UnfrozenChildEBP RetAddr Args to Child 0035b6b8 775514ab 000000d0 00000000 00000000 ntdll!NtWaitForSingleObject+0x15 (FPO: [3,0,0])0035b724 77441194 000000d0 ffffffff 00000000 KERNELBASE!WaitForSingleObjectEx+0x98 (FPO: [Non-Fpo])0035b73c 77441148 000000d0 ffffffff 00000000 kernel32!WaitForSingleObjectExImplementation+0x75 (FPO: [Non-Fpo])0035b750 75777be6 000000d0 ffffffff 0e9c9dd4 kernel32!WaitForSingleObject+0x12 (FPO: [Non-Fpo])0035b7f4 75778040 0070b1b8 000000d0 00000000 sechost!ScSendResponseReceiveControls+0xea (FPO: [Non-Fpo])0035b8a8 75778553 0035b8bc 00000000 00000001 sechost!ScDispatcherLoop+0xc2 (FPO: [Non-Fpo])*** WARNING: Unable to verify checksum for MatchSvr.exe0035b8c0 012432cb 0035b8cc 0035b938 012431a0 sechost!StartServiceCtrlDispatcherA+0x68 (FPO: [Non-Fpo])0035b8dc 01218689 fc7e3c0d 00000000 00000001 MatchSvr!CNTService::StartServiceA+0x2b0035f928 01253f2a 00000001 00708280 006ff620 MatchSvr!main+0x139 (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\main.cpp @ 190]0035f968 7744338a 7efde000 0035f9b4 77bf9f72 MatchSvr!__tmainCRTStartup+0xfd (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\dllstuff\crtexe.c @ 626]0035f974 77bf9f72 7efde000 85371315 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])0035f9b4 77bf9f45 01253f92 7efde000 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])0035f9cc 00000000 01253f92 7efde000 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 1 Id: 173c.290 Suspend: 3 Teb: 7ef9f000 UnfrozenChildEBP RetAddr Args to Child 02aef948 76fa7c1d 02aef9cc 00000000 00000000 user32!NtUserGetMessage+0x15 (FPO: [4,0,0])02aef968 0122d9ad 02aef9cc 00000000 00000000 user32!GetMessageA+0xa1 (FPO: [Non-Fpo])02aef9ec 0124326d 00000000 00712b08 00000000 MatchSvr!CMainService::Run+0x7d (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\service.cpp @ 65]02aefa0c 757775a8 00000001 00712b18 00000000 MatchSvr!CNTService::ServiceMain+0xcd 步骤2观察所有线程的函数调用。 这个服务并不复杂，总共只有二十几个线程（以前分析的都是至少100个线程的dump），然后重点查看服务进程的主要工作线程（是因为工作线程不工作才导致消息堆积）。 这个服务的工作线程有4个分别是10、11、12、13， 至于怎么确定的？1、看日志。良好的编码习惯，程序中的每个线程启动、退出都会在日志中记录2、对代码逻辑的熟悉 步骤3切换到其中任意一个工作线程，比如10号线程~10skv1234567891011121314151617181920212223242526272829303132330:010&gt; ~10seax=00000000 ebx=03020f70 ecx=00000000 edx=00000000 esi=7fffffff edi=ffffffffeip=77bdf8d1 esp=03bcf10c ebp=03bcf14c iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!NtWaitForSingleObject+0x15:77bdf8d1 83c404 add esp,40:010&gt; kvChildEBP RetAddr Args to Child 03bcf10c 74a06f1f 00000330 00000001 03bcf134 ntdll!NtWaitForSingleObject+0x15 (FPO: [3,0,0])03bcf14c 74a06d40 00000330 000001a4 00000001 mswsock!SockWaitForSingleObject+0x1ba (FPO: [Non-Fpo])03bcf238 75796a28 000001a5 00000000 03bcf2ec mswsock!WSPSelect+0x3a6 (FPO: [Non-Fpo])03bcf2b8 744d7787 000001a5 00000000 03bcf2ec ws2_32!select+0x494 (FPO: [Non-Fpo])WARNING: Stack unwind information not available. Following frames may be wrong.03bcf3f4 744d75f0 000001a4 00000004 ffffffff rabbitmq_4!amqp_open_socket+0x34703bcf600 744d76ca 00720ae8 000021e0 ffffffff rabbitmq_4!amqp_open_socket+0x1b003bcf620 744d9693 00720ae8 000021e0 00000000 rabbitmq_4!amqp_open_socket+0x28a03bcf638 744d7e26 0497bdc8 00720ae8 000021e0 rabbitmq_4!amqp_parse_url+0x3c303bcf650 01250550 0497bdc8 00720ae8 000021e0 rabbitmq_4!amqp_socket_open+0x1603bcf728 01250e97 fff73d65 0070b3d8 071ca950 MatchSvr!CRabbitMQ::connect+0xd003bcf840 01250870 0071ecf4 0071ecc4 03bcfa28 MatchSvr!CRabbitMQ::_publish_str_+0x18703bcf8a4 01250100 0071ecf4 0071ecc4 03bcfa28 MatchSvr!CRabbitMQ::sendmsg+0x2003bcf908 01218d48 0071ecf4 0071ecc4 03bcfa28 MatchSvr!CRabbitmqProc::sendmsg+0x2003bcf96c 01231fbc 03bcfa28 fff7382d 0070b3d8 MatchSvr!CProducerMQ::RabbitMQPublish_log+0x28 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\producermq.cpp @ 62]03bcfd08 0122eb98 071cae70 08c6c368 007022a8 MatchSvr!CSockServer::OnGameUserArenaResult+0xc3c (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\socksvr.cpp @ 1096]03bcfda4 012392e4 071cae70 08c6c368 0070b3e0 MatchSvr!CSockServer::OnRequest+0x718 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\socksvr.cpp @ 309]03bcfdcc 0123d1bb 00000000 00715868 007141b8 MatchSvr!CIocpWorker::DoWorkLoop+0xa403bcfde4 0123d18b 03bcfe24 70ffc01d 0070b3d8 MatchSvr!CBaseWorker::WorkerThreadProc+0x2b03bcfdec 70ffc01d 0070b3d8 0d15d467 00000000 MatchSvr!CBaseWorker::WorkerThreadFunc+0xb03bcfe24 70ffc001 00000000 03bcfe3c 7744338a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]03bcfe30 7744338a 007141b8 03bcfe7c 77bf9f72 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]03bcfe3c 77bf9f72 007141b8 86be14dd 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])03bcfe7c 77bf9f45 70ffbfb4 007141b8 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])03bcfe94 00000000 70ffbfb4 007141b8 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 从中，我们看到调用栈并没有什么问题，大概意思就是收到了一个GameUserArenaResult消息，然后通过mq publish出去，然后mq模块正在进行connect。感觉没有问题，接着看11号线程 ~11skv 1234567891011121314151617181920212223240:010&gt; ~11seax=00000001 ebx=00000000 ecx=00000000 edx=00000000 esi=007124f8 edi=00000000eip=77bdf8d1 esp=03ccf4cc ebp=03ccf530 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!NtWaitForSingleObject+0x15:77bdf8d1 83c404 add esp,40:011&gt; kvChildEBP RetAddr Args to Child 03ccf4cc 77bf8e44 00000e0c 00000000 00000000 ntdll!NtWaitForSingleObject+0x15 (FPO: [3,0,0])03ccf530 77bf8d28 00000000 00000000 0070b3e0 ntdll!RtlpWaitOnCriticalSection+0x13e (FPO: [Non-Fpo])03ccf558 01216e48 007124f8 0070b3d8 030c7658 ntdll!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo])03ccf5b4 0121525e 0070b3d8 030c7658 0070b3e0 MatchSvr!JMutex::Lock+0x28 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\jmutex.cpp @ 71]03ccf60c 01214b6a 007124f8 ff873359 0070b3d8 MatchSvr!JMutexAutoLock::JMutexAutoLock+0x1e (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\jmutexautolock.h @ 39]03ccf67c 01231c00 03ccf790 ff873f3d 0070b3d8 MatchSvr!CDelaySendMsg::AddMsg+0x3a (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\delaysendmsg.cpp @ 14]03ccfa18 0122eb98 05ebbe68 088d7790 00702348 MatchSvr!CSockServer::OnGameUserArenaResult+0x880 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\socksvr.cpp @ 1071]03ccfab4 012392e4 05ebbe68 088d7790 0070b3e0 MatchSvr!CSockServer::OnRequest+0x718 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\socksvr.cpp @ 309]03ccfadc 0123d1bb 00000000 00715ff8 007154a0 MatchSvr!CIocpWorker::DoWorkLoop+0xa403ccfaf4 0123d18b 03ccfb34 70ffc01d 0070b3d8 MatchSvr!CBaseWorker::WorkerThreadProc+0x2b03ccfafc 70ffc01d 0070b3d8 0d65d177 00000000 MatchSvr!CBaseWorker::WorkerThreadFunc+0xb03ccfb34 70ffc001 00000000 03ccfb4c 7744338a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]03ccfb40 7744338a 007154a0 03ccfb8c 77bf9f72 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]03ccfb4c 77bf9f72 007154a0 86ce112d 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])03ccfb8c 77bf9f45 70ffbfb4 007154a0 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])03ccfba4 00000000 70ffbfb4 007154a0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 这个堆栈就有意思了，大概就是收到了OnGameUserArenaResult消息，然后AddMsg，进入一个AutoLock，然后RtlEnterCriticalSection，看到这个说明很可能有死锁问题。我们继续观察这个临界区的具体信息103ccf558 01216e48 007124f8 0070b3d8 030c7658 ntdll!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo]) 注意其中的第三列、第四列、第五列， 分别代表了这个函数的第一个入参、第二个入参、第三个入参， 之前看过临界区的结构体，所以使用以下命令1!cs 007124f8 12345678910110:011&gt; !cs 007124f8-----------------------------------------Critical section = 0x007124f8 (+0x7124F8)DebugInfo = 0x007184b8LOCKEDLockCount = 0x2WaiterWoken = NoOwningThread = 0x00001188RecursionCount = 0x1LockSemaphore = 0xE0CSpinCount = 0x00000000 这个临界区正在被 0x00001188 的线程占用，所以导致11s线程无法进入临界区，那么我们就去 0x00001188 线程在做什么。通过线程id显示线程号命令~~[0x00001188]12340:011&gt; ~~[0x00001188] 4 Id: 173c.1188 Suspend: 3 Teb: 7ef96000 Unfrozen Start: msvcr120!_threadstartex (70ffbfb4) Priority: 0 Priority class: 32 Affinity: 3 4号线程，然后我们切换~4skv1234567891011121314151617180:004&gt; kvChildEBP RetAddr Args to Child 02fdf4b0 77bf8e44 00000dcc 00000000 00000000 ntdll!NtWaitForSingleObject+0x15 (FPO: [3,0,0])02fdf514 77bf8d28 00000000 00000000 00713298 ntdll!RtlpWaitOnCriticalSection+0x13e (FPO: [Non-Fpo])02fdf53c 01253666 00720b68 00000000 00713df0 ntdll!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo])02fdf598 0125232e 00000000 00713df0 00713298 MatchSvr!CJMutex::Lock+0x2602fdf5f0 01250d6a 00720b68 feb63229 00000000 MatchSvr!CJAutoLock::CJAutoLock+0x1e02fdf70c 01250870 0071ecf4 0071ecdc 061b729c MatchSvr!CRabbitMQ::_publish_str_+0x5a02fdf770 01250100 0071ecf4 0071ecdc 061b729c MatchSvr!CRabbitMQ::sendmsg+0x2002fdf7d4 01218d88 0071ecf4 0071ecdc 061b729c MatchSvr!CRabbitmqProc::sendmsg+0x2002fdf838 01214ccd 061b729c feb63ded 00000000 MatchSvr!CProducerMQ::RabbitMQPublish_Award+0x28 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\producermq.cpp @ 72]02fdf8c8 012172b9 00000000 00713df0 00713298 MatchSvr!CDelaySendMsg::Thread+0x11d (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\delaysendmsg.cpp @ 46]02fdf924 70ffc01d 007124a0 0c54d31f 00000000 MatchSvr!JThread::TheThread+0x39 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\jthread.cpp @ 175]02fdf95c 70ffc001 00000000 02fdf974 7744338a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]02fdf968 7744338a 00713298 02fdf9b4 77bf9f72 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]02fdf974 77bf9f72 00713298 87ff1315 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])02fdf9b4 77bf9f45 70ffbfb4 00713298 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])02fdf9cc 00000000 70ffbfb4 00713298 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 4号线程MQ正在publish一个消息，而这个消息中有一个临界区，这个临界区可能又正在被其他线程占用。 继续查看临界区12345678910110:004&gt; !cs 00720b68 -----------------------------------------Critical section = 0x00720b68 (+0x720B68)DebugInfo = 0x0071e070LOCKEDLockCount = 0x3WaiterWoken = NoOwningThread = 0x00001590RecursionCount = 0x2LockSemaphore = 0xDCCSpinCount = 0x00000000 这个临界区正在被0x00001590 线程占用，再看看这个线程号是多少~~[0x00001590]12340:004&gt; ~~[0x00001590] 10 Id: 173c.1590 Suspend: 3 Teb: 7ef81000 Unfrozen Start: msvcr120!_threadstartex (70ffbfb4) Priority: 0 Priority class: 32 Affinity: 3 ？？？？ 怎么又回到10号线程了， 再仔细看看10s线程之前我们看的时候觉的没问题，但这里肯定是有问题的，会不会’connect’ 阻塞了呢? 带着疑问查看了下消息堆积时段的日志，有MQ断开的日志。带着猜测自己重现现场试试看，在本地启动服务，然后重启mq服务，发现问题必现。解决方法就是使用非阻塞式的connect函数，问题解决。 总结这里介绍了几个windbg的常用命令，讲解了死锁的一般分析方法，对于这类问题更多的是观察、思考。希望能带给你帮助，如果觉的有用，请帮忙打赏下吧！后续还有一些有意思的dump来分享，比如内存泄漏、死锁+崩溃、踩内存、高cpu等。现在的dump素材没有以前的多了，不然我可以把很多案例都写出来，有些问题没有案例还是挺难讲的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用CMap导致服务高CPU]]></title>
    <url>%2F2019%2F05%2F07%2F%E4%BD%BF%E7%94%A8CMap%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E9%AB%98CPU%2F</url>
    <content type="text"><![CDATA[某天某服务预警一直提示某服务性能不足，cpu已满负荷。很是纳闷，这个服务是纯内存数据，没有io操作；而且都运行了快3个月了，怎么突然就性能不足了？ 步骤1半夜从睡梦中被叫醒，先自己缕一缕思路（整个人都是懵的，基本缕不出思路），先解决线上问题， 让运维保存了一份fulldump，然后重启服务，线上正常，回去睡觉。 异常出现时需要哪些现场信息，比如日志、dump、cpu、内存状态……;因为平时有积累，比如cpu、内存信息主机是有程序在定时生成的；版本（svn、pdb、exe)是自动化编译自动保存的；…… 步骤2向运维取了当时的dump文件(提取码: q5kx)，向版本服务器获取了匹配的pdb、svn记录，获取了当时的日志、cpu、内存信息。使用windbg 打开dump，发现是一个64位dump，看来运维偷懒了，没有用之前说的命令行方式获取dump，而是使用任务管理器获取dump。 步骤3加载pdb，将64位dump切换到32位，然后打印所有线程。12340:000&gt; .load wow64exts0:000&gt; !swSwitched to 32bit mode0:000:x86&gt; ~*kv 123456789101112131415161718192021222324252627282930313233 0 Id: c2c.a4c Suspend: 0 Teb: 7efdb000 Unfrozen*** ERROR: Symbol file could not be found. Defaulted to export symbols for ntdll.dll - *** ERROR: Symbol file could not be found. Defaulted to export symbols for kernel32.dll - ChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.0015f260 75dd1194 000000e4 ffffffff 00000000 ntdll_77b80000!NtWaitForSingleObject+0x150015f278 75dd1148 000000e4 ffffffff 00000000 kernel32!WaitForSingleObjectEx+0x43*** ERROR: Symbol file could not be found. Defaulted to export symbols for sechost.dll - 0015f28c 77717be6 000000e4 ffffffff e15460f0 kernel32!WaitForSingleObject+0x120015f330 77718040 0059f808 000000e4 00000000 sechost!I_ScIsSecurityProcess+0x8a70015f3e4 77718553 0015f3f8 00000000 00000001 sechost!RegisterServiceCtrlHandlerExA+0x27a*** WARNING: Unable to verify checksum for kubsvr.exe0015f3fc 001dd97b 0015f408 0015f438 001dd850 sechost!StartServiceCtrlDispatcherA+0x680015f418 001c76ad 7aed560b 0002001d 00000000 kubsvr!CNTService::StartServiceA+0x2b0015f91c 001de205 00000001 005938e0 0058cc28 kubsvr!main+0x28d (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\kubsvr\main.cpp @ 165]0015f95c 75dd338a 7efde000 0015f9a8 77bb9902 kubsvr!__tmainCRTStartup+0xfd (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\dllstuff\crtexe.c @ 626]0015f968 77bb9902 7efde000 ec718eae 00000000 kernel32!BaseThreadInitThunk+0x120015f9a8 77bb98d5 001de26d 7efde000 ffffffff ntdll_77b80000!RtlInitializeExceptionChain+0x630015f9c0 00000000 001de26d 7efde000 00000000 ntdll_77b80000!RtlInitializeExceptionChain+0x36 1 Id: c2c.dfc Suspend: 0 Teb: 7ef9d000 Unfrozen*** ERROR: Symbol file could not be found. Defaulted to export symbols for user32.dll - ChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.0265fef4 001cf23b 0265ff0c 00000000 00000000 user32!DispatchMessageW+0x5c0265ff2c 001dd91d 00000000 005a6b00 00000000 kubsvr!CMainService::Run+0x4b (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\kubsvr\service.cpp @ 68]0265ff4c 777175a8 00000001 005a6b10 00000000 kubsvr!CNTService::ServiceMain+0xcd0265ff60 75dd338a 005a6b00 0265ffac 77bb9902 sechost!I_ScIsSecurityProcess+0x2690265ff6c 77bb9902 005a6b00 ee0188aa 00000000 kernel32!BaseThreadInitThunk+0x120265ffac 77bb98d5 77717587 005a6b00 ffffffff ntdll_77b80000!RtlInitializeExceptionChain+0x630265ffc4 00000000 77717587 005a6b00 00000000 ntdll_77b80000!RtlInitializeExceptionChain+0x36................................................ 步骤4分析各个线程。从线程中可以看到总共有24个线程，其中有部分能看到代码，有部分不能看到代码。我们只能先从有代码的线程开始分析，因为这部分线程才是自己程序的主要处理模块。可以看到大多线程都在处理 CSockServer::OnPlayerLogon 函数，查看对应的代码，理了下大概逻辑：服务程序使用8个线程接收用户登陆请求，并将用户信息保存在一个全局CMap中，CMay的key是用户id，value是一个类。这个dump线程反应出来的就是当时在处理很多用户的登陆信息，没有什么异常点啊？？？？ 当时就觉的碰到坎了，认为导的dump可能不是引起cpu高时的运行栈， 后悔应该让运维多导几个dump，通过比较应该找的到高cpu时线程运行栈。暂时没辙就打开看下当时的参数信息，慢慢的就看到了CMap的大小 切换到9号线程~9s123456789101112131415160:009:x86&gt; kvChildEBP RetAddr Args to Child 0377f87c 001b3a7d 0addba3c 0377f898 0377f890 kubsvr!CMap&lt;int,int,_tagPLAYER_LOGON_MINI,_tagPLAYER_LOGON_MINI &amp;&gt;::GetAssocAt+0x61 (FPO: [Non-Fpo]) (CONV: thiscall) [c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\afxtempl.h @ 1542]0377f8a8 001bad38 0addba3c 005a1a58 200d99a8 kubsvr!CMap&lt;int,int,_tagPLAYER_LOGON_MINI,_tagPLAYER_LOGON_MINI &amp;&gt;::operator[]+0x1d (FPO: [Non-Fpo]) (CONV: thiscall) [c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\afxtempl.h @ 1589]0377f8c0 001b7a53 0addba3c 0377f8e0 798f5637 kubsvr!CMap&lt;int,int,_tagPLAYER_LOGON_MINI,_tagPLAYER_LOGON_MINI &amp;&gt;::SetAt+0x18 (FPO: [Non-Fpo]) (CONV: thiscall) [c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\afxtempl.h @ 1349]0377f920 001cfc90 1c8d1540 2008cb20 00593ee8 kubsvr!CSockServer::OnPlayerLogon+0xb3 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\kubsvr\folder.cpp @ 1602]0377f950 001d1904 1c8d1540 2008cb20 005a1a60 kubsvr!CSockServer::OnRequest+0x660 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\kubsvr\socksvr.cpp @ 166]0377f978 001d818b 00000000 005be950 005bd800 kubsvr!CIocpWorker::DoWorkLoop+0xa40377f990 001d815b 0377f9d0 7347c01d 005a1a58 kubsvr!CBaseWorker::WorkerThreadProc+0x2b0377f998 7347c01d 005a1a58 e2366994 00000000 kubsvr!CBaseWorker::WorkerThreadFunc+0xbWARNING: Stack unwind information not available. Following frames may be wrong.0377f9d0 7347c001 00000000 0377f9e8 75dd338a MSVCR120!_get_flsindex+0x6f0377f9dc 75dd338a 005bd800 0377fa28 77bb9902 MSVCR120!_get_flsindex+0x530377f9e8 77bb9902 005bd800 ef138d2e 00000000 kernel32!BaseThreadInitThunk+0x120377fa28 77bb98d5 7347bfb4 005bd800 ffffffff ntdll_77b80000!RtlInitializeExceptionChain+0x630377fa40 00000000 7347bfb4 005bd800 00000000 ntdll_77b80000!RtlInitializeExceptionChain+0x36 打开windbg菜单“view”中的“local”、“calls” 可以看到CMap的m_nCount = 0n770036,放置了大约70w用户，调用CMap.SetAt()。难道SetAt性能不好？？ 由于是前人的历史代码，我对CMap基本不熟悉，所以就抱着这个疑问写了个demo进行验证，果然，在CMap达到40w左右时，SetAt性能急剧下降，到70w左右插入可能需要10秒的时间。更换了std::map ，长期观察程序很稳定。 结论在分析高cpu时有几个操作不对的地方，1）运维没有使用命令行保存fulldump2）没有让运维多导几个fulldump3）CMap性能差真没想到，吃一堑长一智，看来都得用std::map 才行 后续的任务1）写了个工具给运维可以正确导32位进程dump2）全部门代码替换CMap为std::map]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[捕获异常并自动保存dump]]></title>
    <url>%2F2019%2F05%2F07%2F%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%B9%B6%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98dump%2F</url>
    <content type="text"><![CDATA[SetUnhandledExceptionFilter 捕获的异常有限，比如ctr异常、栈溢出的异常就无法捕获。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/************************************************************************//* 之所以应用程序捕获不到栈溢出异常，原因是因为新版本的CRT实现在异常处理中强制删除所有应用程序先前设置的捕获函数，如下所示：__crtUnhandledException()&#123;SetUnhandledExceptionFilter(NULL);UnhandledExceptionFilter(&amp;ExceptionPointers);&#125;解决方法是拦截CRT调用SetUnhandledExceptionFilter函数，使之无效。在X86平台下，可以使用以下代码 * //************************************************************************/void DisableSetUnhandledExceptionFilter()&#123; void *addr = (void*)GetProcAddress(LoadLibrary(_T("kernel32.dll")), "SetUnhandledExceptionFilter"); if (addr) &#123; unsigned char code[16]; int size = 0; code[size++] = 0x33; code[size++] = 0xC0; code[size++] = 0xC2; code[size++] = 0x04; code[size++] = 0x00; DWORD dwOldFlag, dwTempFlag; (void)VirtualProtect(addr, size, PAGE_READWRITE, &amp;dwOldFlag); (void)WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL); (void)VirtualProtect(addr, size, dwOldFlag, &amp;dwTempFlag); &#125;&#125;void WriteMiniDMP(struct _EXCEPTION_POINTERS *pExp)&#123; CString strDumpFile; TCHAR szFilePath[MAX_PATH]; GetModuleFileName(NULL, szFilePath, MAX_PATH); *strrchr(szFilePath, '\\') = 0; SYSTEMTIME stTime; GetLocalTime(&amp;stTime); // 保存fulldump &#123; strDumpFile.Format("%s\\[%02d-%02d %02d-%02d-%02d]full.dmp", szFilePath, stTime.wMonth, stTime.wDay, stTime.wHour, stTime.wMinute, stTime.wSecond); HANDLE hFile = CreateFile(strDumpFile, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile != INVALID_HANDLE_VALUE) &#123; MINIDUMP_EXCEPTION_INFORMATION ExInfo; ExInfo.ThreadId = ::GetCurrentThreadId(); ExInfo.ExceptionPointers = pExp; ExInfo.ClientPointers = NULL; // write the dump (void)MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, (MINIDUMP_TYPE)0x9b67, &amp;ExInfo, NULL, NULL); CloseHandle(hFile); &#125; &#125;&#125;LONG WINAPI ExpFilter(struct _EXCEPTION_POINTERS *pExp)&#123; static bool flag = false; if (!flag)&#123; // 防止多个线程同时写dump导致系统函数死锁 flag = true; WriteMiniDMP(pExp); flag = false; &#125; return EXCEPTION_EXECUTE_HANDLER;&#125;int main(int argc, char* argv[])&#123; ::SetUnhandledExceptionFilter(ExpFilter); //捕获crt的栈溢出异常 if ("10" != getOSName()) // win10 系统不生效 &#123; DisableSetUnhandledExceptionFilter(); &#125; ........&#125; 如上基本可以捕获大部分异常]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单分析minidump(2)]]></title>
    <url>%2F2019%2F05%2F07%2F%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90minidump-2%2F</url>
    <content type="text"><![CDATA[有了前几节的准备工作，我们的程序已经可以自动捕获异常了，那么我们开始通过windbg来分析dump解决实际问题。先从简单入手，CString大小写转化导致的异常（提取码ffk6）。 步骤1使用windbg打开minidump，设置好应用程序的pdb， 执行命令 “.ecxr” 、”kv” ,打印如下栈信息 1234567891011121314151617181920212223242526272829300:121&gt; .ecxreax=0e16eea8 ebx=00160768 ecx=00000000 edx=00000001 esi=0e16ef38 edi=0e16ef48eip=7c80bef7 esp=0e16eea4 ebp=0e16eef8 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206Unable to load image C:\WINDOWS\system32\kernel32.dll, Win32 error 0n2*** WARNING: Unable to verify timestamp for kernel32.dll*** ERROR: Module load completed but symbols could not be loaded for kernel32.dllkernel32+0xbef7:7c80bef7 ?? ???*** ERROR: Module load completed but symbols could not be loaded for mfc120.dll0:121&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.0e16eea0 1028bc8c e06d7363 00000001 00000000 kernel32+0xbef7*** WARNING: Unable to verify timestamp for msvcr120.dll*** ERROR: Module load completed but symbols could not be loaded for msvcr120.dll0e16eef8 005a9339 e06d7363 00000001 00000003 mfc120+0x28bc8c0e16ef38 101eee11 0e16ef48 1028bc8c 1029b540 msvcr120+0x193390e16ef4c 100566d4 00160760 0b139848 004a67d2 mfc120+0x1eee11*** WARNING: Unable to verify timestamp for BlockSvr.exe0e16ef8c 004dc703 0b224248 ec476e15 00000002 mfc120+0x566d40e16fea0 004c2bcf 0b139e10 0b167c20 001dfe60 BlockSvr!CSockServer::OnLogonUserV2+0x723 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\user.cpp @ 11713]0e16ff2c 005041e4 0b139e10 0b167c20 00160768 BlockSvr!CSockServer::OnRequest+0x90f (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\socksvr.cpp @ 424]0e16ff54 0050c04b 00000000 0b088970 0b2ec408 BlockSvr!CIocpWorker::DoWorkLoop+0xa40e16ff6c 0050c01b 0e16ffac 005bc01d 00160760 BlockSvr!CBaseWorker::WorkerThreadProc+0x2b0e16ff74 005bc01d 00160760 9835355e 00000000 BlockSvr!CBaseWorker::WorkerThreadFunc+0xb0e16ffac 005bc001 00000000 0e16ffec 7c82482f msvcr120+0x2c01d0e16ffb8 7c82482f 0b2ec408 00000000 00000000 msvcr120+0x2c0010e16ffec 00000000 005bbfb4 0b2ec408 00000000 kernel32+0x2482f 步骤2显示了应用程序的代码行号，但我们希望看到更仔细点，就需要加载windows的系统符号文件 1e:\mylocalsymbols;SRV*e:\mylocalsymbols*http://msdl.microsoft.com/download/symbols 步骤3设置后，重新“kv” 查看堆栈信息，显示如下 12345678910111213141516170:121&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 0e16eef8 005a9339 e06d7363 00000001 00000003 kernel32!RaiseException+0x53 (FPO: [Non-Fpo])0e16ef38 101eee11 0e16ef48 1028bc8c 1029b540 msvcr120!_CxxThrowException+0x5b (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]0e16ef4c 100566d4 00160760 0b139848 004a67d2 mfc120!AfxThrowInvalidArgException+0x19 (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\except.cpp @ 228]*** WARNING: Unable to verify timestamp for BlockSvr.exe0e16ef58 004a67d2 ec477f39 00000000 49bf1ce1 mfc120!ATL::CStringT&lt;char,StrTraitMFC_DLL&lt;char,ATL::ChTraitsCRT&lt;char&gt; &gt; &gt;::MakeLower+0x23 (FPO: [0,0,0]) (CONV: thiscall) [f:\dd\vctools\vc7libs\ship\atlmfc\include\cstringt.h @ 1796]0e16ef8c 004dc703 0b224248 ec476e15 00000002 BlockSvr!IsTempLogonToken+0x52 (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\main.cpp @ 2277]0e16fea0 004c2bcf 0b139e10 0b167c20 001dfe60 BlockSvr!CSockServer::OnLogonUserV2+0x723 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\user.cpp @ 11713]0e16ff2c 005041e4 0b139e10 0b167c20 00160768 BlockSvr!CSockServer::OnRequest+0x90f (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\socksvr.cpp @ 424]0e16ff54 0050c04b 00000000 0b088970 0b2ec408 BlockSvr!CIocpWorker::DoWorkLoop+0xa40e16ff6c 0050c01b 0e16ffac 005bc01d 00160760 BlockSvr!CBaseWorker::WorkerThreadProc+0x2b0e16ff74 005bc01d 00160760 9835355e 00000000 BlockSvr!CBaseWorker::WorkerThreadFunc+0xb0e16ffac 005bc001 00000000 0e16ffec 7c82482f msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]0e16ffb8 7c82482f 0b2ec408 00000000 00000000 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]0e16ffec 00000000 005bbfb4 0b2ec408 00000000 kernel32!BaseThreadStart+0x34 (FPO: [Non-Fpo]) 结论可以看到是由于CString 触发了_CxxThrowException。 服务从VC6版本切换到VS2013，CString 的MakeLower 函数检查变的更加严格，部分特殊用户名在VC6中正确转化，但是在vs2013中会抛出异常，将大小写转化函数替换为CharLower ，问题解决]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单分析minidump(1)]]></title>
    <url>%2F2019%2F05%2F07%2F%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90minidump-1%2F</url>
    <content type="text"><![CDATA[有了前几节的准备工作，我们的程序已经可以自动捕获异常了，那么我们开始通过windbg来分析dump解决实际问题。先从简单入手，一个index过大导致数组越界引发的崩溃。 1、使用windbg 打开dump，设置pdb、系统pdb。 2、设置完成后，执行命令”.ecxr”。 因为是程序自动截获异常，所以dump中已保存了异常的上下文，直接使用”.ecxr” 切换即可。1234560:135&gt; .ecxreax=0dea0048 ebx=0016ae18 ecx=7ff22000 edx=004b38e8 esi=0aba40b8 edi=0016ae10eip=004448cd esp=0ba9ebfc ebp=0ba9ec08 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246CheckSvr!CalcKubIndexByGameID+0x1d:004448cd ?? ??? 3、“kv”。打印异常上下文的栈信息123456789100:135&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 0ba9ec08 0040d9c4 0dea0048 af7220ac 0016ae10 CheckSvr!CalcKubIndexByGameID+0x1d (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\checksvr\main.cpp @ 1082]0ba9fcd4 0040bcb4 0db37c10 0db41a88 0aae48c0 CheckSvr!CSockServer::OnRefreshResultExFromKub+0x1ce4 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\checksvr\cmpaqpro.cpp @ 1081]0ba9feb4 0045ca88 0db37c10 0db41a88 0aae48c0 CheckSvr!CSockServer::OnRefreshResultEx+0x134 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\checksvr\cmpaqpro.cpp @ 419]0ba9ff2c 00477674 0db37c10 0db41a88 0016ae18 CheckSvr!CSockServer::OnRequest+0xd38 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\checksvr\socksvr.cpp @ 1931]0ba9ff54 0047e7db 00000000 0aae5e68 0a9c23a0 CheckSvr!CIocpWorker::DoWorkLoop+0xa40ba9ff6c 0047e7ab 0ba9ffac 0050c01d 0016ae10 CheckSvr!CBaseWorker::WorkerThreadProc+0x2b0ba9ff74 0050c01d 0016ae10 876c3023 00000000 CheckSvr!CBaseWorker::WorkerThreadFunc+0xb 4、异常函数为CalcKubIndexByGameID， 入参的值为0dea0048。 回到代码查看CalcKubIndexByGameID的实现， 1234int CalcKubIndexByGameID(int nGameID )&#123; return g_kub[nGameID];&#125; 明显nGameID 过大导致访问数组越界。 然后排查代码，发现nGameID未使用默认值，某些条件下使用了随机值导致。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何错过异常第一现场找到异常上下文]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%A6%82%E4%BD%95%E9%94%99%E8%BF%87%E5%BC%82%E5%B8%B8%E7%AC%AC%E4%B8%80%E7%8E%B0%E5%9C%BA%E6%89%BE%E5%88%B0%E5%BC%82%E5%B8%B8%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
    <content type="text"><![CDATA[介绍前面的章节都在讲解通过SetUnhandledExceptionFilter 设置程序自动捕获异常dump，这类dump通过.ecxr 命令或者 !analyze -v 就可以找到异常，但是在有些情况下（比如别人的项目），没有自动保存异常dump时应该怎么分析呢？ 现象某个新项目在测试环境出现了异常，弹出了一个异常框，这是windows下比较常见的异常框，是因为程序遇到了异常，但是没有设置用户自定异常处理函数，从而触发了windows默认异常处理函数“弹出一个异常提示框”。这种情况下：1、不要关闭对话框。使用windbg attach 到该异常程序2、通过命令 .dump /ma d:\xx.dmp 保存fulldump分析方法通过windbg打开xx.dmp,加载系统符号文件。输入命令1~*er?$t1=((ntdll!_NT_TIB*)@$teb)-&gt;StackLimit;r?$t2=((ntdll!_NT_TIB*)@$teb)-&gt;StackBase;!teb;dps@$t1@$t2 这个命令是打印所有线程的调用栈，通过查找“KiUserExceptionDispatcher”来找到异常上下文。 注意：因为如上命令会打印很多信息，所以windbg ui界面是无法显示的，好的办法是将输出都保存到日志文件中, windbg-&gt;”edit”-&gt;”open/close log file”。1在输出的log文件中查找&quot;KiUserExceptionDispatcher&quot;,如下 123456789101112044bed64 044ba000044bed68 00000000044bed6c 044bf288044bed70 77a70133 ntdll!KiUserExceptionDispatcher+0xf044bed74 014bed84044bed78 [044bedd4]044bed7c 044bed84044bed80 044bedd4044bed84 e06d7363044bed88 00000001044bed8c 00000000044bed90 769cc42d KERNELBASE!RaiseException+0x58 注意其中“[]”的内容，这个地址就是异常上下文地址，最后通过命令.cxr 044bedd4 kv 就可以找到异常点。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windbg分析准备工作]]></title>
    <url>%2F2019%2F05%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[1、可以上网的电脑。用于下载系统符号文件，没有也没有太大关系。 2、应用程序关闭优化。 关闭优化是方便通过windbg查找内存数据的准确性； 3、匹配的应用程序/dll 的pdb文件。有匹配的pdb才可以找到对应的代码行数、内存参数。很重要 4、windbg软件，32位 下载 5、设置系统符号文件路径。 1e:\mylocalsymbols;SRV*e:\mylocalsymbols*http://msdl.microsoft.com/download/symbols 6、设置应用符号文件路径 PS： win10 的windows商店有款 windbg priview 更加推荐。 下一节如何保存dump。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 开始]]></title>
    <url>%2F2016%2F05%2F09%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AF%BC%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[读书笔记其实就是将自己看过的一些书，将其中有感触的东西记下来。16年前也经常看一些书，但我总感觉自己记忆力太差，看完之后过段时间几乎都想不起来，就和没看过一样，所以希望能够做一些笔记，提醒自己曾经看过。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
</search>
