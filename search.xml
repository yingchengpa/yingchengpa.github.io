<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[windows dll注入修改函数]]></title>
    <url>%2F2020%2F06%2F04%2Fwindows-dll%E6%B3%A8%E5%85%A5%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[背景之前分析windows异常捕获时接触到一个hook api 重定向了SetUnhandledExceptionFilter函数，当时并不熟悉，现在刚好抽点时间可以研究下，并自己手动实现了一个远程dll注入，并修改指定exe函数的实现。 效果 hooktest.exe 里面的某个函数被修改为其他函数实现，如下是hooktest的源码 123456789101112131415void testOutPut()&#123; printf(&quot;%s\n&quot;,&quot;hook test&quot;);&#125;int main()&#123; while (1) &#123; char a; std::cin &gt;&gt; a; testOutPut(); &#125; return 0;&#125; 当输入键盘任意按钮时，输出”hook test”,但是当我注入dll后，按下按键输出”dealHookFunc succ”,效果如下12345678ahook testhook inadealHookFunc succhook outahook test 过程因为是远程注入，需要一个load.exe(loaddll.exe) 、一个 hook.dll(xxxx.dll)、一个被注入程序hooktest.exe 三个项目的源码如下 loaddll.exe该程序主要功能主要是注入xxxx.dll 到指定目标中 找到指定exe的pid 判断是否有重复注入 打开目标进程 获取LoadLibrary地址 CreateRemoteThread 动态加载xxxx.dll xxxx.dll 触发dllmain DLL_PROCESS_ATTACH 时，修改进程的内存机器码 DLL_PROCESS_DETACH 时，还原进程的机器码 testOutPut 函数地址 通过 ida 工具分析hooktest.exe 的信息，很容易找到testOutPut 函数的偏移地址为 0x80 修改汇编代码12345678 hooktest!testOutPut:00cf1080 55 push ebp00cf1081 8bec mov ebp, esp00cf1083 681831cf00 push offset hooktest!GS_ExceptionPointers+0x8 (00cf3118)00cf1088 682431cf00 push offset hooktest!GS_ExceptionPointers+0x14 (00cf3124)00cf108d e8aeffffff call hooktest!printf (00cf1040)00cf1092 83c408 add esp, 800cf1095 5d pop ebp 因为是无条件跳转，所以只要把 00cf1080 开始之后的地址修改为12jmp 目标地址 // 5个字节rent // 1个字节 1234567BYTE hookCode[32] = &#123; 0 &#125;; hookCode[nsize++] = 0xE9; // // 0xE9 0x12345678 : jmp 0x12345678 5个字节 *(DWORD*)&amp;hookCode[nsize++] = (DWORD)dealHookFunc - hookAddress - 5; // 5个字节偏移 jmp call 都是相对地址 nsize++; nsize++; nsize++; hookCode[nsize++] = 0xC3; // 0xC3 retn 修改后的汇编代码1234567891011 hooktest!testOutPut:00cf1080 e9fbff7c54 jmp xxxx!dealHookFunc (554c1080)00cf1085 c3 ret 00cf1086 cf iretd 00cf1087 006824 add byte ptr [eax+24h], ch00cf108a 31cf xor edi, ecx00cf108c 00e8 add al, ch00cf108e ae scas byte ptr es:[edi]00cf108f ff ??? 00cf1090 ff ??? 00cf1091 ff83c4085dc3 inc dword ptr [ebx-3CA2F73Ch] 跳转地址jmp指令所指向的地址是个相对地址，所以真实的目标地址为1hook函数的地址 - 被hook函数的地址 - 5 ; // 5是指指令（jmp 0x12345678）的长度 被hook函数地址1模块基础地址 + virtual address + 偏移地址 修改内存内容123456789101112131415161718192021DWORD baseAddress = (DWORD)GetModuleHandle(NULL); DWORD hookAddress = baseAddress + OUTPUT_FUNC_ADDR_OFFSET; //jmp 0x12345678 //retn // 如上共6个字节 BYTE hookCode[32] = &#123; 0 &#125;; hookCode[nsize++] = 0xE9; // // 0xE9 0x12345678 : jmp 0x12345678 5个字节 *(DWORD*)&amp;hookCode[nsize++] = (DWORD)dealHookFunc - hookAddress - 5; // 5个字节偏移 jmp call 都是相对地址 nsize++; nsize++; nsize++; hookCode[nsize++] = 0xC3; // 0xC3 retn BOOL bRet = ReadProcessMemory(GetCurrentProcess(), (LPVOID)hookAddress, oldCode, nsize, 0); DWORD dwOldFlag, dwTempFlag; (void)VirtualProtect((void*)hookAddress, nsize, PAGE_READWRITE, &amp;dwOldFlag); bRet = WriteProcessMemory(GetCurrentProcess(), (LPVOID)hookAddress, hookCode, nsize, 0); (void)VirtualProtect((void*)hookAddress, nsize, dwOldFlag, &amp;dwTempFlag); 总结这个程序只是简单的说明，希望对你有帮助。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[洛阳游]]></title>
    <url>%2F2020%2F06%2F03%2F%E6%B4%9B%E9%98%B3%E6%B8%B8%2F</url>
    <content type="text"><![CDATA[时间2016年10月 去过很多历史古城，却没去过洛阳，所以决定国庆节时和朋友一起去一趟洛阳。朋友圈里喊了，有个朋友可以一起去，于是约好分别从杭州、湖州做火车出发，然后在洛阳汇合。 过程途中我的内心是非常兴奋的，洛阳作为十三朝古都，可玩的历史古迹是相当的多，主要玩了一下几个地方 古墓博物馆 白马寺 龙门石窟 天堂明堂 洛阳博物馆 总结相当不错，特别是和有相同兴趣的朋友一起，那真的很惬意。 可惜朋友最近也结婚了，以后能够一起长途玩估计也没机会了。]]></content>
      <categories>
        <category>走走看看</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于opencv的C++走迷宫]]></title>
    <url>%2F2020%2F06%2F02%2F%E5%9F%BA%E4%BA%8Eopencv%E7%9A%84C-%E8%B5%B0%E8%BF%B7%E5%AE%AB%2F</url>
    <content type="text"><![CDATA[背景同事在朋友圈贴了一个迷宫的图，看看能否用程序实现，觉的有趣就试了试。 效果 方法 使用opencv对图像进行二值化 使用bfs算法进行路径搜索 对路径进行回溯，并显示路径 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220// ConsoleApplication1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。//#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;queue&gt;#include &lt;opencv2/opencv.hpp&gt;#define GRAY_COLOR 240struct Node &#123; int x = 0; int y = 0; bool operator == (Node&amp; right) &#123; if (this-&gt;x == right.x &amp;&amp; this-&gt;y == right.y) &#123; return true; &#125; return false; &#125;&#125;;//设置访问过的颜色void setVisit(Node node, cv::Mat&amp; imgSrc)&#123; imgSrc.at&lt;uchar&gt;(node.y, node.x) = GRAY_COLOR;&#125;//设置步数void SetStep(Node node,std::vector&lt;std::vector&lt;int&gt; &gt; &amp;oFullStep, int nStep)&#123; oFullStep[node.x][node.y] = nStep;&#125;bool isValid(Node node, cv::Mat&amp; imgSrc)&#123; if (node.x &lt; 0 || node.y &lt; 50 ) // 设置不能比起点更小的y值。 原图应该先处理，避免跑到圆圈外面，我通过坐标来限制 &#123; return false; &#125; if (node.x &gt;= imgSrc.cols || node.y &gt;= imgSrc.rows) &#123; return false; &#125; if (int(imgSrc.at&lt;uchar&gt;(node.y, node.x)) &gt; 0) &#123; return false; &#125; return true;&#125;bool isVisit(Node node, cv::Mat&amp; imgSrc)&#123; if (int(imgSrc.at&lt;uchar&gt;(node.y, node.x)) == GRAY_COLOR) &#123; return true; &#125; return false;&#125;bool pushNode(Node Vw, Node Vd, std::queue&lt;Node&gt;&amp; Q, cv::Mat&amp; imgSrc,std::vector&lt;std::vector&lt;int&gt; &gt; &amp;oFullPath,int nStep)&#123; if (Vw == Vd) &#123;//找到终点了！ setVisit(Vw, imgSrc); SetStep(Vw, oFullPath, nStep); return true;//返回 &#125; if (isValid(Vw, imgSrc) &amp;&amp; !isVisit(Vw, imgSrc)) &#123; //Vw是一个合法的节点并且为白色节点 Q.push(Vw);//加入队列Q setVisit(Vw, imgSrc);//设置节点颜色 SetStep(Vw, oFullPath, nStep); &#125; return false;&#125;// Vs 开始，Vd 结束bool BFS(Node &amp;Vs,Node &amp;Vd, cv::Mat&amp; imgSrc,std::vector&lt;std::vector&lt;int&gt; &gt; &amp;oFullPath)&#123; std::queue&lt;Node&gt; Q; Node Vn, Vw; //初始状态将起点放进队列Q Q.push(Vs); setVisit(Vs, imgSrc); SetStep(Vs, oFullPath, 1); while (!Q.empty()) &#123;//队列不为空，继续搜索！ //取出队列的头Vn Vn = Q.front(); int nStep = oFullPath[Vn.x][Vn.y]; //从队列中移除 Q.pop(); // 四个方向查找 Vw.x = Vn.x; Vw.y = Vn.y - 1; //对搜索过的路径进行颜色修改为240，并记录步数 if (pushNode(Vw, Vd, Q, imgSrc, oFullPath,nStep + 1)) &#123; return true; &#125; Vw.x = Vn.x; Vw.y = Vn.y + 1; if (pushNode(Vw, Vd, Q, imgSrc, oFullPath, nStep + 1)) &#123; return true; &#125; Vw.x = Vn.x - 1; Vw.y = Vn.y ; if (pushNode(Vw, Vd, Q, imgSrc, oFullPath, nStep + 1)) &#123; return true; &#125; Vw.x = Vn.x + 1; Vw.y = Vn.y ; if (pushNode(Vw, Vd, Q, imgSrc, oFullPath, nStep + 1)) &#123; return true; &#125; &#125; return false;//无解 &#125;//从终点开始回溯，开始对上下左右四个方向进行step 比较void findPath(Node Ve,const std::vector&lt;std::vector&lt;int&gt; &gt; &amp;oFullStep,std::vector&lt;Node&gt; &amp;oPath)&#123; int nStep = oFullStep[Ve.x][Ve.y]; Node Vn = Ve; while (nStep != 0) &#123; Node Vw; Vw.x = Vn.x; Vw.y = Vn.y - 1; nStep = oFullStep[Vn.x][Vn.y]; if (oFullStep[Vw.x][Vw.y] == (nStep - 1)) &#123; Vn = Vw; oPath.push_back(Vn); continue; &#125; Vw.x = Vn.x; Vw.y = Vn.y + 1; if (oFullStep[Vw.x][Vw.y] == (nStep - 1)) &#123; Vn = Vw; oPath.push_back(Vn); continue; &#125; Vw.x = Vn.x-1; Vw.y = Vn.y ; if (oFullStep[Vw.x][Vw.y] == (nStep - 1)) &#123; Vn = Vw; oPath.push_back(Vn); continue; &#125; Vw.x = Vn.x+1; Vw.y = Vn.y ; if (oFullStep[Vw.x][Vw.y] == (nStep - 1)) &#123; Vn = Vw; oPath.push_back(Vn); continue; &#125; &#125;&#125;int main(int argc, TCHAR* argv[], TCHAR* envp[])&#123; Node Vs, Vd; //设置起点 ，通过ps工具找到起点像素 Vs.x = 505; Vs.y = 50; //设置终点 ，通过ps工具找到终点点像素 Vd.x = 570; Vd.y = 1115; std::vector&lt;std::vector&lt;int&gt; &gt; oFullPath; //记录搜索的步数 std::vector&lt;Node&gt; oStepVec; cv::Mat image = cv::imread(&quot;e:\\迷宫图片.jpg&quot;, cv::IMREAD_GRAYSCALE); cv::Mat outImage; cv::threshold(image, outImage, 180, 255, cv::THRESH_BINARY_INV); // 对图片进行二值化， &quot;180&quot;是测试出来的 oFullPath.resize(outImage.cols); for (auto&amp; value : oFullPath) value.resize(outImage.rows); bool bRet = BFS(Vs, Vd, outImage,oFullPath); // 进行BFS 搜索 findPath(Vd,oFullPath, oStepVec); // 对路径进行回溯 // 设置路径的颜色为黑色 for (auto&amp; value : oStepVec) &#123; outImage.at&lt;uchar&gt;(value.y, value.x) = 0; &#125; cv::imshow(&quot;hello&quot;, outImage); cv::waitKey(0); // 等待用户按下键盘 cv::destroyWindow(&quot;hello&quot;); // 销毁窗口 &quot;hello&quot; return 0;&#125;]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hashmap 性能对比]]></title>
    <url>%2F2020%2F06%2F01%2Fhashmap-%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[背景对比下 stl、google等hashmap的性能，国外有人有更好的数据 链接链接 部分截图]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tesseract 使用]]></title>
    <url>%2F2020%2F05%2F26%2Ftesseract-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[背景用于图片识别 安装安装方式 里面介绍了windows、linux下安装方法，很简单 只要选择最新版本安装即可。 运行命令行中执行1tesseract /home/ocrjpg/Snipaste_2020-03-17_09-08-27.jpg stdout 在命令行中输出结果。更多命令查看1tesseract --help-extra 语言包默认只有英语，需要下载对应的语言包 语言包 其中： chi_sim.traineddata 为中文简体 测试如果你觉的麻烦，那就直接在这里测试 训练未研究]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[std_system_error_deallocate_message@4]]></title>
    <url>%2F2020%2F05%2F25%2Ftd-system-error-deallocate-message-4%2F</url>
    <content type="text"><![CDATA[背景使用vs2019 16.6.0 版本本地编译了 log4cplus.lib 静态库，然后更新到jenkins编译环境，当使用jenkins编译应用程序时，提示 123log4cplus.lib(global-init.obj) : error LNK2001: 无法解析的外部符号 ___std_system_error_deallocate_message@4 [D:\Jenkins\workspace\GameChannel2019.git\ClockSvr\ClockSvr.vcxproj] log4cplus.lib(global-init.obj) : error LNK2001: 无法解析的外部符号 ___std_system_error_allocate_message@8 [D:\Jenkins\workspace\GameChannel2019.git\ClockSvr\ClockSvr.vcxproj] 解决方法已”std_system_error_deallocate_message”关键字查找了google ，结果记录为2，打开网站，显示的是github ms stl的源码1https://github.com/microsoft/STL/blob/master/stl/src/syserror_import_lib.cpp 查看修改记录，估摸应该是新版本有更新，所以原因应该是我本地的vs2019版本依赖了新的stl库，而jenkisn的vs2019 版本过旧，所以升级了jenkin的vs2019版本，编译正常。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[幾千萬人失業，為什麽美股卻依然漲個不停？]]></title>
    <url>%2F2020%2F05%2F13%2F%E5%B9%BE%E5%8D%83%E8%90%AC%E4%BA%BA%E5%A4%B1%E6%A5%AD%EF%BC%8C%E7%82%BA%E4%BB%80%E9%BA%BD%E7%BE%8E%E8%82%A1%E5%8D%BB%E4%BE%9D%E7%84%B6%E6%BC%B2%E5%80%8B%E4%B8%8D%E5%81%9C%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[时间2020年5月11日 观点美股Google,Apple,Facebook,Amazon和Microsoft為什麽會飆漲？幾千萬人失業，為什麽美股卻依然漲個不停？ 链接链接：https://pan.baidu.com/s/1KzFIiFBomw7SHWcNNhrZjQ 提取码：vb4d 笔记 市场玩的猜谜游戏，猜的是预期差，是很难猜的 短期玩预期差是很难的，费事费力，而且很容易猜错 他的做法是看一个更长期的趋势 这次美股上涨，是大量的流动性流入了股市，因为没地方可以去了 这么多流动性，会去买什么股票呢？ 电力？汽车？银行？奢侈品？房地产？ 大家普遍认为传统行业不容乐观 但是 游戏、电商、云计算、视频 大家普遍觉得需求会大增 所以在流动性大量流入，但普遍都选择了未来可能更有前景得行业和公司，导致5大科技股大涨 作者观点：人多的地方不要去，容易发生踩踏，会留一部分资金出来等待市场表演，等待合适机会再买入5大科技股]]></content>
      <categories>
        <category>刘翔投资</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自动登陆并获取订单信息]]></title>
    <url>%2F2020%2F05%2F12%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E7%99%BB%E9%99%86%E5%B9%B6%E8%8E%B7%E5%8F%96%E8%AE%A2%E5%8D%95%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[背景朋友做的是集成商的生意，他碰到一个问题希望我能解决下，提升一下他的工作效率。 朋友接了一个小区xx改造订单，这个订单的原件都从A公司采购，由于原件很多，所以在A公司里面就会有很多订单号，里面有一些关键信息，比如”价格”,也有一些不敏感信息比如”快递信息”等等。朋友碰到两个问题： 不需要自己的员工查看到敏感信息，但又必须让他们知道快递等一些信息 。 1现在比较简单，就是通过中间“商务”这个人来做，工作就很繁杂 小区xx改造完工时，该订单对账太繁琐，毛利等利润计算工作巨大 朋友的想法，是希望能够把A公司的订单信息能够自动纳入到他们的数据库中，这样朋友只要维护好xx小区的订单号下面涉及哪些A公司订单就可以了， 剩下的就简单很多了。 方案一开始想法，就是A公司能否提供一个开放api接口给朋友调用，那么就可以获取到订单信息了，但A公司没有这个功能。 那剩下的想法就是爬虫了。 试试看 分析过程大概估计了一下会遇到的困难 自动填充数据 自动填充校验码 爬虫订单数据 爬虫订单数据通过chrome的页面调试功能，抓包分析了页面的一些结构和https请求，获取订单信息API包含如下三个关键信息 url （已知） cookies post body （已知） 并分析了他们页面登陆时密码的机密规则： 公钥+密码+校验码， 本想能否跳过自动登陆，直接获取订单信息看来是不行了。 cookies我使用的chrome 81.x的，所以主要是已这个版本举例。 使用sqllite 工具打开cookies文件 “%LOCALAPPDATA%\Google\Chrome\User Data\Default” 里面是加密的 查询资料 “http://www.secwk.com/2020/03/09/16685/&quot; ,了解加密规则 资料中提供的demo 可以解密出cookies的值 爬虫部分基本解决了，只要能够登陆成功，我就可以通过工具获取cookies，然后通过构造api请求正确的订单数据 自动填充校验码 资料链接：https://juejin.im/post/5d9068f66fb9a04e22331ace A公司的验证码不复杂，难度也不大，只要能获取到图片就能识别出数字。 自己搭了一个测试页面，上传图片就可以识别。 测试链接 自动填充数据本来是想用libcef 自己写一个类似的web客户端，发现cookies获取成本太高；接着查询资料使用 selenium 来实现，开发语言用python。 1注意：请选择安装正确版本的chrome driver，并将chromedriver.exe 的路径设置到 环境变量PATH中。 随着分析的深入，发现A公司的验证码其实不是一张图片，而是通过api向服务器获取返回一个字符串，其实就是不需要验证码识别的，只要获取element并填回去就好了。 12345# 设置校验码txtOCR = driver.find_element(By.ID,&apos;ocr&apos;).get_attribute(&apos;value&apos;)inputOCR = driver.find_element(By.ID,&apos;code&apos;)inputOCR.send_keys(txtOCR) selenium 还可以获取当前域解密后的cookies，那整体比我原来想象的简单多了。 所以最后的代码就是这样：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# -*- coding: UTF-8 -*-import timeimport requestsimport jsonfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support.ui import WebDriverWaitfrom selenium.webdriver.support.expected_conditions import presence_of_element_locateddriver = webdriver.Chrome()# Navigate to urldriver.get(&quot;https://xxxxx.com/&quot;)# 选择账号密码登陆btnloginbyuserid = driver.find_element(By.CLASS_NAME,&apos;userId&apos;)btnloginbyuserid.click()# 设置账号、密码txtUser = driver.find_element(By.ID,&apos;userID&apos;)txtpwd = driver.find_element(By.ID,&apos;Pwd&apos;)txtUser.send_keys(&apos;xxx&apos;)txtpwd.send_keys(&apos;ppp&apos;)# 设置校验码txtOCR = driver.find_element(By.ID,&apos;ocr&apos;).get_attribute(&apos;value&apos;)inputOCR = driver.find_element(By.ID,&apos;code&apos;)inputOCR.send_keys(txtOCR)# 点击登陆btnLogon = driver.find_element(By.ID,&apos;btn_login&apos;)btnLogon.click()# 等待10stime.sleep( 10 )# Get all available cookiesprint driver.get_cookies()# 构造 api消息postheaders=&#123;&apos;Cookie&apos;: &apos;sui bian xie de&apos;&#125;postdata=&#123;&apos;begin&apos;:&apos;2019-02-11&apos;,&apos;end&apos;:&apos;2019-05-11&apos;&#125;r = requests.post(&apos;https://xxxxx.com/Getlist&apos;, headers=postheaders, data=postdata)# 请求失败if r.status_code == 200: print(r.text)else: print(&apos;error&apos;) # 数据入自己的库#...... # 退出driver.quit()]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何给股票来估值？怎么判断一个股票到底是贵还是便宜？]]></title>
    <url>%2F2020%2F05%2F08%2F%E5%A6%82%E4%BD%95%E7%BB%99%E8%82%A1%E7%A5%A8%E6%9D%A5%E4%BC%B0%E5%80%BC%EF%BC%9F%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E8%82%A1%E7%A5%A8%E5%88%B0%E5%BA%95%E6%98%AF%E8%B4%B5%E8%BF%98%E6%98%AF%E4%BE%BF%E5%AE%9C%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[时间2020年1月8日 观点如何给股票来估值？怎么判断一个股票到底是贵还是便宜？ 链接链接：https://pan.baidu.com/s/1xafrdK19s0SAieQKGDdoMQ 提取码：w53v 笔记有的股票已经涨了几十倍了，这个股票是不是太贵呢？还能买吗？有的股票跌了50%也不代表便宜了。 股价再过去涨了多少，跌了多少，股票未来的走势其实没有什么直接的关系，你会发现，往往是很多涨了很多的股票它却依然能够上涨，跌了很多的股票会继续跌。 几种估值的方法和适用场景 PE（市盈率）PE其实是过去的数据，但做投资看的是未来。举例：市场预测市值100亿的公司2020年会赚20亿，PE=5，但财报出来结果只赚了10亿，那么PE=10，那么股价就会大跌，因为没有达到市场的预测值；另一种情况如果赚了25亿，那么估计就会涨，因为超过了市场预期。 经常会出现这样情况，一个公司财报看上去很不错，结果股价却大跌了；有的公司财报看去很一般，结果却大涨。 市场对公司的市场预期可以通过yahoo finance 查到卖方（投行）的预测值，买方（基金公司）可能会不一样。 估值看的是未来，所以过去的PE只能作为参考。 简单的方法来判断一个公司的PE是否合理：123增速*2+[10~20] [10~20] 按银行利率水平，简单就按平均15计算比如未来10年的增速是10%，那么PE=10*2+15 = 35 总结：对一个公司进行估值就是预测它的未来，而这个就需要对行业和公司的深刻理解了。 PEGPEG=PE/成长性。 举例：某公司PE=20，未来三年的增速为20%（每年），那么PEG=20/20 = 1 PEG&gt;1 说明高估 PEG=1 说明合理 PEG&lt;1 说明低估 局限性：主要用在盈利能力比较稳定增涨的成长股上面，如果是周期性行业的话，业绩起伏比较大，不太适合。 如果是成长股，还是用PE里面的公式判断，会更加科学一些。 PB（市净率）PB=股价/每股净资产 对于制造业和银行，PB低，如果跌破1的话，说明这个股票是相对安全的，它下跌的风险不是很大。特别对于银行股，有滞后性不能用PE来估值，用PB比较合适。 不适用的领域： 轻资产公司，比如科技性公司，这些公司更适合用PE、PS来估值 ROE（净资产收益率）反映公司的赚钱能力。巴菲特说过，他选公司都要选ROE&gt;20的公司。 但是历史上常年ROE&gt;20的就一定是牛股吗？不一定，比如东**胶。 投资比的是你对行业和公司的理解的深度。 简单总结： ROE&gt;20的公司就值得深入得研究一下，这里面出大牛股的概率是比较大的； 任何的指标你都不可以迷信它；你要分析ROE&gt;20的模式未来能否持续 PS（市销率）PS=市值/主营业务收入 主要用在没用盈利的公司上面，主要用来给创业型或者高科技型的公司进行估值的]]></content>
      <categories>
        <category>刘翔投资</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[个人经验总结]]></title>
    <url>%2F2020%2F04%2F29%2F%E4%B8%AA%E4%BA%BA%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[背景公司进行大裁员有50%的员工离职。 感想看着这些一起共事的同事离开，内心非常难受，更愤怒的是连一些优秀的主程也因为团队整体被裁而不得以离开， 我几乎帮不了什么忙，我就说说一些自己作为面试官的一些经验和工作时的一些感受吧，可能对他们有那么一丢丢帮助。 面试作为公司技术面试官，我想谈谈以我的角度是如何看待面试者的。 笔试题我喜欢编码的题目，不喜欢选择题。笔试题一般考查时间复杂度、编码规范、注释、异常保护，有的人代码给人一看耳目一新，你可以在短短几秒钟就理解他的主要思路；有的人结果是正确的，但代码看起来很费脑…… 总体来说，笔试就是入门坎，只有够到基本线了，就可以了我是不会作为关键评价的。 一面每个公司都有一个结构化面试题库，比如多线程相关、数据结构相关、数据库、编码技巧等等。我一般在聊项目经历时会抽查问，单独的问题这些技术问题我发现有的知识点我自己都不怎么深入，结果对方却答的比我还优秀。 项目经验我喜欢聊他曾经印象最深的项目经历，我会深入的和他探讨，比如画下架构图，你在项目中的角色，我会站在我的角度问一些可能涉及到的问题，并咨询他是如何处理的。这样的沟通中，我可以了解到 表达能力。程序员的沟通方式却无法将项目沟通清楚，说明表达能力是有待提高的。 项目投入度。 有的人会把公司重大项目，但自己只是简单的参与者，而说成是自己的大项目来提升自己的能力 参与能力。 在项目中你是简单的执行者，还是一个参与者。如果是你参与者，那么你会在本职工作之外发现项目隐藏的更多问题，并解决它。 技术能力。其中会咨询一些技术细节，看他实际掌握的能力。 合作能力。 团队的沟通、协作能力是否正常 1聊项目经历的目的，我主要是想了解他在项目中参与能力，如果你是一个合格的员工，那么在做一个项目时，你至少能够回答：这个项目的意义？项目的整体设计？项目中你的角色？项目中你发挥了多大的作用？你是否能发挥更大的作用？ 主动思考能力我一般会问，你觉的目前这个项目中有哪些值得改进的地方（如果项目时间足够的话）。 这个问题主要想了解面试者主动思考的能力。我们在做项目中总会遇到很多不顺心的设计，比如出版本特别耗时？请问你怎么改进，你有改进的想法吗？并付之于行动吗？你的改进效果如何？1我更喜欢这些能够主动思考的员工，他们的技术能力并不是最出色的，但他们却能够创造出更多的价值。 学习能力我会问，如果遇到一个未接触过的技术，请问你的学习过程是怎么样的？这个我完全就是看他怎么说1在压力情况下，如何快速的有效学习。 解决问题能力我会问，你印象最深刻的bug是怎么解决的？1如何快速有效的解决bug，是你核心的竞争力 基本上就这些了 工作这里我想谈谈工作的一些感想，你如何在公司脱颖而出： 找到工作痛点，并解决他 1你做到了前任都做不到的事情 在漩涡中心工作 1一个人应该主动去做核心业务，主动去解决核心问题——这些业务和问题是公司管理层最关注的，如果你做出成绩，最容易被看到。 成为解决问题的高手 1234公司最需要什么人？能够快速解决问题的人！所以，如果你能进入到漩涡中心，并且能够真的解决问题，那就有极大的可能脱颖而出。相对地，如果你在漩涡中心，不但不能解决问题，还阻碍问题的解决，也很容易被发现 做好工作汇报 123只会干，不会说——傻把式只会说，不会干——假把式既会干，又会说——真把式 学习面对软件众多的技术知识点，这学一点那学一点，很难衔接起来，我的建议你抓住“性能优化”这个主干： 水平性能提升，你需要学习哪些知识? 分布式相关知识学习 垂直性能提升，你需要学习哪些知识？ 1算法、数据结构的差别；各类库、系统、软件的性能差异；cpu设计导致结构体大小的调整、多线程优化、各种共享资源的性能差异；内存相关的优化；存储相关的优化；网络相关的优化 等等 按照如上的学习方法，学习其中的技术原理和知识点，并实践在自己的项目中，你的能力一定会得到极大的提升。 牢记两个“心”下面是别人总结的： 悟心、匠心 悟心需求理解能力； 读代码能力； 抽象系统的能力； 匠心工匠精神，不能仅仅满足功能的可用性，用自己最大的努力将产品最到极致，是我们最终的目标。 修炼 同理心的修炼，认同他人的能力和架构设计；别管他设计的多差劲，认同他 全局观的修炼，保持好奇心和学习的韧性 迭代能力的修炼，学会反思，学会在自我否定中不断成长]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[json 转pb 问题定位]]></title>
    <url>%2F2020%2F04%2F27%2Fjson-%E8%BD%ACpb-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[背景线上服务升级一天后，大数据过来告诉我说昨天一天的数据大批下滑。 分析一脸懵逼。昨天升级的服务我是分步升级的，之前的一周我已经升级了1/10的服务，验证业务的稳定，运行一周后，线上无反馈，所以昨天开始批量升级。 我只能把逻辑重新看了一遍，最后锁定再pb新增加了字段如下123456789101112message UserBase&#123; optional int32 userid = 1; // 用户ID optional int32 ip = 2; // IP optional int32 groupid = 3; // 大厅组ID optional int32 recommenderid = 4; // 推广(员)ID optional int32 channel = 5; // 渠道号 optional int32 usertype = 6; // 用户类型( 0：普通用户 1：会员用户) optional int32 groupopt = 7; // group options optional string addinfo = 8; // 玩家自定义数据 -- 新增 optional string idcard = 9; // 身份证号 -- 新增&#125; 按理说pb中新增加字段，没修改序号是没什么影响的，但为什么偏偏出问题了呢？继续分析，原来是 json-&gt;pb 出现的问题。 问题A服务将pb内容序列化json写入redis123456789// bPrimitie false:不输出默认参数， true ：输出所有参数BOOL PB_Msg2Json(const ::google::protobuf::Message&amp; msg, std::string&amp; strJson, bool bMultiLine,bool bPrimitie)&#123; google::protobuf::util::JsonPrintOptions jpo; jpo.add_whitespace = bMultiLine;//multiline 多行显示 jpo.always_print_primitive_fields = bPrimitie; //保留字段是否默认输出 return google::protobuf::util::MessageToJsonString(msg, &amp;strJson, jpo).ok();&#125; B服务从redis读取json在序列化为pb123456BOOL PB_Json2Msg(const std::string&amp; strJson, ::google::protobuf::Message&amp; msg)&#123; google::protobuf::util::JsonParseOptions jpo; return google::protobuf::util::JsonStringToMessage(strJson, &amp;msg, jpo).ok();&#125; pb新增加了字段，A服务升级，导致redis中的json多了两个字段，这时B服务未升级将json序列为老pb失败。 原因在于PB_Json2Msg 默认的 options 设置问题1234567BOOL PB_Json2Msg(const std::string&amp; strJson, ::google::protobuf::Message&amp; msg)&#123; google::protobuf::util::JsonParseOptions jpo; jpo.ignore_unknown_fields = true; // 过滤掉json和pb不相同的字段 return google::protobuf::util::JsonStringToMessage(strJson, &amp;msg, jpo).ok();&#125;]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[web 报表功能开发]]></title>
    <url>%2F2020%2F04%2F23%2Fweb-%E6%8A%A5%E8%A1%A8%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[背景应同学的要求帮忙做一个他们自己店铺的退货功能，需求很简单，考虑自己也想试试用web来开发下小功能，就试了试。 需求店铺有多个员工，原本店长（同学）把每天要退货的“订单号”“退货内容”“是否已收货”“签收员”“收货时间”放在excel中，然后不同的人收到货之后设置下“已收货”。如果每人一个excel，那么就会出现不同步，最后统计时很麻烦。 思路使用mysql作为数据中心，然后提供一个界面给员工操作，其实很简单。 方案一使用C/S界面，我一般都用mfc/qt 来开发小工具，所以直接就使用mfc来开发客户端，花费了1天的时间，功能基本完成，截图如下，丑是丑了点，但好歹用起来没什么问题 如果仅仅这样子就无法满足我的初衷了，我是要用web来做UI的。 方案二使用B/S开发，linux服务端可以选择用C++、go、python等语言开发，但我打算用openrestry+lua脚本来开发。总体大概思路：web端发起http请求给openresty， openresty通过lua脚本集成mysql驱动获取数据通过http返回请求。 因为主要是报表的功能，所以需要选择一个js的报表库，我使用的是jsgrid，这个我是随便选的。12345http://js-grid.com/Lightweight Grid jQuery PluginjsGrid is a lightweight client-side data grid control based on jQuery. It supports basic grid operations like inserting, filtering, editing, deleting, paging, and sorting. jsGrid is flexible and allows to customize its appearance and components. step 1花费半天时间学习jsgrid，网站有demos、api文档介绍，半天时间总算知道如何通过静态数据进行一些报表的操作。 step 2openrestry 学习。 几年前接触过，所以用起来还算可以，虽说只有简单的几个sql数据但我对lua不熟悉，调试花费了很多时间，一个下午的时间差不多也弄完了。 step 3通过http请求数据到jsgrid中。其中功能优化、调试大概又花费了半天 step 4线上真实数据测试。历史数据大概3000条，一次性请求按原来的逐条jsgrid insetitem 方法太慢（3000条需要1分钟），然后再仔细查看api文档、demo、issues 找到了方法一次性插入所有数据，问题解决，花费半天时间。1$(&quot;#jsGrid&quot;).jsGrid(&quot;option&quot;, &quot;data&quot;, lists); 效果如下 大体功能应该完成了，自己也熟悉了web的界面开发。 注意点jsgrid 报表在手机app上显示有个问题，就是如果autoload时如果没数据的化，手机app是无法滑动报表表头的，只有有数据时才能滑动，所以应该把关键的filter 列放在无数据时也能操作的地方。 代码又重新写了一遍代码，比原来简单多了 lua123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182local cjson = require &quot;cjson&quot;local mysql = require(&quot;resty.mysql&quot;)local db_config = &#123; host = &apos;127.0.0.1&apos;, port = 3306, database = &apos;&apos;, user = &apos;&apos;, password = &apos;&apos;, dbtable = &apos;&apos;&#125;local args = ngx.req.get_uri_args()local action = args[&apos;action&apos;]local db,err--自定义一个函数，time为指定的日期格式YYYY-MM-DD，--dayChange为指定日期前后天数，用法：前一天 -1 后一天 1. function dateChange(time,dayChange) if string.len(time)==10 and string.match(time,&quot;%d%d%d%d%-%d%d%-%d%d&quot;) then local year=string.sub(time,0,4);--年份 local month=string.sub(time,6,7);--月 local day=string.sub(time,9,10);--日 local time=os.time(&#123;year=year, month=month, day=day&#125;)+dayChange*86400 --一天86400秒 return (os.date(&apos;%Y&apos;,time)..&quot;-&quot;..os.date(&apos;%m&apos;,time)..&quot;-&quot;..os.date(&apos;%d&apos;,time)) endendfunction dbinit() db, err = mysql:new() if not db then ngx.say(&quot;failed to instantiate mysql: &quot;, err) return end db:set_timeout(5000) -- 5 sec local ok, err, errcode, sqlstate = db:connect(&#123; host = db_config.host, port = db_config.port, database = db_config.database, user = db_config.user, password = db_config.password&#125;) if not ok then ngx.log(ngx.ERR, &quot;failed to connect: &quot;, err, &quot;: &quot;, errcode, &quot; &quot;, sqlstate) return endendfunction dbclose()-- or just close the connection right away: local ok, err = db:close() if not ok then ngx.say(&quot;failed to close: &quot;, err) return endendfunction getdatafromsql(sql) local res, err, errno, sqlstate = db:query(sql) if not res then ngx.say(cjson.encode(&#123;code=200, message=err, data=nil&#125;)) else ngx.say(cjson.encode(&#123;code=200, message=&quot;&quot;, data=res&#125;)) endend-- http://localhost/cailei?action=GetDataByFiter-- jsonfunction GetDataByFiter() local order local cancell local intime local filtersql ngx.req.read_body() local args, err = ngx.req.get_post_args() if not args then ngx.say(&quot;failed to get post args: &quot;, err) return end -- ngx 把参数都作为字符串处理 for key, val in pairs(args) do if key == &apos;ordernum&apos; then order=val elseif key == &apos;timefilter&apos; then intime=val elseif key == &apos;cancell&apos; then cancell=val end end if intime == &apos;&apos; then ngx.say(&quot;must take time&quot;) return end if intime == &apos;0&apos; then -- 近3天 intime = dateChange(ngx.today(),-3) elseif intime == &apos;1&apos; then -- 近7天 intime = dateChange(ngx.today(),-7) elseif intime == &apos;2&apos; then -- 近半月 intime = dateChange(ngx.today(),-15) elseif intime == &apos;3&apos; then -- 近一月 intime = dateChange(ngx.today(),-30) end --intime 是必须携带的 if intime ~= &apos;&apos; then filtersql = &apos; where intime&gt;=\&apos;&apos;..intime..&apos;\&apos;&apos; end if order ~= &apos;&apos; then filtersql = filtersql..&apos; and ordernum LIKE \&apos;%&apos;..order..&apos;%\&apos;&apos; end if cancell ~= &apos;-1&apos; then filtersql = filtersql..&apos; and cancell=&apos;..(cancell) end local sql = &apos;SELECT * FROM &apos;..db_config.dbtable..filtersql --ngx.say(sql) getdatafromsql(sql)end-- http://localhost/cailei?action=UpdateData-- jsonfunction UpdateData() ngx.req.read_body() local order local name local optime local cancell local remark local args, err = ngx.req.get_post_args() if not args then ngx.say(&quot;failed to get post args: &quot;, err) return end -- ngx 把参数都作为字符串处理 for key, val in pairs(args) do if key == &apos;ordernum&apos; then order=val elseif key == &apos;name&apos; then name=val elseif key == &apos;cancell&apos; then cancell=val elseif key == &apos;remark&apos; then remark = val elseif key == &apos;timestamp&apos; then optime = val end end -- optime = ngx.localtime() if order == nil then ngx.say(&quot;failed to get post args: &quot;, err) return end local sql = &apos;update &apos;..db_config.dbtable..&apos; set cancell=&apos;..cancell..&apos; , remark=\&apos;&apos;..remark..&apos;\&apos;&apos;..&apos; ,name=\&apos;&apos;..name..&apos;\&apos;,timestamp=\&apos;&apos;..optime..&apos;\&apos; where ordernum =\&apos;&apos;..order..&apos;\&apos;&apos; --ngx.say(sql) getdatafromsql(sql)end if action == &apos;GetDataByFiter&apos; then dbinit() GetDataByFiter() dbclose()elseif action == &apos;UpdateData&apos; then dbinit() UpdateData() dbclose()end js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;退库系统&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="demos.css" /&gt; &lt;link href='http://fonts.googleapis.com/css?family=Open+Sans:300,600,400' rel='stylesheet' type='text/css'&gt; &lt;link rel="stylesheet" type="text/css" href="../css/jsgrid.css" /&gt; &lt;link rel="stylesheet" type="text/css" href="../css/theme.css" /&gt; &lt;script src="../external/jquery/jquery-1.8.3.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="http://code.jquery.com/ui/1.11.2/themes/cupertino/jquery-ui.css"&gt; &lt;script src="http://code.jquery.com/jquery-1.10.2.js"&gt;&lt;/script&gt; &lt;script src="http://code.jquery.com/ui/1.11.2/jquery-ui.js"&gt;&lt;/script&gt; &lt;script src="http://ajax.aspnetcdn.com/ajax/jquery.validate/1.9/jquery.validate.min.js"&gt;&lt;/script&gt; &lt;script src="../src/jsgrid.core.js"&gt;&lt;/script&gt; &lt;script src="../src/jsgrid.load-indicator.js"&gt;&lt;/script&gt; &lt;script src="../src/jsgrid.load-strategies.js"&gt;&lt;/script&gt; &lt;script src="../src/jsgrid.sort-strategies.js"&gt;&lt;/script&gt; &lt;script src="../src/jsgrid.field.js"&gt;&lt;/script&gt; &lt;script src="../src/fields/jsgrid.field.text.js"&gt;&lt;/script&gt; &lt;script src="../src/fields/jsgrid.field.number.js"&gt;&lt;/script&gt; &lt;script src="../src/fields/jsgrid.field.select.js"&gt;&lt;/script&gt; &lt;script src="../src/fields/jsgrid.field.checkbox.js"&gt;&lt;/script&gt; &lt;script src="../src/fields/jsgrid.field.control.js"&gt;&lt;/script&gt; &lt;style&gt; .ui-widget *, .ui-widget input, .ui-widget select, .ui-widget button &#123; font-family: 'Helvetica Neue Light', 'Open Sans', Helvetica; font-size: 14px; font-weight: 300 !important; &#125; .details-form-field input, .details-form-field select &#123; width: 250px; float: right; &#125; .details-form-field &#123; margin: 30px 0; &#125; .details-form-field:first-child &#123; margin-top: 10px; &#125; .details-form-field:last-child &#123; margin-bottom: 10px; &#125; .details-form-field button &#123; display: block; width: 100px; margin: 0 auto; &#125; input.error, select.error &#123; border: 1px solid #ff9999; background: #ffeeee; &#125; label.error &#123; float: right; margin-left: 100px; font-size: .8em; color: #ff6666; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;退库数据&lt;/h1&gt; &lt;div id="detailsDialog"&gt; &lt;form id="detailsForm"&gt; &lt;div class="details-form-field"&gt; &lt;label for="order"&gt;订单号:&lt;/label&gt; &lt;input id="order" name="订单号" type="text" readonly="readonly" /&gt; &lt;/div&gt; &lt;div class="details-form-field"&gt; &lt;label for="name"&gt;名字:&lt;/label&gt; &lt;select id="name" name="名字"&gt; &lt;option value="蔡磊"&gt;蔡磊&lt;/option&gt; &lt;option value="包包"&gt;包包&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="details-form-field"&gt; &lt;label for="cancell"&gt;是否已退库:&lt;/label&gt; &lt;select id="cancell" name="是否已退库"&gt; &lt;option value="0"&gt;未退库&lt;/option&gt; &lt;option value="1"&gt;已退库&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class="details-form-field"&gt; &lt;label for="remark"&gt;备注:&lt;/label&gt; &lt;input id="remark" name="备注" type="text" /&gt; &lt;/div&gt; &lt;div class="details-form-field"&gt; &lt;button type="submit" id="save"&gt;修改&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div id="jsGrid"&gt;&lt;/div&gt; &lt;script&gt; let svrurl = "http://localhost/"; itemcancell = [ &#123; Name: "全部", Id: -1 &#125;, &#123; Name: "未退库", Id: 0 &#125;, &#123; Name: "已退库", Id: 1 &#125; ]; itemintime = [ &#123; Name: "近三天", Id: 0 &#125;, &#123; Name: "近七天", Id: 1 &#125;, &#123; Name: "近半月", Id: 2 &#125;, &#123; Name: "近一月", Id: 3 &#125; ]; Date.prototype.Format = function (fmt) &#123; // author: meizz var o = &#123; "M+": this.getMonth() + 1, // 月份 "d+": this.getDate(), // 日 "h+": this.getHours(), // 小时 "m+": this.getMinutes(), // 分 "s+": this.getSeconds(), // 秒 "q+": Math.floor((this.getMonth() + 3) / 3), // 季度 "S": this.getMilliseconds() // 毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt; &#125; $(function() &#123; $("#jsGrid").jsGrid(&#123; height: "70%", width: "100%", autoload:true, editing: true, paging: true, filtering: true, pageButtonCount: 5, rowClick: function(args) &#123; showDetailsDialog("修改", args.item); &#125;, controller: &#123; loadData: function(filter) &#123; var d = $.Deferred(); $.ajax(&#123; type: "post", url: svrurl+"cailei?action=GetDataByFiter", data: filter, dataType: "json", success: function(res,status,xhr) &#123; d.resolve(res.data); &#125;, error: function(res,status)&#123; console.log(status); &#125; &#125;); return d.promise(); &#125;, updateItem: function(updatingClient) &#123; &#125; &#125;, fields: [ &#123; name: "ordernum", title: "订单号",type: "text",width: 150 ,editing: false,visible: true &#125;,// 不指定类型，则该field不可编辑 &#123; name: "remark",title: "备注",sorting: false,editing: false&#125;, &#123; name: "cancell",title: "是否已退库", type: "select", items: itemcancell, valueField: "Id", textField: "Name",selectedIndex: 0&#125;, &#123; name: "name",title: "收货员", width: 150 ,editing: false&#125;, &#123; name: "timestamp",title: "收货时间",readOnly: true&#125;, &#123; name: "intime",title: "入库时间",readOnly: true,editing: false&#125;, &#123; name: "timefilter",title: "最近搜索", type: "select", items: itemintime, valueField: "Id", textField: "Name",selectedIndex: 0&#125; // &#123; name: "timefilter",title: "最近搜索",type:"select",items: db.time, valueField:"Id",textField: "Name",selectedIndex: 0&#125; // &#123; type: "control", modeSwitchButton: false,deleteButton:false &#125; ], &#125;); $("#detailsDialog").dialog(&#123; autoOpen: false, width: 400, close: function() &#123; $("#detailsForm").validate().resetForm(); $("#detailsForm").find(".error").removeClass("error"); &#125; &#125;); $("#detailsForm").validate(&#123; rules: &#123; name: "required", cancell: "required" &#125;, messages: &#123; name: "请选择", cancell: "请选择" &#125;, submitHandler: function() &#123; formSubmitHandler(); &#125; &#125;); var formSubmitHandler = $.noop; var showDetailsDialog = function(dialogType, client) &#123; $("#cancell").val(client.cancell); $("#remark").val(client.remark); $("#order").val(client.ordernum); formSubmitHandler = function() &#123; saveClient(client); &#125;; $("#detailsDialog").dialog("option", "title", dialogType + " 记录") .dialog("open"); &#125;; var saveClient = function(client) &#123; client.name = $("#name").val(); client.cancell = parseInt($("#cancell").val(),10); client.remark = $("#remark").val(); client.timestamp = new Date().Format("yyyy-MM-dd hh:mm:ss"); $.ajax(&#123; url: svrurl+"cailei?action=UpdateData", data: client, type: "post", dataType: "json", success: function(res,status,xhr) &#123; &#125;, error: function(res,status) &#123; &#125; &#125;); $("#jsGrid").jsGrid("updateItem", client); $("#detailsDialog").dialog("close"); &#125;; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[疫情期间个人投资总结]]></title>
    <url>%2F2020%2F04%2F17%2F%E7%96%AB%E6%83%85%E6%9C%9F%E9%97%B4%E4%B8%AA%E4%BA%BA%E6%8A%95%E8%B5%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[别买原油，买油气公司原油是损失最大的， 当我卖掉时心里实在是太难受了，失眠了一天而且还请了几天假。 在买原油时，一定要做好功课，比如每个月都要移仓（成本1.5%/月），移仓时还有期货的升水、贴水，所以不要持有超过1个月，买这个产品的都是短期操作，别想着现在石油比水便宜，拿个一年肯定翻倍的美梦。 美国原油基金（USO、UCO）类似。如果你真的想买石油，那么还是推荐买燃油公司，比如雪佛龙、美孚、西方石油、先锋。 推荐买负债低、CEO人品好的公司。 不要买石油产品，应该买油气公司。从长期来看（不考虑升水、贴水），油价涨幅也就1~3倍，所以只能买短线。但是短线你又买不过很多投行和量化公司； 但是买长期可以看好科技采油公司，技术的提升带来股价的提升远不止3倍，而且在这次疫情期间，负债低、CEO优质的公司可以买入更多的资源，只要石油需求反弹，涨幅远比石油更猛烈。 不要满仓当形势不明朗时，不要满仓。抄底容易抄到半山腰。 选股自己选股很难，抄作业却比较简单， 对着巴菲特持有的股票抄就可以了。 etf有时候抄作业也难，那就选etf吧。中国就买沪深300、标普500的基金，美股就买标普500（RSP)。 绝大多数人（不是大多数，是绝大多数）自己选来选去，学来学去，担心这担心那，然后买来买去，最后年终总结，发现自己的收益却赢不了指数基金。 指数基金都是跟随权重股的涨跌，如果你想跑赢指数基金，那么你必然不能买权重股，你只能买一些小股、妖股、概念股，这时你就不属于投资，而是在投机了，风险是非常大的。 美股etf1234银行etf KBWB全球航空eft JETS科技行业etf XLK能源eft XLE 时间线4月20日石油亏损那么多，心有不甘，所以看了一些文章应该投资一些油气公司，觉的自己知道的太晚。买入12345西方石油（这个不是很推荐，负债太高，但是巴菲特持有，所以涨跌浮动很大）先锋自然资源(PXD)FANGCOG油气开采EFT(XOP) 4月28日我加仓了123美国航空美国银行摩根大通 个人觉的航空、银行、能源应该到调整的周期了，不看好科技股的大涨幅。 目前的持仓是：123456789101112英伟达可口可乐美国航空瑞幸咖啡迪士尼摩根大通西方石油先锋自然资源FANGEOG能源Range能源AR 股票分散的太多了，之后某个时间应该会卖掉1234567可口可乐瑞幸咖啡迪士尼西方石油Range能源AR美国航空 5月9日之前卖掉了美国银行，小赚了一点，结果抵挡不住诱惑购买了天然气（AR),结果套牢，看来自己心态实在是差，投机心态太强。其实除了原油基金以外的股票，我只要一直坚持拿到现在也已经有盈利了。 国内A股和基金也小赚了一些，国内疫情好转，打算把债券基金拿一部分出来继续投入到A股中，选择如下并长期持有12345美的格力中海油服中国国航上海机场 总结这次损失估计要好长时间才能缓回来，有可能继续亏。每天太累了，心情波动很大，影响工作和生活。 远离投资市场，实在是想投资点啥，就买指数基金吧。 别让这些烦心事打扰了我们的生活。]]></content>
      <categories>
        <category>生活琐事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[美股投资大神段永平是如何在股市崩盘中大赚50倍的？他的秘籍是什么]]></title>
    <url>%2F2020%2F04%2F13%2F%E7%BE%8E%E8%82%A1%E6%8A%95%E8%B5%84%E5%A4%A7%E7%A5%9E%E6%AE%B5%E6%B0%B8%E5%B9%B3%E6%98%AF%E5%A6%82%E4%BD%95%E5%9C%A8%E8%82%A1%E5%B8%82%E5%B4%A9%E7%9B%98%E4%B8%AD%E5%A4%A7%E8%B5%9A50%E5%80%8D%E7%9A%84%EF%BC%9F%E4%BB%96%E7%9A%84%E7%A7%98%E7%B1%8D%E6%98%AF%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[时间2020年3月10日 观点美股投资大神段永平是如何在股市崩盘中大赚50倍的？他最近选出的大牛股是哪些？他的赚钱秘诀是什么？ 链接链接：https://pan.baidu.com/s/1Wlc8uz1YerSVFtHbsZX1Qg 提取码：tom2 笔记 投资理念，买入并长期持有，需要从心底里认同这种投资逻辑，并不被周围的人影响，且长期执行，是很不容易的 做对的事情和把事情做对 买股票就是买公司。很多人嘴上说自己是价值投资者，但是真的能够从内心相信买股票就是买公司的人并不多。 长期持有是对一个公司价值的判断。买股票需要有一个封仓10年的想法。更重要的是定性的能力，如果公司长期竞争力没有什么变化，那么一时的财务好坏并不重要。 本份+平常心 什么时候卖股票？ 股票分析：找到雪地和长长的坡]]></content>
      <categories>
        <category>刘翔投资</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[美股在2020年會崩盤麽？目前的美股到底有沒有泡沫？]]></title>
    <url>%2F2020%2F04%2F09%2F%E7%BE%8E%E8%82%A1%E5%9C%A82020%E5%B9%B4%E6%9C%83%E5%B4%A9%E7%9B%A4%E9%BA%BD%EF%BC%9F%E7%9B%AE%E5%89%8D%E7%9A%84%E7%BE%8E%E8%82%A1%E5%88%B0%E5%BA%95%E6%9C%89%E6%B2%92%E6%9C%89%E6%B3%A1%E6%B2%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[时间2019年12月20日 观点美股在2020年會崩盤麽？目前的美股到底有沒有泡沫？ 链接链接：https://pan.baidu.com/s/1mtONVui6pnzojttQHhb-sA 提取码：t0lr 笔记 企业盈利能力的增长，造就了美股十年的大牛市 三个利好 1231、川普的税改。重视美国股市，不遗余力，美股最大的多头2、公司的回购潮。科技股回购主力军3、美联储的降息。2020年继续降息也是可以预期的 美股到底贵不贵呢？结合利率水平，虽然看去不便宜，但也不能说明有明显的泡沫。 美国经济基本面各项数据还是不错的，从数据看处于健康稳定的状态中。 12截止到2019年11月份，非农失业率3.5%个人消费增速2.9%，十年来保持良好的增长 2020年有降息的预期，崩盘的可能性不大。但是毕竟经历了十年的大牛市，未来也有可能20~30%的调整。 要选择真正优秀的有长期竞争力的公司，如果股市出现大幅度调整，这些公司也随着调整的话，反而是个很好的买入机会，因为好的公司是可以穿越熊市的。]]></content>
      <categories>
        <category>刘翔投资</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[股灾中，投资指数基金ETF还靠谱吗？]]></title>
    <url>%2F2020%2F04%2F08%2F%E5%88%98%E7%BF%94%E7%9A%84%E6%8A%95%E8%B5%84%E9%A2%91%E9%81%93%2F</url>
    <content type="text"><![CDATA[时间2020年4月8日 观点美股投资之：股灾中，投资指数基金ETF还靠谱吗？现在还应该买入指数基金ETF吗？投资指数基金ETF有什么好处？ 链接链接：https://pan.baidu.com/s/1WNJoQqmDTSsBhzN63McTiQ提取码：z331 笔记 指数基金eft适合大部分个人投资者 三个好处 1231、成本低。每年的基金费用比其他要低0.9%。2、不择时。购买之后，基本不怎么交易，反而更容易盈利。3、强制储蓄。虽然没法获得最优收益，但可以获取平均收益。 幸存者偏差。指数基金的收益关键在于国运，国家经济向好就可以长期投资，否则长期持有也会负收益。 同时押宝中国和美国。两个国家都有大量的消费能力，但体制却不一样，有优势也有劣势。]]></content>
      <categories>
        <category>刘翔投资</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[刘翔投资[转]]]></title>
    <url>%2F2020%2F04%2F07%2F%E5%88%98%E7%BF%94%E6%8A%95%E8%B5%84-%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[最近学习“刘翔的投资频道”，个人认为说的不错，记录下学习过程。 他的频道在油管中可以订阅]]></content>
      <categories>
        <category>刘翔投资</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vs2019链接时找不到kernel32.lib]]></title>
    <url>%2F2020%2F03%2F19%2Fvs2019%E9%93%BE%E6%8E%A5%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0kernel32-lib%2F</url>
    <content type="text"><![CDATA[背景安装完vs2019后编译一个demo程序，提示”链接时找不到kernel32.lib” 解决方法 “视图”“其他窗口”“属性管理器”，查看“Microsoft.Cpp.Win32.User”中 对应的“宏”，输入：$(WindowsSdk_71A_LibraryPath_x86)， 如果没有定义，则换成$(WindowsSDK_LibraryPath_x86)]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows下C++程序的捕获功能]]></title>
    <url>%2F2020%2F03%2F13%2Fwindows%E4%B8%8BC-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%8D%95%E8%8E%B7%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[背景因为打算把服务器从win2008 server升级到win2012，所以需要验证下新系统对程序异常的捕获能力。 测试之前使用的是 link 里面说到的方法。 我很关注 stack Security Checks ，因为类似如下代码，12345void xxx()&#123; char szchar[8]; sprintf(szchar, &quot;%s&quot;, &quot;1111111111122222&quot;);&#125; 程序会崩溃但不会生成dump(部分崩溃都是这个造成的），这对程序的定位带来了很大的麻烦，所以我在切换操作系统时非常关注这个功能的使用。 但不幸的是，vs2012居然不支持如上的设置方式。 一开始我认为应该是hook api的方式，于是google了不少的文章，最后找到靠谱的方法 link 发现实际api的hook是成功的，但crt gs触发的异常就是无法捕获 二再搜索文章的过程中看到了这个链接link 这个文章里面对C++的异常都可以捕获，同时也说明crt的异常说明123456789Buffer Security ChecksBy default, you have the /GS (Buffer Security Check) compiler flag enabled that forces the compiler to inject code that would check for buffer overruns. A buffer overrun is a situation when a large block of data is written to a small buffer.Note; In Visual C++ .NET (CRT 7.1), you can use the _set_security_error_handler() function that CRT calls when a buffer overrun is detected. However, this function is deprecated in the later versions of CRT.Since CRT 8.0, you can&apos;t intercept the buffer overrun errors in your code. When a buffer overrun is detected, CRT invokes Dr. Watson directly instead of calling the unhandled exception filter. This is done because of security reasons and Microsoft doesn&apos;t plan to change this behavior. For additional info, please see these links:https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=101337http://blog.kalmbachnet.de/?postid=75 但是在win8.1 和 win10 系统下还是无法捕获栈里面说的异常， 同时在查看 crt代码时，还看到了这段说明 12345678910// Set up a fake exception, and report it via UnhandledExceptionFilter.// We can&apos;t raise a true exception because the stack (and therefore// exception handling) can&apos;t be trusted. The exception should appear as// if it originated after the call to __report_securityfailure, so it// is attributed to the function where the violation occurred.//// We assume that the immediate caller of __report_securityfailure is// the function where the security violation occurred. Note that the// compiler may elect to emit a jump to this routine instead of a call,// in which case we will not be able to blame the correct function. 12345678910111213141516171819202122232425__declspec(noreturn) void __cdecl __raise_securityfailure( PEXCEPTION_POINTERS const exception_pointers ) &#123; #ifdef _VCRT_BUILD DebuggerWasPresent = IsDebuggerPresent(); _CRT_DEBUGGER_HOOK(_CRT_DEBUGGER_GSFAILURE); #endif // _VCRT_BUILD SetUnhandledExceptionFilter(NULL); UnhandledExceptionFilter(exception_pointers); #ifdef _VCRT_BUILD // If we make it back from Watson, then the user may have asked to debug // the app. If we weren&apos;t under a debugger before invoking Watson, // re-signal the VS CRT debugger hook, so a newly attached debugger gets // a chance to break into the process. if (!DebuggerWasPresent) &#123; _CRT_DEBUGGER_HOOK(_CRT_DEBUGGER_GSFAILURE); &#125; #endif // _VCRT_BUILD TerminateProcess(GetCurrentProcess(), STATUS_SECURITY_CHECK_FAILURE); &#125; 进行代码跟踪调试，也的确走到了SetUnhandledExceptionFilter函数，但就是不进入我hook的api中，很是奇怪，能力有限，可以试着hook KiUserExceptionDispatcher和UnhandledExceptionFilter 。 三使用google 的breakpad,进行捕获异常。分为进程内异常捕获和进程外异常捕获 异常捕获也是无法捕获stack 异常的。 四按照 二 中链接给出的异常类型进行验证link中的CCrashHandler 捕获能力最好推荐，google的breakpad 可以c/s捕获进程， hook api 可以获取win7下的crt异常 五考虑windows本身有AutoDebug功能，修改注册表“\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows NT\CurrentVersion\AeDebug”auto=112Debugger=&quot;C:\Program Files (x86)\Debugging Tools for Windows (x86)\ntsd.exe&quot; -p %ld -e %ld -g -c &quot;.dump /f /u d:\1.dmp ;q &quot; 这样就可以把异常通过ntsd 自动保存dump。 缺点是： 无法区分进程名是什么 总结 进程内捕获推荐Exception-Handling + hook api （win7 以前系统均可捕获，win10 只有一种情况无法捕获) win8.1 win10 系统推荐用 Exception-Handling + autoDebug ; 可参考 异常捕获 google breakpad 可作为备选，优点跨平台 补充最近线上刚好又出现了异常，这次是在win2008系统下已经hook api的情况下还是出现了异常，并且测试使用Exception-Handling也无法捕获到dump，最后还是依靠AutoDebug自动保存了dump，并分析出来是double free导致heap异常。 但是我使用demo测试模拟double free是不会出现异常的。 最终最靠谱的方案还是使用AutoDebug来捕获最靠谱。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小孩流感]]></title>
    <url>%2F2020%2F01%2F20%2F%E5%B0%8F%E5%AD%A9%E6%B5%81%E6%84%9F%2F</url>
    <content type="text"><![CDATA[时间2020/01/18 过程女儿从姥姥家来杭州，计划过年的时候和儿子一起回老家看我的奶奶、姑姑等一些亲戚，虽然老家离杭州不远，但是女儿这几年都因为很多事情没怎么去，大家都还是很期待的。 但事与愿违，1月18日早上起来女儿感觉不舒服，一量体温38度，所以就想着会是什么原因导致？昨晚和儿子玩玩具，用嘴舔玩具，太脏了，感染了细菌？昨天因为太冷，都没出去过，也没有流鼻涕所以感冒的可能性不大也出去过，也打了流感疫苗，流感的可能性也不大 …… 想了一些细节，总觉的最有可能的是肠胃出了问题。 早上让她多喝点水，休息休息；下午去了趟社区医院，检查了血，从血像上看不是细菌感染，有点像流感病毒，让我们观察一天。晚上回去女儿精神还可以，早点上床休息了。 半夜温度到39.6度，然后给喝了美林5ml，奇怪的是一段时间后温度并没下降，也没出汗，我都怀疑药是否过期了，还是没摇匀。 1/19日，我们去上班，让爸妈注意观察，下午温度到了40度左右，我们就决定晚上带去省儿保医院看下。重新抽了血看了血像和病情描述，比较肯定的回答是流感，给开了奥司他韦，并嘱咐我们需要隔离，3天后温度不降回院检查。 TIPS：表象上无明显感冒特征，体温快速上升高温不退，美林降温效果不大；血象上白细胞、超敏c反应不高，中性粒细胞偏高；打了流感疫苗也中招。 结果第二天买了回姥姥家的高铁票，把儿女送了回去，免的交叉感染。现在也在关注儿子是否也有感染（虽然也打了流感疫苗）。 流感潜伏期有2~4天，很可能在来杭州的路上或是在幼儿园放假那天就已经感染了。 后续回姥姥家让当地的医院进行了病毒检查，甲型、乙型是阴性]]></content>
      <categories>
        <category>生活琐事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内存碎片分析(2)]]></title>
    <url>%2F2020%2F01%2F17%2F%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景之前写过一篇文章 内存碎片分析 的后续分析。 问题检查大厅状态时发现check服务虚拟内存很高，于是就看了下历史的内存状态 时间时从12月3日9：51分开始突然所有check服务都上升，然后12月4日7：01分提交内存下降，但虚拟内存仍然不变。 分析过程1） 提交内存上升，必然是代码中大量申请内存导致，于是review了代码查看有没有大的内存申请，没有。 2）已经确认了上升时间，那么查看每小时的消息处理统计，有没有处理消息的量级上升，没有。 3）查看12月3日9：50~9：51之间的日志，无线索。 4）查看12月4日7：01~7：02之间的日志，有线索，count值很大。112/04/19 07:02:28:955[4500][INFO][Server.cpp:770] release server buffer pool done. count = 408490. 对比了历史日志的，大都是几百， 所以应该是这个时刻通讯库调用了 ReleaseSockBufPool()函数清理了无效buff导致提交内存大量释放。 review了底层通讯库的代码，如果报文突然大量涌入，会开辟很多buff，每个buff=4K，而且这个内存只能手动清理，无法自动清理。 然后去咨询运维，12月3日机房网络状况，那个时刻有个较大的网络抖动。 原因就是： 1）网络抖动导致通讯库瞬间大量申请内存； 2）第二天定时清理释放无效内存； 3）虚拟内存大小未变化。 虚拟内存大小未变化我们的服务经常出现虚拟内存过高的问题，而这次checksvr确确实实也碰到了提交内存下降，但虚拟内存却不下降，特别的写了个demo，非调试下运行 1234567891011121314151617int _tmain(int argc, _TCHAR* argv[])&#123; std::list&lt;char *&gt; oList; for (auto i = 0; i &lt; 400000; i++) &#123; char *pBuff = (char*)malloc(1024* 4 ); oList.push_back(pBuff); &#125; for each (auto obj in oList) &#123; free(obj); &#125; system(&quot;pause&quot;); return 0;&#125; 发现4K的内存申请，释放之后虚拟内存是不会下降的，4K一直调整到508K时，提交内存和虚拟内存都会同时下降；原因是内存大小&gt;507K时，内存已经不在堆中申请，而是在堆外申请。 总结点学习了，原来虚拟内存过高也不一定是内存碎片，也可能是某次提交内存的大量申请，然后释放从而导致虚拟内存上升。 通讯库4K的由于历史原因修复的风险很大，所以计划使用asio架构的通讯库替换原来老的库。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中国文化的深层结构]]></title>
    <url>%2F2020%2F01%2F17%2F%E4%B8%AD%E5%9B%BD%E6%96%87%E5%8C%96%E7%9A%84%E6%B7%B1%E5%B1%82%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[时间2020年1月 感想这本书从文化的角度来分析国人生活习惯；《巨ying国》从心理学角度来分析国人的生活习惯 1在这本书里，中国文化以十分负面的形象出现，那是因为它被放置入一个由他人缔造的“现代”世局中，一切条件对它来说都是不利的，用来衡量它的所有标准也必然是异化的。但这个“现代化”该不断被重新定义。中国文化的“文法”规则能否在新的世局里创造出族新的佳句妙句，我们将拭目以待。 本书写1983年时面世，里面举例的有些观点在现在已经不太合时宜了。应该说这几十年祖国的发展，国人的很多方面都是得到了很大的提高，所以说经济是基础。 同时书中说的很多观点也是有道理的，所以我们在与人交往上遇到不顺眼的不要一味的埋怨，多一份理解，多一份宽容。 如上两本书我会保留，内容太多，看不完，将来还会再翻翻。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于给家人购买保险]]></title>
    <url>%2F2020%2F01%2F13%2F%E5%85%B3%E4%BA%8E%E7%BB%99%E5%AE%B6%E4%BA%BA%E8%B4%AD%E4%B9%B0%E4%BF%9D%E9%99%A9%2F</url>
    <content type="text"><![CDATA[背景买保险，给小孩买保险、给老婆买保险、给自己买保险、给父母买保险 过程买保险是我见过最复杂、且坑点最多的产品了，17年时摸索了一个多月虽了解了一些知识，但总觉的不够透，刚好自己工作时曾经的好同事转行做保险经理人，于是就和她聊了这个事情。友情提醒，熟人间买东西要谨慎，不过还是要看人品，这个同事接触较多，和她也有一些争执，在争执过程你是可以感觉的到对方的真实态度的，所以我还是选择了她介绍的产品。 给小孩买保险家里老大已经3岁了，只是买了杭州市每年250的少儿医保，刚好二宝也出生了，所以给小孩买份商业保险。 同事给推荐产品有如下： 终身重疾险这个产品对于小孩不是必须的，如果资金不充裕可以不买 百万医疗这个应该很有必要买 意外险我没选择 定期重大疾病险和终身的区别在于保障时间短，但是保额高 参考的方案 最终选择的方案 同时也给侄女买了一份，算是给她的生日礼物了，总共三份 给老婆买保险丈人之前就给老婆买了两份平安福保险，这次顺便给她买了份百万医疗 给自己买保险无。 给父母买保险父母65岁了，能买到百万医疗就可以了，市面上没找到好的产品。 同事推荐了“众安尊享e生爸妈版”，赶紧给爸妈买了，妈妈之前做过脑膜瘤手术无法购买，爸爸身体还不错，购买成功了。因为是家庭版，所以顺便给姐姐也买了。 结论三个小孩、老婆、父亲、姐姐保险费大概一年4w左右。 保险不过只是一种额外的保障，如果希望自己家庭身体健康，那么科学的就医方式和每年的体检才是最好的方法，毕竟健康是金钱无法换取的。 父母一直很排斥去医院，认为每次去一是费钱、二是没病也看出病来、三就是害怕。第一次去体检阻力是很大，但是我改变下方法，说这个是给小孩买保险保险公司送的，他们虽不情愿，但也去了，体检报告出来也是这抱怨、那抱怨，就是一些老年病。 后来我又找借口说是公司福利费用减半等等，连续体检了3年，发现他们已经不排斥了，而且把每年的报告存起来，然后在平时生活中更加注意饮食和锻炼了。]]></content>
      <categories>
        <category>生活琐事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows切linux过程]]></title>
    <url>%2F2020%2F01%2F13%2Fwindows%E5%88%87linux%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[背景公司的服务一直是在windows下运行的，本身服务并不复杂，windows性能和稳定性表现也是不错的，有的服务器也快4年没重启过了，运行的还是挺好的。 这次切linux版本，原因只要是 技术的沉淀。服务端从windows到linux转变也算是一种趋势。 使用一些开源库。比如服务的管理、编排、治理…… windows下毕竟小众。 提升下主机性能、稳定性（这个没什么说服力）。 总之，就是要换到linux。 方案一之前的工作有过跨平台库的架构经验和开发经验，所以方案一无疑就是接口上的跨平台替换。主要是： 通讯库。 IOCP—&gt;boost::asio 数据结构。 CString/CMap —&gt; std::string/map 线程、锁。 _beginthreadex –&gt; std::thread/std::mutex 线程的消息队列。 postthreadmessage–&gt; 自定义消息队列 ini 配置文件的接口。 GetPrivateProfileInt —&gt;IniParser（开源库） 一些开源库。 如log4cpp、json、redis、rabbitmq、libcurl、protobuf、odbc…..本身就是跨平台的 公司原来的一些基础库 总之，难度不大，花点时间就行。 方案二在替换的过程中，搜到了一个中间件（winehq），官网的说明是这样的： Wine （“Wine Is Not an Emulator” 的首字母缩写）是一个能够在多种 POSIX-compliant 操作系统（诸如 Linux，macOS 及 BSD 等）上运行 Windows 应用的兼容层。Wine 不是像虚拟机或者模拟器一样模仿内部的 Windows 逻辑，而是將 Windows API 调用翻译成为动态的 POSIX 调用，免除了性能和其他一些行为的内存占用，让你能够干净地集合 Windows 应用到你的桌面。 也就是说，wine中间件将windows的一些函数通过posix接口模式实现了，只要wine xxx.exe 就能执行windows的可执行程序。于是就尝试了下，把一些过程记录下。 在centos 上安装wine 1234yum install epel-releaseyum install winewine --version安装成功 制作成docker容器，700M好大，搜了官网资料没找到如何裁剪 将进程的依赖库，如mfc120.dll 复制到linux目录中（windows的库不需要复制，如kernel32.dll) 将xxx.exe 复制到linux目录 执行 wine xxx.exe 喔哦，服务正常运行 剩下的就是如何后台运行？ 尝试使用nohup、disown命令，虽然可以在后台运行，但cpu却出奇的高（80%）。采用的方式就是使用screen start.sh1234567#! /bin/bashscreen_name=$&quot;hallsvr&quot;cmd=$&quot;wine hallsvr.exe&quot;screen -X -S $screen_name quitscreen -dmS $screen_namescreen -x -S $screen_name -p 0 -X stuff &quot;$cmd&quot;screen -x -S $screen_name -p 0 -X stuff $&apos;\n&apos; stop.sh1234#! /bin/bashscreen_name=$&quot;hallsvr&quot;cmd=$&quot;wine hallsvr.exe&quot;screen -X -S $screen_name quit cpu 稳定在8%左右。 异常、调试： 使用MiniDumpWriteDump可以保持minidump，也可以使用windbg分析这个dmp文件，但却不能保存fulldemp； 调试可以使用winedbg。 稳定性、功能性测试还在继续中，但我其实已经不推荐这个方式了，wine更适合用在有gui界面的程序，服务还是原生跨平台的更好。 总结方案一]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[电影评论]]></title>
    <url>%2F2020%2F01%2F10%2F%E7%94%B5%E5%BD%B1%E8%AF%84%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[最近一段时间在看一些影评，主要是 “大象放映室”和“阿斗归来了”。 其中“大象放映室”讲解的几部片子，看着看着就流泪，还是挺感触的，如果自己看电影不一定能感受的出来，但是听着她的讲解，眼泪就自然的流了出来。 初识不懂片中意，再看已是剧中人。]]></content>
      <categories>
        <category>生活琐事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[贫穷的本质]]></title>
    <url>%2F2020%2F01%2F10%2F%E8%B4%AB%E7%A9%B7%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[从10个角度讲解贫穷的本质，实际上，我们如果不注意，其实也会立刻变的贫穷。 不要试图鹤立鸡群，离开那群鸡是最好的选择。要真正脱离一个阶层，向上突破是非常困难的，经济、人际、精神，从微小的生活习惯到思想的意识形态要全面与之前原生态环境进行脱离，从这个意义上来看，学习和思考之路不管有多么艰辛，多么遥远，我们都要竭力前行，脱离贫困，这远比靠买彩票一夜暴富，更接近人生的进步状态。上坡是非常困难的，但下坡却快的多，即使你小步的上行，你也会觉的世界在抬高。不论脱贫的过程多么孤单，多么艰难，如果你觉的时机到了，就要坚定自己的信念、前行，脱贫觉不要回头。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[人生就像赶路]]></title>
    <url>%2F2020%2F01%2F09%2F%E4%BA%BA%E7%94%9F%E5%B0%B1%E5%83%8F%E8%B5%B0%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[在一个影评里面看到一段话，他认为人生就像赶路形容的不对，人生更像是在大河里漂着，不能上岸，不能停留，比赶路的自由度要低很多，不是说想加速就能加速，想歇会儿就能歇会儿，而且一个人遇到什么样的浪头，遇到什么样的河湾，是整条河来决定的。 想起这些话来，还是有点儿震撼。]]></content>
      <categories>
        <category>生活琐事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[让问题问到你为止]]></title>
    <url>%2F2019%2F12%2F26%2F%E8%AE%A9%E9%97%AE%E9%A2%98%E9%97%AE%E5%88%B0%E4%BD%A0%E4%B8%BA%E6%AD%A2%2F</url>
    <content type="text"><![CDATA[时间2019/12/24 总结无意间发现自己的书柜里有这本书，主要就是讲中层管理者应该如何激发每一个员工发挥最大潜能。 书本不厚，废话不多，3小时就能看完，但说的很有道理，比较浅显易懂的管理书籍，里面需要记小本本的知识点太多，所以就不概要了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[经常断线重连的问题]]></title>
    <url>%2F2019%2F12%2F12%2F%E7%BB%8F%E5%B8%B8%E6%96%AD%E7%BA%BF%E9%87%8D%E8%BF%9E%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[背景客服经常反馈说很多老游戏玩一会儿就会断开连接，而且这个问题只发生在移动端的一些老版本游戏。 原来的组网是玩家直接阿里云上的游戏服务器，后来因为安全问题，所以运维在中间加了一层HAProxy代理， 问题的反馈是在某几天集中反馈的。 分析过程在问题的分析过程中是遇到很多干扰因素的，但从事后回顾所有的现象，其实就是一种合理的工作方法，如果不梳理就会陷入一个死胡同。 当客户反馈问题时，他描述现象是正确的，比如某某游戏某某问题，某某游戏某某问题…… 运维在操作、调整之后也反馈 某某操作之后现象还是存在的…… 当这些事实摆在你面前的时候，从运维操作方式、用户现象会存在矛盾的地方，比如运维猜测可能是HAProxy的原因，所以把部分游戏切回到了直连模式，但仍然出现断线的问题（因为反馈的游戏太多，可能运维操作错了？） 一开始太着急把所有游戏的问题都归于一个原因是不对的，这时应该一个一个分析。 所以和客服沟通把反馈的游戏列出一个表格，然后我逐一复现。复现之后，和运维进行逐一排查，然后验证。事实上，我们发现了4个原因，而不是一个原因： HAProxy 保活时间60s太短了。 连接60s内无数据就会关闭链接。 阿里高防的策略配置。 游戏本身的bug,某个依赖服务刚好最近异常了。 某安全厂商提供的测试域名存在问题。 结论当问题集中反馈时，我们会陷入一种思维陷阱，这时就需要冷静的思考，通过假设-排查、再假设-排查 来查找问题。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[打印字符串的装饰器函数]]></title>
    <url>%2F2019%2F11%2F28%2F%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[背景经常因为打印日志时出现如下情况，导致程序崩溃： 123std::string strtest = &quot;this is a simple&quot;;printf(&quot;%s &quot;,strtest); --&gt; 正确写法应该是 printf(&quot;%s &quot;,strtest.c_str()); 方法为了解决以上的问题，让同事写了个装饰器函数，123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;string&gt;#include &lt;type_traits&gt;#include &lt;memory&gt;class va_in_convert &#123;public: template&lt;typename T&gt; const typename std::enable_if&lt;std::is_pod&lt;typename std::decay&lt;T&gt;::type&gt;::value, T&gt;::type * operator ()(const T* p) &#123; return p; &#125;&#125;;class va_out_convert &#123;public: const char* operator ()(const std::string&amp; s) &#123; return s.c_str(); &#125; const wchar_t* operator ()(const std::wstring&amp; s) &#123; return s.c_str(); &#125; template&lt;typename T&gt; const typename std::enable_if&lt;std::is_pod&lt;typename std::decay&lt;T&gt;::type&gt;::value, T&gt;::type &amp; operator ()(const T&amp; p) &#123; return p; &#125;&#125;;template &lt; typename CONVERT, typename RET, typename... ARGS &gt;class va_wrapper&#123;protected: RET(__cdecl *func)(ARGS..., ...);public: va_wrapper(RET(__cdecl *_func)(ARGS..., ...)) : func(_func) &#123;&#125; template &lt; typename... ARGS2 &gt; RET operator ()(ARGS... args, ARGS2&amp;&amp;... args2) &#123; return (*func)(std::forward&lt;ARGS&gt;(args)..., CONVERT()(args2)...); &#125;&#125;;template &lt; typename CONVERT, typename CLS, typename RET, typename... ARGS &gt;class va_wrapper2&#123;protected: CLS* cls; RET(__cdecl CLS::*func)(ARGS..., ...);public: va_wrapper2(CLS* _cls, RET(__cdecl CLS::*_func)(ARGS..., ...)) : cls(_cls), func(_func) &#123;&#125; template &lt; typename... ARGS2 &gt; RET operator ()(ARGS... args, ARGS2&amp;&amp;... args2) &#123; return (cls-&gt;*func)(std::forward&lt;ARGS&gt;(args)..., CONVERT()(args2)...); &#125;&#125;;template &lt; typename CONVERT, typename RET, typename... ARGS &gt;va_wrapper&lt;CONVERT, RET, ARGS...&gt; va_analyzer(RET(__cdecl *func)(ARGS..., ...)) &#123; return va_wrapper&lt;CONVERT, RET, ARGS...&gt;(func);&#125;template &lt; typename CONVERT, typename CLS, typename RET, typename... ARGS &gt;va_wrapper2&lt;CONVERT, CLS, RET, ARGS...&gt; va_analyzer(CLS* cls, RET(__cdecl CLS::*func)(ARGS..., ...)) &#123; return va_wrapper2&lt;CONVERT, CLS, RET, ARGS...&gt;(cls, func);&#125;#define va_in_wrap(func) va_analyzer&lt;va_in_convert&gt;(func)#define va_in_wrap2(cls, func) va_analyzer&lt;va_in_convert&gt;(cls, func)#define va_out_wrap(func) va_analyzer&lt;va_out_convert&gt;(func)#define va_out_wrap2(cls, func) va_analyzer&lt;va_out_convert&gt;(cls, func)class strscanf_helper&#123;protected: size_t sz; template &lt; typename T &gt; class strscanf_pointer &#123; protected: T** p; public: strscanf_pointer(T*&amp; _v) :p(&amp;_v) &#123;&#125; ~strscanf_pointer() &#123;&#125; void* operator ()() &#123; return p; &#125; &#125;; template &lt; typename T &gt; class strscanf_integer &#123; protected: T&amp; v; intmax_t im; public: strscanf_integer(T&amp; _v) :v(_v) &#123;&#125; ~strscanf_integer() &#123; v = (T)im; &#125; void* operator ()() &#123; return &amp;im; &#125; &#125;; template &lt; typename T &gt; class strscanf_float &#123; protected: T&amp; v; long double ld; public: strscanf_float(T&amp; _v) :v(_v), ld(0) &#123;&#125; ~strscanf_float() &#123; v = (T)ld; &#125; void* operator ()() &#123; return &amp;ld; &#125; &#125;; template &lt; typename T &gt; class strscanf_string &#123; protected: std::basic_string&lt;T&gt;&amp; v; std::unique_ptr&lt;T[]&gt; p; public: strscanf_string(std::basic_string&lt;T&gt;&amp; _v, size_t sz) :v(_v), p(new T[sz + 1]) &#123; p.get()[0] = 0; &#125; ~strscanf_string() &#123; v = p.get(); &#125; void* operator ()() &#123; return p.get(); &#125; &#125;;public: strscanf_helper(size_t _sz) :sz(_sz) &#123; &#125; ~strscanf_helper() &#123; &#125; template&lt;typename T&gt; typename std::enable_if&lt;std::is_same&lt;T, char&gt;::value || std::is_same&lt;T, wchar_t&gt;::value, strscanf_string&lt;T&gt;&gt;::type operator ()(std::basic_string&lt;T&gt;&amp; v) &#123; return strscanf_string&lt;T&gt;(v, sz); &#125; template&lt;typename T&gt; typename std::enable_if&lt;std::is_integral&lt;typename std::decay&lt;T&gt;::type&gt;::value, strscanf_integer&lt;T&gt;&gt;::type operator ()(T&amp; v) &#123; return strscanf_integer&lt;T&gt;(v); &#125; template&lt;typename T&gt; typename std::enable_if&lt;std::is_floating_point&lt;typename std::decay&lt;T&gt;::type&gt;::value, strscanf_float&lt;T&gt;&gt;::type operator ()(T&amp; v) &#123; return strscanf_float&lt;T&gt;(v); &#125; template&lt;typename T&gt; strscanf_pointer&lt;T&gt; operator ()(T*&amp; v) &#123; return strscanf_pointer&lt;T&gt;(v); &#125;&#125;;template &lt; typename... ARGS &gt;int strscanf(const std::string&amp; src, const std::string&amp; fmt, ARGS&amp;... args)&#123; return sscanf(src.c_str(), fmt.c_str(), strscanf_helper(src.size())(args)()...);&#125;typedef va_out_convert strprintf_helper;template &lt; typename... ARGS &gt;std::string strprintf(const std::string&amp; fmt, const ARGS&amp;... args)&#123; std::string s; int l = _snprintf(nullptr, 0, fmt.c_str(), strprintf_helper()(args)...); if (l &gt; 0) &#123; std::unique_ptr&lt;char[]&gt; tmp(new char[l + 1]); _snprintf(tmp.get(), l + 1, fmt.c_str(), strprintf_helper()(args)...); s = tmp.get(); &#125; return s;&#125; 然后就一劳永逸解决打印std::string 的问题了12std::string strtets = &quot;this is a simple&quot;;PRINTF(&quot;%s \n&quot;, strtets);]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网关服务的性能数据]]></title>
    <url>%2F2019%2F11%2F28%2F%E7%BD%91%E5%85%B3%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[网关服务是使用windows的完成端口实现的，当时一直有个疑惑，到底能支撑多少套接字的链接？查了些资料有的说3w、有的说4w，一直也没实践过。 最近刚好有个服务负载没调整好，数量上到了5w，借机可以看下服务的性能、消息饱和、内存都还不错。 从图中看到玩家数量持续上涨到5w左右，网关的cpu也就在40%左右，内存500M，消息转发几乎没有堆积， 4小时总共转发了800w左右的消息，服务句柄5w左右。另外这台机器的配置是阿里云 2 vCPU 4 GiB。 同时这台机器上还运行着 IMGate 网关服务，同样也是5w用户，5w句柄，内存、性能类似。 看上去一台机器运行两个网关服务视乎还不错。 PS:玩家数量上涨到5w左右就维持在5w左右了，其他服务器的用户数开始上涨，可能单进程5w左右是上限了吧]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[环球科学]]></title>
    <url>%2F2019%2F11%2F01%2F%E7%8E%AF%E7%90%83%E7%A7%91%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[环球科学杂志， 自己花钱从 http://www.freelian.com/ 买的，希望你也喜欢 链接：https://pan.baidu.com/s/1xqkqaInlU9imQzahfPum-A 提取码：qkbc]]></content>
      <categories>
        <category>杂志</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++代码静态检查]]></title>
    <url>%2F2019%2F10%2F31%2FC-%E4%BB%A3%E7%A0%81%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[背景之前出现一次程序crash，虽没什么影响，但定位到原因后发现其实是一个简单的笔误，肉眼还真一时看不出来，但是用静态代码检查工具还是能很方便的测试出来的。 于是就想检验下静态检测工具的作用。 方法在 vs2019的扩展中可以下载到 Visual Lint 这个工具（一个月试用版），安装后可以看到主流的C++静态代码检查工具： pclint pclint plus cppcheck google cpplint vera++ 并逐一验证（除了vera++），比较了下常见问题的效果。 top 1 ： pclint plus top 2 ： pclint top 3 ： cppcheck /google cpplint cppcheck/cpplint 没有仔细去研究详细的使用方法，只是写了一些常见错误，然后常见的操作，发现有的错误能发现有的错误不能发现，而pclint plus/pclint 全都能够发现。 pclint / plus 的优缺点plus优点：Gimpel 最新产品，Full support for recent versions of C and C++ including C99, C11, C++11 and C++14 C++18. 缺点： 暂时没破解，需要购买lic pclint优点：有免费下载缺点：新语法支持力度不够 个人使用操作了一段时间的plus ，整体和pclint用法差不多， 之前遇到一些boost、stl库的语法问题pclint就很难绕过去，现在plus 就没有问题了。 先这样吧，后续如果购买了lic 再把一些 plus 使用的细节写一下。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windbg分析内存泄漏（二）]]></title>
    <url>%2F2019%2F10%2F23%2Fwindbg%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景之前有讲过内存分析 [http://www.91dengdeng.cn/2019/05/07/windbg分析内存泄漏 ] 最近刚好又碰到一个问题，方式差不多，但过程复杂了些。 更新了一个版本，在后台的监控程序中可以看到内存一直在上涨，差不多1小时 100M左右。 方法 保存了dump，按照之前的方式查看 1234567891011120:000&gt; !heap -sSEGMENT HEAP ERROR: failed to initialize the extentionLFH Key : 0x52861f0bTermination on corruption : DISABLED Heap Flags Reserv Commit Virt Free List UCR Virt Lock Fast (k) (k) (k) (k) length blocks cont. heap -----------------------------------------------------------------------------Virtual block: 04360000 - 04360000 (size 00000000)003b0000 00000002 1473664 1460924 1473664 9013 3856 96 1 0 LFH005e0000 00001002 3136 1128 3136 604 7 4 0 3bd LFH External fragmentation 53 % (7 free blocks)00aa0000 00001002 256 4 256 1 1 1 0 0 堆块003b0000 提交了1.4G的内存 分析百分比 1234567891011121314151617181920212223240:000&gt; !heap -stat -h 003b0000 heap @ 003b0000group-by: TOTSIZE max-display: 20 size #blocks total ( %) (percent of total busy bytes) 2c00 545f - e805400 (16.93) ac17 9b7 - 687d371 (7.63) a417 559 - 36d7eff (4.00) a897 50f - 354d3d9 (3.89) a7fb 493 - 3006121 (3.50) a663 46b - 2df1761 (3.35) 9a17 49d - 2c6dc1b (3.24) ae97 3c9 - 294d98f (3.01) a817 3e4 - 28df97c (2.98) ada3 26c - 1a486c4 (1.92) 2800 9d3 - 188f800 (1.79) a797 221 - 164c877 (1.63) a697 20a - 153afe6 (1.55) a617 1e5 - 13aa993 (1.44) aa23 19b - 1112631 (1.25) aa17 193 - 10bc235 (1.22) a517 19a - 10866d6 (1.21) ae63 180 - 1059480 (1.19) 3000 518 - f48000 (1.12) a7ef 165 - ea304b (1.07) 和之前不一样，没有哪块内存占用空间特别大，所以猜测应该是大量大小不一的内存导致的内存泄漏。 打印所有内存块 123456789101112131415161718192021222324252627282930313233340:000&gt; !heap -stat -h 003b0000 -grp S 1000 heap @ 003b0000group-by: TOTSIZE max-display: 4096 size #blocks total ( %) (percent of total busy bytes) 2c00 545f - e805400 (16.93) ac17 9b7 - 687d371 (7.63) a417 559 - 36d7eff (4.00) a897 50f - 354d3d9 (3.89) a7fb 493 - 3006121 (3.50) a663 46b - 2df1761 (3.35) 9a17 49d - 2c6dc1b (3.24) ae97 3c9 - 294d98f (3.01) a817 3e4 - 28df97c (2.98) ada3 26c - 1a486c4 (1.92) 2800 9d3 - 188f800 (1.79) a797 221 - 164c877 (1.63) a697 20a - 153afe6 (1.55) a617 1e5 - 13aa993 (1.44) aa23 19b - 1112631 (1.25) aa17 193 - 10bc235 (1.22) a517 19a - 10866d6 (1.21) ae63 180 - 1059480 (1.19) 3000 518 - f48000 (1.12) a7ef 165 - ea304b (1.07) 40 391f9 - e47e40 (1.04) a987 146 - d7e1ea (0.98) a9a3 13c - d16534 (0.96) a5a3 142 - d05706 (0.95) b097 12b - ce405d (0.94) 9617 150 - c4fe30 (0.90) 1000 c3d - c3d000 (0.89) a763 12b - c380a1 (0.89) --- 内容过长省略（总共有600行） 也就是说差不多有600个内存大小的申请，数量都不大，但是加起来有1.4G，该怎么找呢？ 方法就是： 当内存上涨到 1.6G时，我们再打印一遍列表，然后比较1.4G和1.6G 两个的数量大小，比较下两者的差异，多出来的内存就是刚刚泄漏的内存。 结论 我对比了下，找到了一些怀疑点，然后通过1!heap -flt s a397 获取内存的地址，并再memory中查看内存的内容，通过内存的内容找到了代码的怀疑点，并修复。 这个问题代码review时还真看不出来，UwlConstructRequest是第三方库，也没有函数说明。 12345678910111213141516 LPCONTEXT_HEAD lpContext2 = NULL;LPREQUEST lpRequest2 = NULL;if (!UwlConstructRequest(buff.GetBuffer(), buff.GetBufferLen(), lpContext2, lpRequest2, m_pbKey, m_lenKey, m_flagEncrypt, m_flagCompress, m_nPacketSize)) &#123; LOG_ERROR(_T(&quot;data package error. data abandoned.&quot;)); return FALSE;&#125;REQUEST request;memset(&amp;request, 0, sizeof(REQUEST));request.head.nRequest = UR_GATE_TRANSMIT;UwlClearRequest(lpRequest2); // bug修复: 内存泄漏 。说明：UwlConstructRequest函数中申请了内存SAFE_DELETE(lpContext2);SAFE_DELETE(lpRequest2);]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[程序员的数学-概率统计]]></title>
    <url>%2F2019%2F09%2F30%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%95%B0%E5%AD%A6-%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[时间2019/09/25 摘要概率是一种面积已上帝视角看待每一个平行世界。 （上帝视角）—–&gt;完全确定的面积问题 —-&gt;面积的答案 （人类视角）—–&gt;结果不确定的概率问题 —-&gt;概率的答案 随机变量 联合概率 ： P（x=a,y=b) 边缘概率 : P（x=a) 或 P(y=b) 条件概率 : P(x=a|y=b) :在条件y=b下x的条件分布 1P(A,B)=P(A|B)*P(B)=P(B|A)*P(A) 贝叶斯公式: 应用条件概率来解决逆问题。 1P（A|B)=P(B|A)*P(A)/P(B) 1234通信：根据含有噪声的接收信号Y推测发送信号X语言识别：根据麦克风识别音频波形数据Y推测语言信息X文字识别：根据扫描仪读取的图像数据Y推测用户书写的文字X邮件自动过滤：根据接收到的邮件文本Y推测邮件的类型X（是否是广告等） 独立性：多个随机变量之间是否真的存在关联 离散 期望值 E[X] （或 μ） : 所有世界每次可能的结果乘以其结果概率的总和。 方差：V[X]=E[(X-μ）*(X-μ)] 标准差： 方查的开方 平均数和期望值的区别： 期望值是多个平行世界的观测结果，因为生活在某一个平行世界的人类无法知晓该值。 平均值测量的是一个特定世界的值。 然后，手握大数定律后，即使我们只能观测某个特定的世界，只要观测平均值，就能知晓只有上帝才能观测的期望值μ。 是不是很神奇？ 正态分布与中心极限定律 练习题1 使用林德伯格定理： 练习题2 使用拉普拉斯定理 123现抛掷一枚正反概率恰好各为一半的硬币100次，估计正面朝上的次数小于等于60次的概率。（60-100/2）/根号(100*1/2*（1-1/2) = 2， 标准正态分布查表θ(2)~~0.982]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[How It Works 2018]]></title>
    <url>%2F2019%2F09%2F29%2FHow-It-Works-2018%2F</url>
    <content type="text"><![CDATA[《How It Works 2018》 电子版 107期链接：https://pan.baidu.com/s/1yAgqDic9dCwlIdvNSGYDDA 提取码：3q5v 108 期链接：https://pan.baidu.com/s/1Gw4JPVFdc85h3icwbXmHpw 提取码：uqh5 其他的联系我]]></content>
      <categories>
        <category>杂志</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事故报告（2019/09/03）]]></title>
    <url>%2F2019%2F09%2F26%2F%E4%BA%8B%E6%95%85%E6%8A%A5%E5%91%8A%EF%BC%882019-09-03%EF%BC%89%2F</url>
    <content type="text"><![CDATA[时间2019/09/03 06：00 事故描述 部分老app玩家无法登陆 部分业务无法使用 事故原因早上升级了版本，其实就改动了两处地方，评估应该是没有问题的。 所以出现问题时都觉得不可以思议。 第一处 登陆时多返回了一个其他消息号的消息，在测试和预发环境中验证都没有问题，而且也review过当前客户端代码，客户端对于不识别的消息号是会做丢弃处理（这个也是业界默认做法）。 结果在更老的app版本居然不是这么设计，如果识别到无法识别的消息号，app直接拒绝所有的消息（多么反人类的设计） 第二处 比如有两个逻辑处理的地方， 原来代码是 a 的地方多加了一次，b的地方多减了一次，结果在处理某业务时，刚好 a+b，负负得正，业务正常。（开发b模块的人，难道不想想为什么要多减一次吗？） 我在修复另一个代码逻辑时，发现a的逻辑有严重错误，导致了其他业务无法使用，于是就修复了 a 的多加一次bug，结果就是 导致执行了b的某业务 出现了异常。 处理方式两个问题都比较懵。先在线上进行回滚，然后实验室进行修复。 总结没什么好说的，自己还是偷懒了， 测试不够全面。]]></content>
  </entry>
  <entry>
    <title><![CDATA[事故报告（2018某月）]]></title>
    <url>%2F2019%2F09%2F26%2F%E4%BA%8B%E6%95%85%E6%8A%A5%E5%91%8A%EF%BC%882018%E6%9F%90%E6%9C%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[时间2018年某月 事故描述半夜某业务操作超时 事故原因业务操作mysql，表中存储了历史大量数据，查询速度变慢。 说这个问题，是因为临时接手项目，代码都不熟悉，突然来一个线上问题，头皮发麻，只能半夜打开电脑，现场看代码，用户又催的急，还好代码结构清晰，又有其他项目组员查看相关模块日志。 数据库设计时有定时清理功能，但是没想到业务发展快速超过了当时的设计速度，所以清理没有跟上，导致sql查询变慢，cpu 100%。 手动进行强制清理，问题修复。 总结良好的编码习惯，清晰的代码逻辑 是一个优秀工程师的重要素质。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何培养孩子主动阅读的兴趣]]></title>
    <url>%2F2019%2F09%2F24%2F%E5%A6%82%E4%BD%95%E5%9F%B9%E5%85%BB%E5%AD%A9%E5%AD%90%E4%B8%BB%E5%8A%A8%E9%98%85%E8%AF%BB%E7%9A%84%E5%85%B4%E8%B6%A3%2F</url>
    <content type="text"><![CDATA[来源少年得到《泉灵的语文课》 摘要 环境 1所谓的读书环境部仅意味着有适合孩子读的书，更意味着这里是一个读书的氛围。 让孩子有自己选择读哪一本的权利 1家长再这个过程中是可以有引导的，也包括要教给孩子一些如何选择书的能力和技巧。 适龄 12在合适的年纪读适合的书，而不是字词句的难度。比如12岁是小孩人生观形成时期，看一些任务传记或面向未来的书籍，那么这些了不起的人物的精神可以影响到小孩 增加回路 123孩子在阅读之后如何能获得正向反馈，并且成为他继续主动阅读的驱动力。在我看来，孩子被表扬远不如他有机会能教你点东西。请记住移动要是他能够教你和分享的状态，而不是被家长考试。]]></content>
      <categories>
        <category>音视频摘要</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[格蠹汇编]]></title>
    <url>%2F2019%2F09%2F20%2F%E6%A0%BC%E8%A0%B9%E6%B1%87%E7%BC%96%2F</url>
    <content type="text"><![CDATA[时间2019/06 作者的书我基本都买了，对我工作帮助很大。 书籍偏windbg的技术，1是学习一些windbg方法，2 主要是学习思考方式和分析方法。 收获良多，应该会持续持有。 比较专业，笔记都记在书籍里面，这里就不摘抄了。 还有本月看了他的新书《软件调试 第二版 卷一 硬件基础》，收获也很多，有些疑惑之前在网络上没有好的答案，这里能够得到很好的解答。 之前看的老版《软件调试》 主要将操作系统层的一些知识，使自己瞬间技能提升很快，书都快翻烂了， 非常期待后续的卷二、卷三。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[有意思的话]]></title>
    <url>%2F2019%2F09%2F19%2F%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[牛x之后就是傻x 人生有四然:来的偶然，去的必然，尽其当然，顺其自然 英雄创造历史 庸人繁衍子孙（三个枪手的博弈），做人要“优秀且低调”]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[北洋水师军歌]]></title>
    <url>%2F2019%2F09%2F19%2F%E5%8C%97%E6%B4%8B%E6%B0%B4%E5%B8%88%E5%86%9B%E6%AD%8C%2F</url>
    <content type="text"><![CDATA[载自《循迹漫聊》：北洋水师 宝祚延庥万国欢， 景星拱极五云端， 海波澄碧春辉丽， 旌节花间集凤鸾。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[摩托增驾攻略]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%91%A9%E6%89%98%E5%A2%9E%E9%A9%BE%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[杭州2018年新的禁摩政策实施后，虽然主城区还是禁摩，但比以前温和多了，只要不是改装、扰民、违章（闯红灯、随意变道…），只要你有驾照、戴头盔， 交警也会睁只眼闭只眼，就算被栏，只要驾照在手，就罚50，不像以前会扣车。 所以有个摩托驾照是很重要的。 我在15年因为心血来潮将驾照增照到C1D，陆续也有一些人问如何增摩托车照，所以简单说明下。 楼主是在萧山的捷达驾校报名的，主城区也有但是比较麻烦，相比起来萧山的就方便多了。当时的价格是1100（大致），报名后需要按约定时间考理论，然后两个半天的现场学习，再加一个半天的考试，总共耗时：报名：路程来回1小时+报名2小时（材料准备不全，来回打印）理论： 路程来回1小时+考试1小时现场学习第一天： 路程来回1小时+学习2小时现场学习第二天： 路程来回1小时+学习2小时考试： 路程来回1小时+考试2小时+拿驾照2小时总时间 = 16小时，总花费 = 1300左右。 驾照到手，就是买摩托车了， 自己是新手从来没骑过，所以也不敢买大排，然后预算也有限，所以当时考虑就是 &lt; 200 cc 的摩托， 看中的是春风150nk、本田的cb190。最后我是从闲鱼上买的二手春风nk150， 注意杭州市主城区户口无法上牌，其他区可以（比如萧山、余杭），最后找了老爸的身份证办了暂住证然后上牌，从余杭走九堡大桥、机场高速然后到萧山。 “二轮载灵魂四轮载肉体”， 骑行的保护还是要注意，头盔必不可少；不追求速度，通勤才是我最大的需求，所以250cc 以内就足够了，我现在连150cc都不想骑，踏板车才是最适合我的。 春风150nk已经被我出售了，主要问题是 国产质量还是差一点。小毛病搞的你心烦，有次晚上载lp去看电影，看玩之后前轮莫名奇妙锁死，大半夜找不到修理的，结果两个人还得走路回家。第二天推着车走了1km 找个电瓶车店，拧下螺丝就好了； 有一次摩托骑到路中间，刚好红绿灯，结果突然熄火，绿灯了被后面汽车喇叭吹死，硬着头皮，重新点火….. 终于在30s后启动；…… 所以很心烦。 没有踏板方便。没法买菜啊，想想看手上提着蔬菜的袋子，放在把手上来回晃荡，不够帅气。 排量低，推背感不强。 起步不够暴力。 杭州适合骑行的天气太少。冬天太冷、夏天太热。一年才骑1000km。 综上所述，要么来点暴力点的、要么通勤方便点。 总体来说买辆质量好点的踏板（比如本田or雅马哈），比电瓶车还是要方便的。]]></content>
      <categories>
        <category>生活琐事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[春节杭州自驾游到福建]]></title>
    <url>%2F2019%2F09%2F18%2F%E6%98%A5%E8%8A%82%E6%9D%AD%E5%B7%9E%E8%87%AA%E9%A9%BE%E6%B8%B8%E5%88%B0%E7%A6%8F%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[不想宅在家2017年过年不想宅在家，浙江周边还没怎么去过福建，所以规划下行程自驾游去福建省。 旅游景点福建有名的景点还是很多的，那么如何规划路线呢？ 去程 武夷山推荐酒店：观景山台度假村 南靖土楼守望客栈（土楼房）、 茶之韵（高级民宿）白天可以早点去看“四菜一汤”，然后乘别人来看景点时，我们刚好回去。南靖土楼道路条件限制，道路很窄，超级堵，所以早点离开为妙！！ 回程去程兴致勃勃，但是经历堵车、排队…… 等考验后，回程其实已经没有玩的兴致了。所以就选了霞浦作为最后一战。在非景点游玩反而来的舒坦，早起看看滩涂、日出，晚上吃吃海鲜大排档，睡睡舒服的房间，反而轻松了很多！！ 厦门（放弃，人多，之前去过了） 泉州（看时间） 福州 （看时间） 霞浦 （看滩涂，吃海鲜）住宿：帝景国际。 路程基本就是途中的 去程： 推荐（1） 回城： 方案（2） 总结累，以后再开车那么远是小狗]]></content>
      <categories>
        <category>走走看看</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[东京游（三）：东京]]></title>
    <url>%2F2019%2F09%2F18%2F%E4%B8%9C%E4%BA%AC%E6%B8%B8%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E4%B8%9C%E4%BA%AC%2F</url>
    <content type="text"><![CDATA[day1东京大学10年前老婆在这里留学毕业，所以东京游玩必须要来的。 感受下日本第一学府的气息，逛逛校园，打卡地点：安田讲堂、三四郎池。 上野公园带着小孩在公园里划船，和老外打招呼、比赛玩的很开心。 中午寿司店外带，坐在公园里边看、边聊、边吃。 上野动物园人、动物相处的非常和谐 东京国立博物馆一般！毕竟我们祖国历史辉煌，这里没太多的看点。 武士大铠，身体不大。 day2巨蛋游乐场出门时小孩看到摩天轮在营业，迫不及待的要去玩，所以就在酒店附近的这个巨蛋游乐场玩了一上午。感觉上东京游乐场价格和国内差不多。摩天轮一圈大概30分钟850日元。 浅草寺风雷神门 东京晴空塔没有去东京塔。从高处往下望，东京的街道车并不多。 day3~day4箱根day5~day6新宿逛街、买买买 总结总体来说，东京游玩我给9.0分，十分满意。不足的就是 吃的不爽。早饭没什么吃的 优点就很多了： 非常有礼貌 人多而不乱 公共厕所非常多 空气很好 街道很干净，车也很干净 到东京玩，不需要安排太多景点，就是在街上漫无目的的逛逛、看看街头艺人的表演，都是非常惬意的！]]></content>
      <categories>
        <category>走走看看</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[东京游（一）：准备]]></title>
    <url>%2F2019%2F09%2F18%2F%E4%B8%9C%E4%BA%AC%E6%B8%B8%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[准备工作机票双12在全日空官网订购了明年4月份杭州到东京的来回机票，2大1小含税6309. 签证过年回来，准备了三年多次的签证，找的淘宝商家。 这之间出现了一个小插曲：购买机票时，我没有看老婆的护照，所以在填写姓名时，“吕”的拼音我就写成了“lv”。同时我老婆护照过期，需要重新办理，新的护照“吕”已经修改成了“lyu”，而老的护照“吕”的拼音是”lu”, 新老护照和“lv” 完全没有关系，所以解决办法有两个： 在新的护照上加注：”lv”、“lu” 和全日空沟通修改姓名 最后采用的方法是 2 ， 打电话给全日空的客服很快就搞定了。 电话卡淘宝买7天7G的流量卡，大概40左右（softbank运营商）淘宝买7天7G的流量卡，大概70左右（达摩运营商） 在东京两者信号没区别，只是去箱根，达摩信号比softbank好。 微信、钉钉、googlemap 都可用。流量完全足够用。以上都是无法打电话的，只能用app语音通话。 交通东京交通是比较复杂的。日本有jr、地下铁、skyline、急线，而且是私营，你有时候会奇怪，我仅仅是地下铁换乘，为什么还要出站刷一次，然后再刷一次进站？ 不用太细的研究，最关键是把机场—&gt;酒店，酒店—–&gt;机场 路线搞清楚，至于在市内的乘坐办一张西瓜卡，然后带上google map 就可以了。 1酒店位置的选择比研究交通路线更关键。 已我为例：第一天的酒店(里士满水道桥酒店） 成田机场出站（10min） 转skyline到日暮里（45min） 日暮里转jr到秋叶原（6min） 再转jr到水道桥（6min） 最后一天的酒店（新宿格拉丽斯酒店） 新宿jr山手线到日暮里 （20min) 日暮里坐sky line 到成田机场 (45min) 现金只有在中国人购物比较多的商场、药妆店才支持支付宝、微信。 大部分的地方比如吃饭、酒店、买车票只支持现金、信用卡。 所以携带合适的日元还是有必要的。 酒店先订好游玩的目的： 玩 东大 上野公园 上野动物园 东京国立博物馆 箱根 浅草寺 台场 购物 新宿 涩谷 所以我选择的酒店在上野附近、新宿附近。 语言不会日语是没有关系的，会点英语，有google 翻译app就可以。 优惠券不太需要提前准备。 在购物时拿出大众点评，看看附近的优惠券，基本药妆店都是8%免税+5%的优惠 在商城购物，结账时问问店员有什么优惠，都会很热情的告诉你。 白金卡、支付宝的铂金会员有点用处，我在新宿三越伊势丹商场买东西，以上可以有5%的优惠。 小孩推车如果是带小孩出去玩，那么推车很有必要。 购物地点新宿、御殿场奥特莱斯。 这两个地方已经足够满足购物需求了。 全日空单个行李最大公斤数这点我没注意，东西都塞在一个大箱子里，结果超重了，需要6000日元运费。 全日空单个行李（不管乘客数量）最大是23KG。]]></content>
      <categories>
        <category>走走看看</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[东京游（二）：箱根]]></title>
    <url>%2F2019%2F09%2F18%2F%E4%B8%9C%E4%BA%AC%E6%B8%B8%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%AE%B1%E6%A0%B9%2F</url>
    <content type="text"><![CDATA[准备因为主要是去泡温泉，所以预定了箱根汤本富士屋酒店。 也是因为准备不足，所以游玩的安排并不合理。 游玩的官网 https://www.odakyu.jp/sc/sightseeing/hakone/ 路线从新宿站乘坐小田急“浪漫”特快 75分钟到达箱根汤本站。 在新宿站购买了两天的周游券，并领取“小田急箱根交通指南”。 游玩路线按照“小田急箱根交通指南”推荐的黄金路线： 箱根汤本—&gt;雕刻之森—&gt;强罗—-&gt;早云山—-&gt;大涌谷—&gt;桃园台—&gt;箱根町港—&gt;箱根汤本 这样一趟下来，大概3小时，全程基本很少走路，不会累，风景很好！ 然后回酒店泡温泉。 注意：箱根的交通工具18：00基本就停止了，而且商店18：00也基本都关门了，太晚就只能去便利店买泡面。 第二天计划去御殿场奥特莱斯，但是时间上却来不及了，只能在箱根汤本附近简单的玩玩并匆匆的赶回新宿。 里面的一些不重要景点比如小王子博物馆、玻璃之森等看个人兴趣吧，我是不推荐。 所以2天箱根游，合理安排好行程是有必要的。 仔细回想，如果既要泡温泉，又要购物，又要看到富士山，那么当天的酒店应该安排在御殿场附近最为合适。当天从箱根出发、泡温泉、玩玩主要景点，然后回到御殿场的酒店，好好休息，准备第二天奥特莱斯的shopping，然后乘坐“浪漫”特快回到新宿。 如下是箱根的主要景点位置 PS：箱根所有景点都是有交通工具可以到达的，具体乘坐方法见”小田急箱根交通指南”。购买了”箱根周游券”，箱根的所有交通费用都不需要额外购买。 泡温泉日本泡温泉有一些礼节需要注意，重点就是只让干净的身体进入温泉中。温泉温度有点高，一般也坚持不了多久，30~40分钟就足够了。]]></content>
      <categories>
        <category>走走看看</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小孩发烧-感冒]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%B0%8F%E5%AD%A9%E5%8F%91%E7%83%A7-%E6%84%9F%E5%86%92%2F</url>
    <content type="text"><![CDATA[女儿不省心4岁的女儿放寒假来杭州陪弟弟玩。爷爷奶奶带上孙女、孙子出去玩，好开心，但是糟心的事情马上就来了。午睡醒来后女儿说头疼，没力气。我神经立刻紧张，我去，刚来就发烧，拿耳温枪一量，38度，真的发烧了。上午来的时候还好好的，出去玩了一会回来就发烧。是 感冒、还是流感、或者东西吃坏了…… 然后从能知道的蛛丝马迹中猜测原因，估计应该是感冒或者流感。&lt;小孩发烧（1）&gt; 中两次去省儿保的经历我记忆犹新，一般毛病不敢去啊！ 123普通感冒是自愈性疾病，没有特效药，没有特效药！！只要多喝水、多休息 一般7天就会自愈。一般去的县城医院医生会额外开一些中成药，比如xxx感冒颗粒，甚至有的直接挂盐水，其实没必要，非但没有效果，反而对小孩身体造成了负担。 如果是流感，常见流感48小时之内使用达菲还有效果； 因为病情初发，还不能确认是感冒还是流感，贸然前去省儿保，一家人累不说，而且还可能交叉感染。目前当务之急是给女儿带上口罩，限制她的活动范围，安抚情绪，带上头贴，以免脑部温度过高；还有管好儿子避免传染。先观察一天再看….. 到底是感冒还是流感？ 当天晚上和女儿一起睡觉，期间给她喝水、讲故事，睡着后，间隔一段时间就帮她量体温，温度一直在38-39度之间徘徊，心里也是焦灼。第二天温度并没有退去，但从病情症状上看，应该是普通感冒，心里稍微放心。第二天还是在家，没有去医院，只是照顾两个小孩真的是很累。第三天女儿温度降到37.4左右，精神也好了，大家正想放松，哪知儿子刚喝完奶准备睡觉时，状态不对，拿耳温枪一量，我去，38.5度。天啊1234# 儿子不省心儿子年纪小，体质没有女儿好。一周左右的时间发烧反反复复，第三天温度还&gt;39.5，奶奶征求了我的意见，喝了一次美林。 病毒、病菌入侵会刺激细胞释放出前列腺素E2。E2会把“正常体温”的设定值给调高了， 让身体觉得体内热量不足，于是就要增加产热和减少散热。美林能够抑制前列腺素E2的合成，所以是有效的退烧药。但是无法抵抗病毒。小孩什么时候喝美林，国内、国外有很多说法，我一般是在&gt;39度时看小孩身体状态，是否还精神。12儿子喝了美林之后，出了一身汗，人也精神了。按照规律，活泼2个小时之后，病毒又会继续入侵，温度继续升高， 吃了退烧药，或者病好了，体温恢复正常， 身体需要把多余的热量散发出去，就会出汗。所以退烧会导致出汗，但是许多人却本末倒置，以为是出汗导致了退烧，所以平时都是这样的土方法：发烧后多穿衣服，多盖被子，捂出汗来病就好了。这些土方法是不对的。123但这次居然一天温度都没有升高，维持在37.3左右，心想病终于好了。然后按照原定计划，年前全家去宁波老家过年，出发时儿子手舞足蹈，但开了100KM，发现儿子又变焉了，温度一量，39度，在服务区休息，透透风，没有喝美林，温度稳定在38-39之间。这样总共过了6天，温度时高时低，一般白天在37~38之间，晚上睡觉&gt;38度。终于在第6天还是去宁波妇儿医院检查一下。排队2小时，看病2分钟。抽了血常规， 超敏C反应蛋白 23白细胞 6.3~~~医生开了“头孢克肟” ，我问可以不吃嘛，医生说6天都没扛过来，还是吃点吧。吃了两天，就好了。 总结每个小孩在成长过程中，或多或少都会发烧；其实生病去医院是很稳妥的，但是大城市的三甲医院你带个小孩去试试？人乌泱泱的，时间是其次，重要的是怕被其他小孩传染。所以掌握一些知识，在陪伴、等待期间也会淡定一些。]]></content>
      <categories>
        <category>生活琐事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小孩发烧-肺炎、哮喘]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%B0%8F%E5%AD%A9%E5%8F%91%E7%83%A7-%E8%82%BA%E7%82%8E%E3%80%81%E5%93%AE%E5%96%98%2F</url>
    <content type="text"><![CDATA[2019.5.20登登最近咳嗽，因为不是大毛病，所以就没有带去大医院，而是去了社区医院。实在是被大医院搞怕了，排队2小时，看病5分钟.在社区医院，医生听了听胸部，看了喉咙，并化验了血常规和超敏c（社区医院这点就是方便）。社区医院的诊断是，“喉咙有痰，肺部没有发炎，但是如果不化痰，就会导致肺部发炎，建议我们做两天雾化，并口服阿奇霉素“。 但是我考虑咳嗽也还好，而且也没炎症，加上1岁小孩雾化估计不肯做，所以就没有坚持下去，就把孩子抱回去了。 2019.5.26之后一周白天还是有咳嗽，但是到周末早上突然咳嗽严重了， 下午午睡后还出现了发烧现象（38.8度），晚饭就送到省儿保医院。结果是：血常规、超敏都正常，但肺炎是有的，需要挂两天盐水、两天雾化，两天后再来复查。 两天后复查结果，呼吸还是可以听到啰音的声音，还需要继续挂两天。 又两天复查，医生听了声音但还存在杂音，所以需要再挂两天。因为使用的是进口的阿奇霉素，所以最多可以挂7天。 附 ps：现在儿保可以手机挂号，而且也有临时停车场，方便了很多。 ————————————————— 后续 ——————————————————— 2019.06.01事情远比想象中的要复杂，7天的阿奇霉素+甲强龙激素，是大部分咳嗽和气喘的有效治疗方法。但是当我们第七天准备去复查时，小孩突然又发烧了，这就比较麻烦了。 所以医生怀疑是否感冒或流感导致，接着就是化验流感病毒、血常规，结果还是正常的。医生就说先挂两天头孢+甲强龙（因为进口阿奇霉素只能使用7天），心中充满了疑惑也只能这样。 又过了两天，挂了儿保专家号，医生看了之后还是很明显的喘的声音，所以继续用药两天头孢+甲强龙。 2019.06.05过了两天，继续复查，小孩还是有明显的湿罗音，所以甲强龙不敢停，并建议我们留院观察，同时去住院部进行排队预约。 接着就是住院预约，同时去急诊的留院观察室排队安排床位（没经验）。折腾了3个多小时，总算搞到了留院观察室床位，其实也没什么事，就是观察下小孩病情，如果没有好转，就直接转住院部，比预约排队快。所以在观察室呆了两天，第二天晚上11点收到通知让我们进住院部。 2019.06.06进入住院部，就是全面的身体检查，剩下的就交给医生了，期间ct、支气管镜都做过。住院在做常规性检查时ppd检查阳性(大小10mm左右，无水泡），心里一阵难受，说明是有结核菌感染，也可能是卡介苗引起的，还得继续t-spot检查；一周的等待真是煎熬，还好结果是“阴性”，但查了相关论文，也有可能是假阴性，每年ct观察吧。总之只要肺部没有出现结节，就不是肺结核，最差打算即使是肺结核，按时吃药也是可以的，只是对肝功能会有损失，这么小的小孩想想都觉得可怜。 2019.06.13住了7天，终于出院，得出的结论是“急性肺炎，哮喘未知”，一周内复查。出院时小孩基本没有喘的声音了，是否有哮喘还要继续观察，还是有东西悬在心头。 2019.06.18名医复查，炎症没有了，哮喘没有了（医生建议还是观察，因为家族没有过敏史、没有鼻炎，医生对于这次哮喘这么严重仍不能确定原因）。 医院检查存在副流感iii 病毒，可能是这个引起。回去继续吃“特鲁斯含片”，不用来复查了。如果出现咳嗽等症状，在家或者卫生院做做雾化。]]></content>
      <categories>
        <category>生活琐事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DevOps开发运维训练营]]></title>
    <url>%2F2019%2F09%2F10%2FDevOps%E5%BC%80%E5%8F%91%E8%BF%90%E7%BB%B4%E8%AE%AD%E7%BB%83%E8%90%A5%2F</url>
    <content type="text"><![CDATA[时间2019/9/10 人1234567作为经验分享，我认为培训人员适应新的文化非常重要，这是一场需要耐心的博弈。我们不能在一夜之间改变人们的思维方式，在改变文化之前首先需要理解。在行业中往往能看到，文化的改变从DevOps知识或是DevOps工程师开始，应该逐步改变现有环境。我们不需要一个专门的DevOps团队，需要的是开发人员、测试团队、自动化实现人员和云或基础设施团队之间的更多沟通和协作。让所有人都理解彼此的痛点是必不可少的步骤。 知识快餐DevOps概念与评估框架 devops 的必要性 如何发展devops文化：敏捷、Devops PPT：人、过程和技术的总要性 持续集成容器云计算与配置管理持续交付自动测试（功能和负载测试）编排安全和监控DevOps文化评估–&gt;构建自动化-&gt;持续集成-&gt;云配给-&gt;配置管理-&gt;持续交付-&gt;持续测试-&gt;持续部署-&gt;部署编排-&gt;持续监控-&gt;持续反馈-&gt;持续改善-&gt;持续创新]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[云主机网关切换]]></title>
    <url>%2F2019%2F09%2F05%2F%E4%BA%91%E4%B8%BB%E6%9C%BA%E7%BD%91%E5%85%B3%E5%88%87%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[背景之前网关服务器都部署在华东阿里云，为了提供玩家的登陆体验，所以需要在中国几个大区进行分区部署网关。 使用dnspod域名智能解析。 分区 分区前和分区后的数据对比 总结得出一套服务地区分布式部署（代理）的方法，对节点性能提升有一定帮助。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[香港卡申请]]></title>
    <url>%2F2019%2F09%2F02%2F%E9%A6%99%E6%B8%AF%E8%B4%A6%E5%8F%B7%E7%94%B3%E8%AF%B7%2F</url>
    <content type="text"><![CDATA[早两年前研究了见证开户，最终选择中国工商银行的工银亚洲，于是跑到网点排队预约，条件是： 50w理财 港澳通行证 排队3个月 虽然没有50w但我也答应了，因为到时办不办再决定。 3个月后，工行如期电话通知是否办理工银亚洲，但苦于手头没现金，就放弃了。 现在突然又想办工银亚洲，于是又打电话咨询，结果告知：18年底政策调整，只有持有香港长期签证的才可以办理，像我这样只有港澳通行证是不能办理的。 于是网上查找，联系了民生银行，条件： 境外长期签证（不限香港） 5w理财 无实体卡，只有电子卡 账户管理费（境外卡）1w以上：10港币/月 之前刚好办理了日本的三年签证，刚好用的上，于是直接就去现场办理了。 民生银行办理还是很快速的，就按照现场员工指导你一步步办理即可，总共耗时50分钟，一周后审核通过。]]></content>
      <categories>
        <category>走走看看</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[丈人过世]]></title>
    <url>%2F2019%2F08%2F29%2F%E4%B8%88%E4%BA%BA%E8%BF%87%E4%B8%96%2F</url>
    <content type="text"><![CDATA[丈人是在8月22日8：58离开人世的，我从杭州赶回去在旁边陪伴了最后的几个小时，第一次近距离的感受了一个人在最后时刻的状态。 丈人在三年前查出肝癌晚期，找了国内最好的医生进行了肝移植，开始两年控制的还算可以，吃吃药、定期检查，到了最近一年，肝功能损坏，医生建议第二次移植。家里人毫不犹疑的选择了二次移植，可是这一年过非常艰辛，icu待了几个月，期间多种细菌交叉感染，出国买进口药…… 费用也用的很多，这三年除去报销，还自己花费了3百多w。 这一年的治疗过程中，我深深的感受到“久病无孝子”给人带来的现实感触。久病的人一是拖累家庭经济，二是拖累家庭神经。 家庭经济比较简单，大部分家庭，icu每天1w的治疗费，而且看不到离开icu的希望，有几个人能支撑的下来呢？ 好多都是子女辞职全职照顾的，那卖房、卖地的就很多了。 家庭神经是自己随便取的，因为扛过了经济上的压力，你还要煎受每天化验、发烧、护理、发脾气……等多方面精神上的考验。 工作忙碌后难得一天休息、孩子考了好成绩难得高兴…… 突然化验单指标异常、或出现发烧症状，全家就陷入恐惧； 肝病的人很容易发脾气，或者说是因为病房呆太久了，也很容易发脾气，比如饮食照顾不周、护理不够细致，就会发脾气，生气又容易伤肝…… 所以一年的时间都在担心害怕中度过，没有任何娱乐，因为高兴不起来。 这一年的艰辛没有体验过的人永远体会不到。 这一年的坚持就是对人性的考验，我们也不知道是否还能继续坚持多久。 对人最打击的是这种无望，看不到终点…… 丈人一年经常说的话、写的字就是“回家”，可是病情没控制住，不能随便回家。最终在病情控制不住的时候，我们决定还是回家住一天，然后再送到当地人民医院。 丈人终于在20号的时候回了家并住了一晚上，也算了了一个心愿，然后转移到当地人民医院等待最后的时间。 23日在丈人旁边陪伴了几个小时，肝癌细胞这几年一直都没有扩散，长期的使用抗生素身体内多种细菌感染导致组织受损，导致丈人身体很虚弱，除了呼吸、睁眼，几乎没有任何多余动作，有几次努力的想说话，但也只发出了“哼”的声音；努力的转动眼睛，希望能多看这个世界、能够多看自己的亲人，可是瞳孔变小，也几乎看不到； 大口的呼吸，希望能够多留一段时间；最后丈人还是安详的去世了，带着对人世的留恋、对亲人的爱，也带着遗憾离开了。 很多人知道生命很重要，但很难体会生命有多重要，只有在生死最后一刻，才突然认识到”活着”比什么都重要。 一个人代表的不单单是一个人，而是一个家庭，伤害自己其实就是在伤害家庭，可很多人却不明白这个道理。 最后陪伴的那段时间里，我再想如果换做我是丈人，此刻会在想什么呢？ 回望自己的人生印象最深的事情是什么？ 结婚、生子、事业…… 35年的记忆快速的从脑海中翻过，很多事情虽然有简单的记忆，但只有向求婚、生子的时候还记得一些细节。 遗憾：会有什么遗憾呢？ 还有好多话没有和家人说；还有好多事情没去完成； 人生啊！ 遇到高兴的事情，就全身心的去体会这种快乐，并写写日记去把这段记忆保存下来； 遇到要表白的女孩就去大胆表白；和孩子一起成长；和家人一起出去旅游……好好享受当下。 生活终究会回到油米酱醋茶，积极乐观的人生态度就是，即使生活再困难，每天起床时也要感谢这新的一天。]]></content>
      <categories>
        <category>生活琐事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一篇讲解select/iocp/epoll等网络模型推荐的文章]]></title>
    <url>%2F2019%2F08%2F19%2F%E4%B8%80%E7%AF%87%E8%AE%B2%E8%A7%A3select-iocp-epoll%E7%AD%89%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%8E%A8%E8%8D%90%E7%9A%84%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[转 https://my.oschina.net/yearnfar/blog/297733 将网络的模型说的比较清晰的文章]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安防行业视频播放器的设计]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%AE%89%E9%98%B2%E8%A1%8C%E4%B8%9A%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[背景在安防行业工作了n年，基本都是在做播放器相关开发，从公司最初的一代架构，后来的二代架构，再后来的轻量2.5代架构都是核心负责人员，对于安防行业播放器的架构设计有很深的了解。安防播放器并不需要追求最新的架构和最新的技术，适合自己行业、自己公司特点的才是优秀的。笔者的开发团队长期维持在4~5人，却承载着大量第三方厂商对接、标准测试、多种码流分析、多种私有文件格式解析、高稳定性、各种系统平台支持、正常需求、奇葩需求、新技术预研、奇奇怪怪bug定位等等，有一个易接入、插件式、高稳定、小而精的播放组件是多么的重要。 架构如下是在二代开始设计时架构图，分为UI和播放库，其中除了UI的桌面客户端、decode filer中的解码插件由其他团队完成，其他都是本组负责。 演变过程在一代架构开发过程时，公司还是已接入自己公司设备为主，所以架构比较随便，能用就行，但是随之时间发展，公司平台需要接入大量第三方厂商，一代架构有几个致命的缺点：1、播放库和UI层结合太精密。一代是已ActiveX形式提供的，那么就无法在非windows平台下使用；第三方公司接入也非常不方便。2、代码耦合高。每次接入一个厂商设备，新增加代码修改必然影响之前流程。每次出版本都冒着影响主流程的风险，测试、开发风险很大。 基于此，开发了二代架构。 二代架构参考了windows的directshow的方式，使用插件式进行接入。每次接入一个厂商，只需要开发对应厂商的source filter、parse filter、decode filter、render filter，然后通过配置可以选择用哪些filter进行连接。 举例1渲染模式从一开始的ddraw方式，演变出了d3d， 主要原因是在控制云台相机转动时画面在ddraw渲染下会出现锯齿现象。所以新开发了一个d3d_filter.dll ，那么只要在显示设置上选择“d3d模式”，就自动切换为d3d渲染。 举例2解码自适应。比如播放一些标准视频文件如 avi、mp4等等，我们可以编写一个ffmpeg filter,就自动支持很多文件格式、流格式了。只是性能稍微差一些。 所以只要套上一个漂亮的UI外壳，就可以成为一个万能播放器，即可以播放主流公司、主流格式的码流文件，也可以播放一些小众公司的码流文件。 设计的关键点1、已dll、so 的形式提供。2、使用C++98。兼容一些嵌入式设备。3、能用自研模块，就用自研模块。比如跨平台日志、跨平台多线程、锁、套接字、rtsp、http、mp4解析封装、渲染……4、能小则小，不依赖第三方库。比如公司设备web客户端插件，使用activex、npapi技术，包括解码等所有组件压缩后不到800K。5、跨平台。基本支持所有平台。6、提供32位、64位版本 涉及到的一些知识信令： 国标、onvif、sip媒体控制： rtsp、rtmp流媒体传输协议： rfc3984、 ps over rtp、ts over rtp、es over rtp本地文件格式： mp4（音频mp3、mp2、aac）音视频编码格式： mpeg2、mpeg4、h264、h265、g711、g722解码库： 264、intel media sdk、h265视频渲染： ddraw、d3d、opengl、sdl、x11音频渲染： waveout、directsound 新技术智能播放器的decode 和 render模块之间增加一个IA filter 就可以变成一个智能播放器了，加入伴线、车牌识别等等智能库。 GPU解码CPU性能的提升遇到了瓶颈，GPU成了现在的热门。早期2011年左右我在尝试gpu解码，采用的是n卡的cuda库和微软的dxva2，购买了当时最强的桌面显卡GTX470，但实际测试h264的hw解码性能却非常低下。后来查找了资料了解其实虽然使用了cuda算子，但h264本身的并发性并不强，所以在性能上勉强只能支持4路1080p的hw解码。接着就是研究intel quick sync video，intel的技术和n卡原理不同，intel的芯片中单独解码单元负责h264的解码，所以性能非常强劲，当时测试16路1080P h264解码，cpu占用率15%左右，但需要消耗2G多的内存。GPU解码存在一个缺点：显存数据copy到内存性能是非常低下的。 h5播放1、推模式：flash的rtmp协议模式。无延时，falsh可能被抛弃2、拉模式：hls 。有延时，兼容性强。3、webrtc：解码库h264支持不够完美、h265还不支持。 chrome、edge早期IE 统治下，activeX无疑是首选，后来chrome、firefox崛起，使用npapi，再后来chrome放弃npapi，不知道chrome下如何实现低延时播放？ 客户端web（IPC自带）C#（国内行业项目首选开发语言）QT(海外项目)手机 NAT穿越1、turn、stun。4种NAT类型2、端口合一。信令、媒体流都使用一个端口。rtp over http，rtp over rtsp 常见问题播放卡顿使用wireshark 抓包分析I、B、P帧间隔。 rtp包乱序缓存排序 rtp丢包tcpkcpQos 包分片rtp 包大小控制在mtu字节以内tcp 注意tcp粘包，使用’$’同步位 花屏1、是否存在丢包2、保存es码流使用elecard 播放，确定是码流问题还是解码库问题 播放锯齿、撕裂使用d3d模式 ddraw死锁（低概率）ddraw老bug， ddraw所有函数调用都放置在一个线程中。 资源泄漏、死锁、崩溃、踩内存……windbg 分析IDA pro 反汇编，定位第三库bug 性能差80% cpu是解码、15%是yuv内存copy……….. 1、优化解码性能。语言层的优化、算法层的优化2、优化yuv 内存copy次数。 解码后到渲染表面只进行一次内存复制；多窗口播放1080p视频时可以先缩放再copy。 疑难问题有几个疑难问题属于三界之外：1、windows 7 系统下主题更换导致ddraw存在gdi泄漏（超低概率）2、web端ddraw 低概率出现死锁（超低概率）3、某些多显卡情况下，播放视频不流畅（某台机器）4、vista系统长时间播放存在系统性丢包（某个版本操作系统）5、轮切过程中如果锁屏，会出现黑屏（超低概率）6、第三方小公司库质量差（大坑），最后变成我们帮他们定位、修改库代码。 总之，wireshark、elecard、模拟发包器（自己写的）、vlc、ffmpeg 、cool edit、windbg这几个神器在手，问题基本都能解决。 衍生出的产品万能播放器前面提到过，套上一个UI壳，就是一个漂亮的播放器 SDC（软dc）soft decode 软dc。 客户端不当只有pc、手机，其实还有电视墙。一般做法是配一个公司的ipc配置一个dc设备用户解码输出信号dvi、vga到电视墙，但是由于安防厂商众多，有的公司不提供linux解码方式，只有windows解码库，所以在这种场景需要SDC。SDC实际是一台PC主机，安装windows系统，并有3块A卡（A卡支持1卡3输出），所以实际上有9通道输出，输出口为DVi+VGA+DP,安装上万能播放器，再带一个sip协议库，就可以介入公司平台，可以上电视墙。并且支持图像拼接、画中画、漫游、多图层等类似拼接器功能。 IA智能服务器类似架构开发，将filter更名为engine，支持算法库插件式。 转码服务器1、使用hw解码库进行转码，从高分辨率转为低分辨率2、使用第三方sdk解码，然后hw重编码为标准码流 参考的源码vlcffmpegsdlintel media sdkwebrtc 总结安防的播放器需要满足：高兼容跨平台高稳定低延时流畅播放多通道高性能低带宽足够小元数据叠加]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows的应用验证机制]]></title>
    <url>%2F2019%2F08%2F15%2Fwindows%E7%9A%84%E5%BA%94%E7%94%A8%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[windows的验证机制发现软件瑕疵的最普遍方法就是测试，常用的测试手段有如下几种： 黑盒测试 白盒测试 内建自检 压力测试 虽然以上每种测试都有它的优势和侧重点，但即使用上了以上所有测试手段，也不能保证会发现所有问题。比如某个程序有轻微的内存泄漏，就很难发现。比如有些异常需要再比较苛刻的环境下才会出现，但测试时会很难满足。…… windows操作系统的验证机制（Verifier）就是为了满足这个需求而设计的。 windows 验证机制分为驱动验证器和应用程序验证器，这里主要讲解应用程序验证器。 应用程序验证器工作原理验证器的基本设计思想是在应用程序调用内核函数时，对应用程序执行各种检查，看其是否符合windows sdk的调用条件和规范。 windows 采用的是通过修改被验证程序的输入地址表（IAT）来挂载（hook）应用程序的api调用。 系统会将被验证驱动程序的IAT表中的api函数地址替换为验证函数的地址。这样，当这个应用程序调用api函数时，便会调用对应的验证函数。 应用检测器组成位于NTDLL中的支持例程位于ntdll.dll 中，大多已 AVrf 开头 验证提供器模块安装验证工具时复制到system32目录下的多个dll文件 应用验证管理器关于管理验证程序参数的图形界面工具。 执行过程执行过程是详细讲解是比较复杂的，这里我已简单的doublefree来简单介绍下执行过程。当函数中执行free时，最终会调用到virtualfree，这时应用验证器实际调用的是AVrfVirtualFree，改函数会调用AVrfVirtualFreeSanityChecks 执行健全性检查……当第二次对同一个地址进行free时，健全性检查会验证不过，从而主动触发一个异常。 使用应用验证器下载：链接：https://pan.baidu.com/s/1JKst9CbDKTFROKL0yWsmjg 提取码：7291 ，里面的ApplicationVerifier.x86.msi 和 ApplicationVerifier.amd64.msi 验证项目目前的验证器设计了6个类别，19个验证项目。 basics COM 正确使用组件对象模型（COM） Exceptions 检查非法访问异常 handles 正确使用句柄 Heaps 正确使用堆 Locks 正确使用同步对象 Memory 合理使用虚拟内存 RPC 正确使用rpc Threadpool 正确使用内存池 Tls 正确使用线程局部存储 Compatibility(兼容性) FilesPaths 正确读取公共目录和使用有个api HighVersionLie 读取版本信息的方式 Interactive-service 验证交互式系统服务 KernelMode-DriverInstall 正确安装内核态驱动程序 hangs hangs 检测可能导致程序僵死的情况 lowRes（低资源模拟） lowRes 模拟低资源情况，对分配资源请求返回失败 LuaPriv LuaPriv 判断在管理员权限可以运行的程序是否也可以在受限账号下正常运行 杂项 DangerousAPIs 检查使用危险api的情况 DirtyStacks 检测使用未初始化局部变量的情况 TimeRoolOver 强制GetTickCount api快速重新计数，已考验是否处理该异常 打印 PrintAPI 正确使用打印API PrintDriver 验证打印驱动程序 服务 Service 验证系统服务 doublefree操作举例安装应用验证安装后，找到appverif.exe doublefree代码123int *p = new int[100];delete []p;delete []p; 不开启应用验证时，程序不会出现异常。 开启应用验证“file” –&gt;”add application” —&gt;”xxx.exe” (不要在.exe 运行时操作)，选择“heaps” 启动 .exe ,然后执行doublefree 程序崩溃。使用windbg可以查看异常堆栈1234567891011121314151617180:000&gt; kvChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.004feafc 6ade80c8 6aded258 00000007 07041000 vrfcore!VerifierStopMessageEx+0x5b8004feb20 0fdcdfbe 00000007 0fdc1cac 07041000 vrfcore!VerifierDisableVerifier+0x598004feb78 0fdcbb9f 00000007 0fdc1cac 07041000 verifier!VerifierStopMessage+0x8e004febe4 0fdc89bd 07041000 00000000 0a8607ec verifier!VerifierDisableFaultInjectionExclusionRange+0x44af004fec48 0fdc8b15 07041000 0a6d6e70 00000000 verifier!VerifierDisableFaultInjectionExclusionRange+0x12cd004fec6c 0fdc8d90 07041000 0a6d6e70 004fed04 verifier!VerifierDisableFaultInjectionExclusionRange+0x1425004fec88 0fdcadd0 07041000 0a6d6e70 0a8607ec verifier!VerifierDisableFaultInjectionExclusionRange+0x16a0004feca4 77b72fa1 07040000 01001002 0a6d6e70 verifier!VerifierDisableFaultInjectionExclusionRange+0x36e0004fed14 77ad2735 0a6d6e70 08ba3c35 00000000 ntdll!RtlpNtSetValueKey+0x3cf1004fee60 77ad2302 00000000 0a6d6e70 00000111 ntdll!RtlGetCurrentServiceSessionId+0xf5004feeb4 6adead3b 07040000 00000000 0a6d6e70 ntdll!RtlFreeHeap+0x222004feed4 71de3c1b 07040000 00000000 0a6d6e70 vrfcore!VerifierSetAPIClassName+0x16b004fef20 00181660 0a6d6e70 004ff758 0a6d6e70 MSVCR90!free+0xcd004fef40 78409479 004ff758 004fef68 7840965b TraceMe!CTraceMeDlg::OnBnClickedButton1+0x40 (CONV: thiscall) [c:\users\b41-cx\documents\visual studio 2008\projects\traceme\traceme\tracemedlg.cpp @ 195]004fef4c 7840965b 000003e9 00000039 00000000 mfc90!_AfxDispatchCmdMsg+0x3b 个人常用方法 一般用这个工具来分析踩内存 可以在测试环境中验证服务 注意点 只能检查native代码 程序序正常退出才行，强行杀进程不能得到正确的报告 只能做Run-time检测。尽量使用程序的所有功能已保证检测到更多代码 开启检测时，性能会下降，内存会升高，不要在生产环境中使用。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[普通感冒]]></title>
    <url>%2F2019%2F08%2F05%2F%E6%99%AE%E9%80%9A%E6%84%9F%E5%86%92%2F</url>
    <content type="text"><![CDATA[普通感冒时指流感病毒以外的病毒引起的急性上呼吸道感染。几个误解： 感冒是着凉引起的。挨冻是不会引起感冒的，会流鼻涕。 吃感冒药能治疗感冒的。打点滴、感冒药只能缓解感冒的症状，但是会拖长感冒治愈的时间。 抗生素能治疗感冒。抗生素是杀菌的，不是杀病毒的。 免疫力强的人不会感冒。只要感冒病毒进入鼻腔，几乎都会得，除非你的免疫系统不活跃。 感冒大都是通过手揉眼睛、挖鼻子，将病毒带入鼻腔的；还有就是通过其他人的唾沫传入的。所以 勤洗手，可以降低50%的概率 在人群多的地方带口罩]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[癌的简单介绍]]></title>
    <url>%2F2019%2F08%2F05%2F%E7%99%8C%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[外来性的毒性物质，物体本身没有危害，但是被身体的酶分解后会变成有毒物质，（比如酒精危害不大，但是被分解后的乙醛毒性很大 ）；物理射线都会导致基因受损 。 dna本身有修复功能，如果修复工作能在细胞下次分裂之前完成修复，就没有什么问题；但是如果在修复还没完成就进行有丝分裂，这时dna就会携带有错误的基因，所以对于有丝分裂频繁的细胞就会因为这个时间差而导致错误，高发位置就是在上皮细胞，比如膜啊、皮肤啊，经常暴露在环境和消化液中； 还有的情况不是修复时间不够，而是修复功能有问题，就是负责修复的酶本身就存在问题；还有的就是50%的癌症源自P53基因发生变异，P53基因是细胞修复的质检员，工作是：控制在修复完成时才能进行下次有丝分裂，同时如果dna损失过大可以引导细胞自杀。黄曲酶素专门破坏P53基因，一点点的黄曲酶素可能就会花掉你一辈子创造的财富。 形成癌细胞并非易事，需要受损细胞几十代的变异，需要10年以上时间，苯芭比妥给肝癌细胞更好的生长环境；焦油给了肺癌细胞好的环境；过量的雌性激素会给乳腺癌细胞和卵巢细胞更好的环境。 1/3人在某个时间点会最终患癌 ，大家可能会将癌症归于环境、遗传，但事实上细胞修复时发生的随机性错误也是需要考虑的。 了解了大概原理后，其实癌症发生是随机的，饮食、环境、遗传固然是一个原因，但是细胞有些分裂导致的随机错误是谁都无法避免的。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高度近视]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%AB%98%E5%BA%A6%E8%BF%91%E8%A7%86%2F</url>
    <content type="text"><![CDATA[一般建议： 高度近视眼患者定期进行扩瞳眼底检查（至少一年一次），早期发现小裂孔，可通过激光来防治视网膜脱离。 避免强度过大的体育锻炼或劳动，猛而强的撞击易诱发裂孔形成。 控制血压、血糖，避免其他原因引起的视网膜病变。 一旦出现眼部不适症状，及时至医院就诊。 视网膜脱离：是高度近视眼常见且严重的并发症之一。高度近视视网膜变性变薄，同时玻璃体变性，产生液化或后脱离，有玻璃体条索与变性的视网膜相粘连，如果眼球仅受到轻微震动或外伤，就有可能由于条索的牵拉，引起视网膜破裂，形成裂孔，这时液化的玻璃体可经裂孔流入视网膜下，使视网膜脱离。 黄斑病变：黄斑是视网膜上视觉最敏锐的部位。高度近视可形成脉络膜新生血管膜导致黄斑出血，患者因此出现视力突然明显降低、视物变形或中心固定暗点。高度近视眼球后部显著增长，由于黄斑中心区域玻璃体或黄斑前膜的前后方向牵引，可形成黄斑劈裂，甚至继发性黄斑裂孔，黄斑裂孔同样也可以引起视网膜脱离。 青光眼：高度近视合并开角型青光眼比正常眼多6～8倍。但近视眼合并的青光眼，易于漏诊及延误治疗。因为高度近视，随着眼球变长变大，眼球壁变薄变软，通常所测眼压偏低。同时对应出现的视力减退和视野缺损，一般也只认为是近视眼眼底病变所致。 鉴于高度近视的严重危害性，建议各位宝宝们： 高度近视的宝宝们应定期至眼科行扩瞳眼底检查，以期及早发现周边部视网膜裂孔，一旦发现，可通过激光光凝裂孔周围以预防视网膜脱离的发生。 视网膜脱离后会出现眼前幕样黑影遮挡感、闪光感、视力下降等，黄斑出血后会出现视力突然降低、视物变形或中心固定暗点等，一旦出现以上及其他眼部不适症状，及时至眼科就诊。 避免剧烈体育运动或其他体力劳动，避免眼球受到外伤，因强烈的震动或外力撞击容易使原本薄弱的视网膜发生裂孔。 青光眼是高度近视的并发症之一，应定期测量眼压及检查视野，以免忽略了青光眼的诊治。 由于眼底的变性萎缩，高度近视往往不能完全矫正，验光配镜时适当低矫也可提高一些视力，并易于被患者接受。 ---------- 以上摘自网络]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[近视--后半球]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%BF%91%E8%A7%86-%E5%90%8E%E5%8D%8A%E7%90%83%2F</url>
    <content type="text"><![CDATA[眼睛前半球的问题医学界都有成熟的解决办法。 看不清可以带眼镜。 不想带眼睛，可以做角膜手术 度数高，无法做角膜手术，可以植入人工晶状体 白内障可以换掉原来的晶状体 角膜坏了可以移植 但是如果后半球出了问题，几乎没法解决的，因为它已经涉及到神经跟视觉信号处理部分了。 所以我们只要有这个意识，就是保护好后半个眼球，那么眼睛上的问题总会有完美的解决办法。 后半球重要的问题就是视网膜脱落。图片中阿慕斯勒方格，使用一只眼睛对着黑点，如果看到的直线是有扭曲的，就说明你的眼睛已经存在严重问题了，需要马上去医院。中国人的这个发病率是万分之二。视网膜脱落对于高度近视人就更高了，建议： 需要避免头部做剧烈运动，比如拳击、蹦极、赛车、跳水。 定期进行扩瞳眼底检查（至少一年一次）]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[近视--前半球]]></title>
    <url>%2F2019%2F08%2F05%2F%E8%BF%91%E8%A7%86-%E5%89%8D%E5%8D%8A%E7%90%83%2F</url>
    <content type="text"><![CDATA[眼睛大致分为前半球和后半球，本次重点讲前半球，下次讲后半球。 我们平时提到的近视、远视都是说的是前半球。 对于一个没有成年的孩子来说，如果双方父母视力都是600度以上的高度近视，那么大概率来说，小孩是高度近视的可能性是非常非常高的。如果父母懂得科学的方法，那么就可以让小孩成年前原来增加1000度，变为只增加200度，坚持到20岁，眼睛定型了就算是大功告成了。那么下面说下有效的保护方法： 在户外待足够长的时间。并不需要运动，只要静坐在那里就有效果，时间&gt;40分钟 使用阿托品类的眼药。浓度0.01%，一旦使用了这个药，就要有毅力，坚持下去。 使用ok 镜。 在小孩3、4岁的时候就一直坚持到眼睛定型，就不会让自己的孩子成为高度近视。这之外的其他方法对于缓慢近视发展是无效的，比如眼保健操、眼睛按摩椅、防蓝光灯等。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[饮食中游离糖背后的科学奥秘]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%A5%AE%E9%A3%9F%E4%B8%AD%E6%B8%B8%E7%A6%BB%E7%B3%96%E8%83%8C%E5%90%8E%E7%9A%84%E7%A7%91%E5%AD%A6%E5%A5%A5%E7%A7%98%2F</url>
    <content type="text"><![CDATA[问：什么是“游离糖”？ 答：“游离糖”是指厂商、厨师或消费者添加到食品中的单糖和双糖，加上蜂蜜、糖浆和果汁中天然存在的糖。单糖有一个糖分子，而且包括葡萄糖、半乳糖和果糖。双糖有两个糖分子。消费最广的双糖是蔗糖或砂糖。 问：所以建议不针对其它类型的糖？ 答：是的。世卫组织的建议只针对游离糖。它们不包括完整水果和蔬菜中的糖。后面这种糖有时称为内源性糖。这些糖由一层植物细胞壁包裹，消化起来更为缓慢，进入血流所需的时间比游离糖更长。 问：食品标签不显示“游离糖”，但有“添加糖”，那是什么？ 答：“添加糖”一词在美国和其它一些国家使用广泛，不过“添加糖”的定义还没有达成普遍共识。多数时候，“添加糖”是指与游离糖相同的一组糖，但“游离糖”一词更为精确。例如，尚不清楚浓缩果汁中是否含有添加糖，但其中肯定含有游离糖。还有原糖、非精制糖和天然糖。这些都是游离糖。 问：比较大的影响是什么？ 答：一个是龋齿（蛀牙），一个是不健康的体重增加（即，超重和肥胖）。肥胖会催生其它非传染性疾病：2型糖尿病、某些癌症（如，绝经后乳腺癌、结肠直肠癌），并在一定程度上造成心血管疾病。 水果非常不建议榨汁喝。 摘自： http://www.who.int/bulletin/volumes/92/11/14-031114/zh/]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[发烧]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%8F%91%E7%83%A7%2F</url>
    <content type="text"><![CDATA[发烧 病毒、病菌入侵会刺激细胞释放出前列腺素E2。E2会把“正常体温”的设定值给调高了， 让身体觉得体内热量不足，于是就要增加产热和减少散热。肌肉运动是增加产热的一种快速方法，因此发烧的人会不由自主地颤抖。为了减少散热，皮肤的血管收缩，那里的血液被送到体内深处，因此发烧的人会觉得发冷。扑热息痛（对乙酰氨基酸）、阿司匹林（乙酰水杨酸）等药物能够抑制E2的合成，因为他们是有效的退烧药。 吃了退烧药，或者病好了，体温恢复正常， 身体需要把多余的热量散发出去，就会出汗。所以退烧会导致出汗，但是许多人却本末倒置，以为是出汗导致了退烧，所以平时都是这样的土方法：发烧后多穿衣服，多盖被子，捂出汗来病就好了。 理论上，温度升高能加速某些免疫能力。初步的临床实验也表明发烧可能有些好处。比如，小孩患水痘，从发烧、出疹到完全结痂，大约一周，如果使用了退烧药，这个病程反而要多一天。 当然体温过高也是有害的。如果是高烧（肛门温度&gt;41度），会对细胞、组织造成损伤。当体温达到42度时，神经元就无法对体温做进一步的控制。因此一旦高烧，必须采取手段让体温下降。但是平时我们的土方法“捂热”，反而增加了体温，加重了病情。 如果是一般的发烧，未必就要急着吃药退烧。在通常情况下，吃退烧药只是让病人觉得舒服一些，无助于身体恢复，反而可能还会有所延误。至于“xx退热颗粒”“xx清热颗粒” 之类的传统药物，是否真有退烧的疗效很值得怀疑，服用他们也是有害无益。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[咳嗽]]></title>
    <url>%2F2019%2F08%2F05%2F%E5%92%B3%E5%97%BD%2F</url>
    <content type="text"><![CDATA[咳嗽 咳嗽不是病，而是一种保护机制 为什么感冒的咳嗽不能随便吃药 如何正确处理儿童感冒后的咳嗽问题 简单回答：对于成年来说，如果不影响正常生活，不用特地的吃药；如果明显影响到睡眠，可以吃现代医学的止咳药；如果暂时没有药，可以含一块糖。 感冒之后还在咳嗽，说明粘膜并没有完全修复，还有致病源在上面，身体还在不断的清除他们。所以最好不要用什么药来终止身体的自我保护机制，特别是儿童。 如果咳得太厉害，影响到睡眠，那就可以吃一些止咳药，休息不好，受到的损失会更大。现代医学止咳药都是通过抑制神经起作用。比如吗啡，这个不仅止咳，连疼痛也止住，但是吗啡会成瘾，普通人不能使用。还有就是对吗啡做了化学调整的”可待因“，它的成瘾性略低，但现代医院也不允许使用。 安全的药是“右美沙芬” “苯丙哌林”“盐酸那可叮”“喷托维林”。 但以上这些抑制神经止咳的药对孩子还是风险过高，所以如果孩子不到6岁，最好的办法是吃一块糖。因为糖分混合着水会促进粘膜生层一层保护层，避免粘膜被病菌侵扰。 这个效果立竿见影，当然棒棒糖效果更好。棒棒糖可以算是缓慢释放糖分的止咳药，一根棒棒糖的止咳效果大约和15分钟不停的喝梨水，糖水效果差不多。 不论什么情况下，都不要用带“复方”开头的药物，也不吃那些药品名称里面包含了疗效的药物，比如“止咳水”“止咳糖浆”“克咳片”等，因为他们不安全，或者里面普通含有“可带因”“吗啡”等已经被禁的成分。 以上仅针对普通咳嗽，至于咳嗽带血、伴有呕吐，发烧，就需要立即就医。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[食用油的选择]]></title>
    <url>%2F2019%2F08%2F05%2F%E9%A3%9F%E7%94%A8%E6%B2%B9%E7%9A%84%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[先说结论： 炒菜用精炼油，不要用初榨油，也不要用小作坊榨出来的油 精炼油只要不是动物油、椰子油、棕榈油，植物类的油都差别不大，主要是口味不同。首选菜籽油 转基因油即健康又便宜又实惠。 初榨油中含多酚类和维生素，所以不适合炒菜；同时不是精炼的油，杂质较多，在高温作用下容易产生致癌物质，所以也不适合炒菜。 食用油需要长时间保存，就需要精炼，一般会进行脱水、脱酸、脱色、脱臭、托蜡，最终目标就是让油中之有脂肪酸，含量为99.5%，所以基本没有其他什么营养物质，更别提什么清除自由基、抗衰老的功能了。如果纯度不高，遇到高温就容易产生致癌物质方而不安全。 99.5%都是脂肪酸，那么他们是有区别的。对人体的好处就是 单不饱和脂肪酸&gt;多不饱和脂肪酸&gt;饱和脂肪酸。 植物油差别不大，其中菜籽油、橄榄油、芝麻油都比较好，但菜籽油价格最便宜。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事故报告（2018/05/12）]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BA%8B%E6%95%85%E6%8A%A5%E5%91%8A%EF%BC%882018-05-12%EF%BC%89%2F</url>
    <content type="text"><![CDATA[时间2018/05/12持续： 30分钟 事故描述少量玩家玩家登陆不上 事故原因某台网关服务业务线程出现异常，出现僵死。但是tcp端口仍正常，slb健康检查正常，所以部分玩家请求会转发到该异常网关。 总结定位花费比较长时间。网关健康检查不完整；对于tcp正常，但业务线程异常，会上报消息堆积（但是某个服务缺失该功能）保存dump，找到原因修复bug 感受线上问题的修复其实并不难，难的其实是找到异常的服务；比如线上运行了几百个服务，如果能快速定位到根源服务；某个服务异常，导致其他服务雪崩，如何在雪崩的消息中找到有用的线索……. 服务如何部署、如何规划、哪些信息需要中心汇总、哪些信息需要及时预警……都要和业务结合起来进行调整，不能抛离业务。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事故报告（2018/01/26）]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BA%8B%E6%95%85%E6%8A%A5%E5%91%8A%EF%BC%882018-01-26%EF%BC%89%2F</url>
    <content type="text"><![CDATA[时间2018/01/26持续： 10分钟 事故描述用户无法登陆 事故原因本人手贱，中午快吃饭时，线上手动执行redis删除大key命令，导致redis性能不足。其他接口redis访问超时 总结低级失误，关闭线上服务给开发人员的写操作权限。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事故报告（2017/09/26）]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BA%8B%E6%95%85%E6%8A%A5%E5%91%8A%EF%BC%882017-09-26%EF%BC%89%2F</url>
    <content type="text"><![CDATA[时间2017/09/26 持续：5分钟 事故描述钉钉预警网关服务消息堆积1000+； 移动网关服务负载较高，导致用户连接失败 事故原因单台网关使用完成端口，套接字数量2.6w，阿里云cpu 100% 处理方式slb新挂载n台服务进行分流 总结服务状态监控预警很有必要，发现问题+处理问题 5分钟。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事故报告 (2017/09/07)]]></title>
    <url>%2F2019%2F07%2F30%2F%E4%BA%8B%E6%95%85%E6%8A%A5%E5%91%8A-2017-09-07%2F</url>
    <content type="text"><![CDATA[时间2017年9月7日 持续 半小时 事故描述服务升级，线上运行一会就出现崩溃；立刻保存dump分析原因。 事故原因编译器版本从vc6切换到vs2013，ms的函数保护严格，对原来的输入错误会产生异常；比如vs2013 版CString 函数转换特殊字符大小写，对于某些特殊字符产生异常，而vc6 不会 总结 结构化异常保护： 即使异常，程序仍能继续运行 无状态服务 ： 即使程序重启，仍不影响用户正常业务]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Teach Yourself Programming in Ten Years]]></title>
    <url>%2F2019%2F07%2F30%2FTeach-Yourself-Programming-in%2F</url>
    <content type="text"><![CDATA[Teach Yourself Programming in Ten Years http://norvig.com/21-days.html]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[牙疼]]></title>
    <url>%2F2019%2F07%2F30%2F%E7%89%99%E7%96%BC%2F</url>
    <content type="text"><![CDATA[牙疼俗话说“牙疼不算病，疼起来真要命”。2019/7/24~7/30 日我就经历一次疼痛的经历，这段经历比较曲折，所以记录一下。 大女儿暑假过来配我们，所以第一天晚上很兴奋，怎么都不肯睡，搞得我一晚上精力很差，第二天回家时感觉有颗牙齿不是很舒服，想想自己每年都去做牙齿检查，保护得也还可以，应该没什么。 过了一天，发现牙疼得厉害，那颗疼得牙齿已经不能碰任何食物了，即使是米，咀嚼时碰到都会疼的要死。 联系了一直看牙的医生，要周六才有时间。好不容易等到周六，拍片检查后，问我是哪里做的根管治疗，我想了想应该省口腔医院，他沉默了一会，然后帮我磨了下牙，过一会放弃了“打了纤维桩，取不出来，只能回省口处理”。我的天，我现在很疼，省口肯定是当天挂不上号的，但是疼的难受，还是跑去了省口。 跑到省口，空隙间抓住一个医生，简单描述了下病情，他的答复是他们也取不出来，而且也加不了号。 只能挂了市口医院，医生听了我描述之后，并观察了下，“为什么要打纤维桩呢？”，“我不知道啊，省口做的”。他们表示他们也取不出来，还是只能回省口，他们几乎没碰到到做了根管治疗会发炎的，建议我吃抗生素。 不能疼了就吃抗生素啊，总归要治好吧，虽然抗生素吃了几天，牙齿是不疼了。 约了周末的省口，普通科室看了下，说他们也处理不了，只能专家处理。 😰汗 ，牙体牙髓专家号太难挂了……………..]]></content>
      <categories>
        <category>生活琐事</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[超人类革命]]></title>
    <url>%2F2019%2F07%2F30%2F%E8%B6%85%E4%BA%BA%E7%B1%BB%E9%9D%A9%E5%91%BD%2F</url>
    <content type="text"><![CDATA[时间2019/07/30 概要1归根结底，最后都回到一个问题：到底是要让人变得更加像人-----或者说，使人变得更加像人所以变得更好--------还是反过来使人失去人的本质，甚至人工制造出一种新的物种，即后人类？ 什么是超人类主义？1超人类主义是利用科技进步---对当前人类的体能、智力、情感和道德等方方面面进行改善的浩大工程。超人类主义运动的一个最本质的特征就是它打算从传统的医疗模式，即以“修复”和治疗疾病为主要目的的治疗方式升级到“高级”模式，即改善甚至“增强”人类。 本书的目的：1完成黑格尔给哲学定下的首要任务：“理解现在存在的东西。”尽可能准确地描绘出现实。 书本结构 古典人文主义、超人类主义和后人类主义之间的关系 反对和支持超人类主义运动的各大主要论点 “共享经济”背后隐藏的政治哲学 对监管的反思 总结大致翻阅即可。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[tcmalloc vs2013编译]]></title>
    <url>%2F2019%2F07%2F24%2Ftcmalloc-vs2013%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[下载https://github.com/gperftools/gperftools 编译tcmalloc 编译比较简单，有现成的工程。默认是使用vs2015编译，需要降级，并同时去掉“constexpr”关键字的使用。 使用可以参考 “README_windows.txt” dll 版选择“release-patch”编译出lib、dll在自己的项目中包含libtcmalloc_minimal.lib，并在“强制服号引用”设置“__tcmalloc” 静态库(md) 版选择“release-patch” ,项目输出修改为 “lib” 编译出 libtcmalloc_minimal.lib。 在自己的项目中包含libtcmalloc_minimal.lib，并在“强制服号引用”设置“__tcmalloc” 静态库(mt) 版选择“release-override” 编译出 libtcmalloc_minimal.lib。 将libtcmalloc_minimal 工程添加到自己的项目中，然后在“通用属性”–“引用” 中添加libtcmalloc_minimal 在“预处理器定义中增加 “PERFTOOLS_DLL_DECL=” 总结jemalloc 在windows下无法简单的替换项目中的malloc、free，但是tcmalloc却可以很方便的替换。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[jemalloc vs2013编译]]></title>
    <url>%2F2019%2F07%2F23%2Fjemalloc-vs2013%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[下载https://github.com/jemalloc/jemalloc 选择master 说明本地解压后查看 jemalloc-master\msvc\ReadMe.txt12345678910111213141516171819202122How to build jemalloc for Windows=================================1. Install Cygwin with at least the following packages: * autoconf * autogen * gawk * grep * sed2. Install Visual Studio 2015 or 2017 with Visual C++3. Add Cygwin\bin to the PATH environment variable4. Open &quot;x64 Native Tools Command Prompt for VS 2017&quot; (note: x86/x64 doesn&apos;t matter at this point)5. Generate header files: sh -c &quot;CC=cl ./autogen.sh&quot;6. Now the project can be opened and built in Visual Studio: msvc\jemalloc_vc2017.sln 安装cygwinhttp://www.cygwin.com/ setup-x86.exe 环境配置cygwin 默认安装完后，安装jemalloc说明在vs2013 的命令行下执行 sh -c “CC=cl ./autogen.sh” ，提示123autoconf./autogen.sh: line 5: autoconf: command not foundError 0 in autoconf 需要安装 autoconf2.5 、automake vs2015 工程降级 修改 jemalloc_vc2015.sln 修改jemalloc.vcxproj 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;Project DefaultTargets=&quot;Build&quot; ToolsVersion=&quot;12.0&quot; xmlns=&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;&gt; &lt;ItemGroup Label=&quot;ProjectConfigurations&quot;&gt; vs2013 打开工程，修改平台工具集为“Visual Studio 2013 (v120)” 编译报错static 正常；dll 库时报错12341&gt;arena.obj : error LNK2001: 无法解析的外部符号 _test_hooks_arena_new_hook1&gt;malloc_io.obj : error LNK2001: 无法解析的外部符号 _test_hooks_libc_hook1&gt;pages.obj : error LNK2001: 无法解析的外部符号 _test_hooks_libc_hook1&gt;prof.obj : error LNK2001: 无法解析的外部符号 _test_hooks_libc_hook 添加 test_hooks.c 到工程中，重新编译 测试能用，但是windows下替换malloc、free还不是很方便，下次尝试用下tcmalloc。 工程地址链接：https://pan.baidu.com/s/1WsmfkgNSlIp_CYApYGUJ5Q提取码：sgev]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SLB支持wss]]></title>
    <url>%2F2019%2F07%2F18%2FSLB%E6%94%AF%E6%8C%81wss%2F</url>
    <content type="text"><![CDATA[背景原本用boost::asio 做了一个支持tcp、ws、wss协议的网关，一个端口同时支持三种协议，区分的方法比较简单： 判断三次握手之后的第一字节的数据报文 0x16：wss // ssl协议的头 ‘G’：ws ‘H’: tcp //私有协议也有一个握手报文 现在担心自己ssl解析性能不够优秀，所以打算使用阿里slb的ssl解析 配置方法配置比较简单，使用“性能保障型SLB”，然后在https中设置。 出现的问题健康检测异常由于不支持http的HEAD命令，所在在代码中增加对HEAD的处理，直接返回200ok，并主动关闭链接 https返回502使用 curl https://xxx.xx.com:1235 -v 提示502。需要支持http的GET命令。修改代码对GET的支持。 slb一个端口无法支持多个协议原来的服务12345端口是可以同时支持tcp、ws、wss协议的，经过slb需要配置三个端口： tcp ： 12345 — &gt;12345 http: 12346 — &gt; 12345 https:12347 —&gt; 12345 巨不爽！！ 测试数据使用 https://blog.csdn.net/zt3032/article/details/80492146 文章中测试https的结果。 slb123456789101112131415161718192021222324252019-07-18,16:27:57 0.002:0.003:0.057:0.000:0.057:0.063:0.0632019-07-18,16:27:58 0.001:0.003:0.048:0.000:0.048:0.055:0.0552019-07-18,16:27:59 0.002:0.005:0.051:0.000:0.051:0.057:0.0572019-07-18,16:28:00 0.002:0.003:0.050:0.000:0.050:0.055:0.0552019-07-18,16:28:01 0.002:0.003:0.049:0.000:0.049:0.054:0.0542019-07-18,16:28:02 0.002:0.003:0.052:0.000:0.052:0.058:0.0582019-07-18,16:28:03 0.002:0.003:0.050:0.000:0.050:0.056:0.0562019-07-18,16:28:04 0.002:0.003:0.051:0.000:0.051:0.057:0.0572019-07-18,16:28:05 0.002:0.003:0.050:0.000:0.050:0.057:0.0572019-07-18,16:28:06 0.001:0.003:0.049:0.000:0.049:0.055:0.0552019-07-18,16:28:07 0.001:0.003:0.048:0.000:0.048:0.053:0.0532019-07-18,16:28:08 0.002:0.003:0.052:0.000:0.052:0.058:0.0582019-07-18,16:28:09 0.001:0.003:0.049:0.000:0.049:0.055:0.0552019-07-18,16:28:11 0.001:0.003:0.049:0.000:0.049:0.055:0.0552019-07-18,16:28:12 0.001:0.003:0.052:0.000:0.052:0.058:0.0582019-07-18,16:28:13 0.002:0.003:0.049:0.000:0.049:0.055:0.0552019-07-18,16:28:14 0.002:0.003:0.049:0.000:0.049:0.055:0.0552019-07-18,16:28:15 0.002:0.003:0.053:0.000:0.053:0.059:0.0592019-07-18,16:28:16 0.001:0.003:0.050:0.000:0.050:0.055:0.0552019-07-18,16:28:17 0.002:0.003:0.048:0.000:0.048:0.053:0.0532019-07-18,16:28:18 0.001:0.003:0.056:0.000:0.056:0.061:0.0612019-07-18,16:28:19 0.002:0.003:0.050:0.000:0.050:0.056:0.0562019-07-18,16:28:20 0.001:0.003:0.048:0.000:0.048:0.053:0.0532019-07-18,16:28:21 0.002:0.003:0.051:0.000:0.051:0.057:0.0572019-07-18,16:28:22 0.002:0.004:0.051:0.000:0.051:0.058:0.058 自己做解析123456789101112131415161718192021222324252019-07-18,17:57:04 0.002:0.002:0.073:0.000:0.073:0.074:0.0742019-07-18,17:57:06 0.002:0.002:0.071:0.000:0.071:0.072:0.0722019-07-18,17:57:07 0.002:0.002:0.072:0.000:0.072:0.072:0.0722019-07-18,17:57:08 0.002:0.002:0.072:0.000:0.072:0.073:0.0732019-07-18,17:57:09 0.002:0.002:0.072:0.000:0.072:0.072:0.0722019-07-18,17:57:10 0.002:0.002:0.075:0.000:0.075:0.076:0.0762019-07-18,17:57:11 0.002:0.002:0.075:0.000:0.075:0.076:0.0762019-07-18,17:57:12 0.002:0.002:0.074:0.000:0.074:0.075:0.0752019-07-18,17:57:13 0.002:0.002:0.074:0.000:0.074:0.075:0.0752019-07-18,17:57:14 0.002:0.002:0.072:0.000:0.072:0.073:0.0732019-07-18,17:57:15 0.002:0.002:0.075:0.000:0.075:0.076:0.0762019-07-18,17:57:16 0.001:0.002:0.072:0.000:0.072:0.072:0.0722019-07-18,17:57:17 0.001:0.002:0.074:0.000:0.074:0.075:0.0752019-07-18,17:57:19 0.002:0.002:0.072:0.000:0.072:0.073:0.0732019-07-18,17:57:20 0.001:0.003:0.072:0.000:0.072:0.073:0.0732019-07-18,17:57:21 0.002:0.002:0.070:0.000:0.070:0.071:0.0712019-07-18,17:57:22 0.001:0.002:0.071:0.000:0.071:0.072:0.0722019-07-18,17:57:23 0.002:0.002:0.071:0.000:0.071:0.072:0.0722019-07-18,17:57:24 0.001:0.002:0.070:0.000:0.070:0.071:0.0712019-07-18,17:57:25 0.002:0.002:0.071:0.000:0.071:0.072:0.0722019-07-18,17:57:26 0.001:0.002:0.071:0.000:0.071:0.072:0.0722019-07-18,17:57:27 0.002:0.002:0.071:0.000:0.071:0.071:0.0712019-07-18,17:57:28 0.001:0.002:0.072:0.000:0.072:0.073:0.0732019-07-18,17:57:29 0.001:0.002:0.070:0.000:0.070:0.071:0.0712019-07-18,17:57:30 0.002:0.002:0.083:0.000:0.083:0.084:0.084 线上验证线上找了个某个微信小游戏做小白鼠，在wss链接步骤增加大数据埋点，用户的每次调用wss链接结果都上报大数据，然后进行统计，经过多天的测试，数据如下： 实验a[微信client]—-wss—&gt;[slb+ssl]—-ws—&gt;[svr] 成功率在 60% 左右。 实验b[微信client]—-wss—-&gt;[slb]—-wss—&gt;[svr+ssl] 成功率在 90% 左右。 总结 https返回502 其实我的测试工具不正确； 如果直接用wss测试工具是不会返回502的。 实验室中验证slb+ssl性能好20ms左右 线上验证slb+ssl成功率不高（这个问题有时间分析下）]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[奶是妈的好]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%A5%B6%E6%98%AF%E5%A6%88%E7%9A%84%E5%A5%BD%2F</url>
    <content type="text"><![CDATA[配方奶是无法复制母乳的，是因为母乳中含有许多微量活性元素、还含有消化酶，可以帮助婴儿消化、吸收； 母乳中含有免疫球蛋白、巨噬细胞、淋巴细胞，能够帮助消灭肠道细菌；含有生长因子，刺激小肠细胞繁殖； 母亲还能将接触到的病菌、病毒抗体通过乳汁传给婴儿。等等。 配方奶虽然可以添加免疫蛋白或乳铁蛋白，或是其他活性物质，但是婴儿的胃酸最终都会杀死它们。而母乳的活性物质会被乳汁脂肪包装、保护起来，躲过胃酸，最终抵达肠道。 但母乳也有不足， 一是缺少维生素D，母乳婴儿应每天补充维生素D制剂； 二是缺少铁，前4~6个月婴儿体内有铁储备，之后就需要通过辅食补充铁； 三是从饮食、药物摄入的毒素以及多种传染病也会通过母乳传递给婴儿。 特别是传统医学里面的下奶、通奶的中草药，这些未知的药物毒素就会传递个婴儿。 总之，母乳喂养的婴儿消化系统、呼吸系统、糖尿病、免疫系统等方面的疾病及肥胖风险都降低了。世界卫生组织建议哺乳期为两年，前6个月纯母乳喂养。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[乙肝]]></title>
    <url>%2F2019%2F07%2F17%2F%E4%B9%99%E8%82%9D%2F</url>
    <content type="text"><![CDATA[我国有9300w乙肝病毒携带者，得了乙肝如果不治疗，任其发展下去，20%的人会转变成肝硬化，这20%肝硬化病人中还会有20%最终会发展为肝癌。如果再加上有喝酒，甚至是酗酒的习惯，得肝癌的比例就更高了。 如果已经确认是乙肝患者了，那唯一要注意的就是三个字——抗病毒。 现在也只有这一种方法可以控制病情的发展，最好的情况下，可以在人生之后几十年中跟健康人没有太大区别。 那么，怎么确定谁是携带者还是病人呢？ 主要看三个指标： 第一个是两对半的检查： 第二个是乙肝病毒 DNA 的检查；检测病毒的活跃程度。 第三个是转氨酶的检查；转氨酶只有肝细胞有，血液中转氨酶数量越多，肝细胞破坏的越严重 怎么治疗呢？ 一种是干扰素的治疗，它是通过打针的方式，疗程一般要1年的时间。国产的干扰素1周打3针，1年下来估计花费6000块钱。进口的干扰素1周打1针，省时间，但是费钱，大约1年下来需要5万块钱。用干扰素治疗，时间比较短，但是效果不好，1年后平均有60%的患者检查指标可以变成正常。 另外一种方式就是口服抗病毒药，正规医院直接开的就是“恩替卡韦”这个药，这也是乙肝抗病毒药物中最好的一种。在治疗指南上，建议要持续吃4年，而且还要外加3年的巩固期，加起来是7年的时间，所以花的钱比干扰素要多。但是效果也会好很多，平均来看，经过1年的治疗以后，乙肝病毒 DNA 检测不到的概率是90%，转氨酶变成正常的概率是80%，所以比干扰素要好很多。如果按照指南上说，吃了4年，几乎两项都能变正常，那就是比例超过95%了。如果再巩固3年，7年下来之后，有部分患者就可以在医生的监督下停药了，还有极少数的患者在之后的一生里也没有吃药，也没有再复发。 有一个误区就是，乙肝病毒携带者可以通过治疗去除病毒，彻底治愈。这个说法，起码现在全世界是没有医生，没有人能做到的。 还有任何中成药、中药，或者奇奇怪怪的疗法，保健品，护肝药，都没有抗病毒作用，保不齐还会有肝毒性，所以都不要采纳 。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[大蒜能杀菌吗]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%A4%A7%E8%92%9C%E8%83%BD%E6%9D%80%E8%8F%8C%E5%90%97%2F</url>
    <content type="text"><![CDATA[大蒜能杀菌的“说法”是有根有据的，也有相关的研究，说大蒜里面包含大蒜素有抑制细菌生长的特性，之后就被各种误导性文章给宣传了，那么我们从科学的思维来分析下这个问题。 1、细菌在胃里，被胃黏液保护着， 大蒜需要经过胃酸洗礼，能不能接触的到胃里的微生物都不一定。比如喝下去的几亿个益生菌，经过胃酸再到肠道就不到100w个了。 2、一公斤大蒜含量0.1克大蒜素。 我们已另一种抗生素（青霉素）为例，如果一个人感染，每天用量是100w个单位青霉素，大概每天是0.6g，持续几天用药，可以治疗感染。那大蒜素也是一样的用量，那每天要吃6公斤。现在医学就是将有效成分提炼、浓缩到一个胶囊里才可以治病。不管是大蒜、还有其他任何食物都不可能对某种疾病有疗效，就是因为里面的有效成分太低了。类似的还有青蒿素，都是要提取才可以。 3、我们继续假设，有方案可以提取，那么吃了它能治疗细菌感染吗？大蒜之所谓分泌大蒜素，从某个角度考虑，它是在分泌一些毒素来杀害或警告要吃掉它的动物和微生物，所以大蒜素很可能是把肠道里所有的微生物都杀死。人体肠道微生物不是都是有害的，大部分还是有益的，如果都杀了， 那么你可能会拉肚子、口臭、身体消瘦等。你会天天吃青霉素吗？ 所以大蒜就是一种调味食品。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[减肥]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%87%8F%E8%82%A5%2F</url>
    <content type="text"><![CDATA[减肥不但让人看着精神，而且确实可以全面降低各种患病的风险。那如何减肥呢？ 1）、减肥靠锻炼、靠运动？从实际效果看，增加运动量来减肥效果是最差的。因为运动耗能特别慢，可是运动之后，马上又想吃饭，只要吃上两口，这效果就变负了。比如每周计划减掉1公斤脂肪，那么折合热量是3850大卡，那么每天就要减去550大卡。550大卡合算到运动，相当于慢跑1小时，每天坚持1小时慢跑是有点难度的，而且在运动后你还不能有进食。即使我们在毅力上可以控制运动后只喝水，但是饥饿的身体是不会欺骗自己的，你会不知不觉的在之后的一日三餐中多吃一点。运动减肥还有一个问题，就是消耗脂肪效率。人体在开始的一个月慢跑1小时消耗550大卡，但是身体适应能力很强，当身体适应了这个强度，那么脂肪的燃烧效率就会降低，所以你要经常改变自己的运动强度和节奏。长期运动即使无法减肥，但是它会让你身体各项指标都增强。 减肥效果最好的就是营养均衡的少吃，想要做到少吃，最需要的是意志力；同时你要考虑的是那些营养均衡的饮食法，否则就是对身体有害。 你一旦走上运动减肥这条路，实际上是给自己增加减肥难度，因为你是在完成减肥和增强体质两项任务，就需要更多的毅力了。如果身边有朋友是通过运动减肥下来，并且没有反弹的话，其他也可以隐射出这个人的意志力是非常强的。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[升高]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%8D%87%E9%AB%98%2F</url>
    <content type="text"><![CDATA[成年后身高就定了，什么训练方法，什么药都不管用。 身高70%是由基因决定的，剩下的30%就是在骨骺线完全闭合之前的营养、锻炼、睡眠，这些因素决定。对身高影响最大的骨头就是大腿和小腿骨的长度，只要它们的骨骺线闭合了，那就基本决定身高了。骨骺线女生在16岁，男生在18岁左右，基本都会闭合，所以成年后不可能增高。想要增高，就只能抓紧在这个时间点前，多跑多跳，这些活动能促进生长激素分泌，配合骨骼生长，就能长高个儿。还有就是注意多睡觉，睡觉时的生长激素分泌量也远高于清醒的时候。 成年后严格地说也不是完全没有增高方法，那就是通过手术。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[事故报告(2019/07/12)]]></title>
    <url>%2F2019%2F07%2F17%2F%E4%BA%8B%E6%95%85%E6%8A%A5%E5%91%8A-1%2F</url>
    <content type="text"><![CDATA[事故时间2019/7/12 11：37 ~ 12：15 ，持续38分钟 事故描述移动用户无法登陆 事故原因根本原因：数据库硬盘物理损坏，RAID修复过程中IO超时。 事故总结短时间的IO超时，目前的服务器是能够承受的，但是长时间的IO超时带来的雪崩问题是需要总结的。 事实上我们的服务至少要把故障时间缩短为IO故障时间，比如IO故障5分钟，那么用户的故障时间也应该为5分钟，但目前的效果却是花费了35分钟的时间才恢复。 服务器的通讯库模型采用多线程竞争消费方式： tcp层将帧数据合并为一个用户请求包，丢入一个消息池 用户层启动n个消费线程，竞争方式去消息池取消息处理 这样设计的好处是每个线程的能力都得到最大的发挥，或者当一个线程出现问题时，其他线程仍然可以正常工作。 实际上如果IO发生长时间超时，用户发现登陆失败，就会不断的重试登陆，最后导致的结果是：消息池的消息堆积越来越多。即使当IO恢复后，消费线程仍然在处理之前堆积着的请求消息，从而故障的恢复时间变的延后。 处理方法 在tcp丢入消息池时给每个消息打一个时间戳 消费线程在处理某些IO消息时，判断当前时间和消息时间戳是否 &gt; n(s),超过则丢弃 这样当IO恢复时，服务也能快速恢复。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[问题的分析方法]]></title>
    <url>%2F2019%2F07%2F12%2F%E9%97%AE%E9%A2%98%E7%9A%84%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前面的文章中，总结了工作中一些常见问题的分析方法，总的来说工具是次要的，科学的分析方法是最重要的。当出现一个问题时，我们应该把问题正确的写下来： 问题是什么 假设问题的原因 证实每个问题的假设 预测实验的结果 观察实验的结果 有实验得出结论 科学方法最主要的目的就是让你能够准确地知道事情的真相，而不会误入歧途。 历史文章中列举了一些常见问题的分析过程： 内存泄漏 内存碎片 踩内存 死锁 崩溃 高cpu 优化情况下的dump分析 想对windbg调试有深入的了解，我推荐的书籍是： 《软件调试》 《高级软件调试》 《格蠹汇编》]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[内存碎片分析]]></title>
    <url>%2F2019%2F07%2F12%2F%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[背景在上篇文章中进程状态可视化方案搭建了可视化界面，对于目前运行环境下的几百个服务器状态就非常清晰了，比如服务的虚拟内存，这时就发现一个服务存在问题： 红色线为virtual Bytes ，大概在1.4G左右绿色线为Private Bytes ， 大概在350M左右 那么应该是出现了严重的内存碎片（Fragmentation)。 往事在众多疑难问题定位过程中，我一直对刚参加工作时分析的一个内存碎片问题印象非常深刻，因为这个问题锻炼了我坚韧的耐力和大幅度技能的提升。 刚工作的时候被分配到一个视频组件组，主要功能就是网络收流、报文解析、音视频解码、视频渲染、音频同步播放，和当时的视频播放软件最大的区别就是多窗口，最大支持128个视频流同时播放。 当时一个大版本发布之后，长时间运行（1天）组件就会出现内存申请失败，这个问题刚好就交给我处理，当时整个公司都没有人会用分析dump，大家都是用vs进行调试，还有代码的回滚是不可能的，这个版本合入太多功能，其他团队、客户都等着这个版本呢。所以我的思路 第一步是减少问题复现的时间，通过3天左右的观察、验证，找到了业务流程，写了一个测试demo，将原来需要1天才复现的问题，减少到只需要2个小时左右。 在观察、验证的3天时间，查资料，找原因，把《windows核心编程》 内存方面仔细研读，上网找资料。大概可以锁定是内存碎片导致，而不是内存泄漏。 进行二分法对模块进行分解测试。所以短时间内我又要把整个组件的模块设计、流程学习一遍。 建立execl对测试结果数据进行分析 3~4 步骤坚持了1周左右。 大家可能都觉得应该能找到问题了吧？ 结论是 no， 没找到原因。 我们可以梳理下内存碎片的原因，大致就是 a、b 两个大小内存随机申请，最后会导致一个连续内存会被a、b大小内存随机分裂，最后有一个更大的C就无法申请到内存。如果采用二分划分，那么很有可能我们把C给排除了，把a、b 模块保留，这时候程序当然稳定运行，execl表格体现出来的就是这个a、b模块正常，但实际是存在问题的。 现实的程序远比上面的例子复杂的多，模块、开源库、第三方依赖都得考虑，这也是当时整理了1周左右的数据仍然定位不到原因。 问题的分析已经过去了1周半，却没有任何进展，手上堆积的事情也越来越多，这1周半几乎都是7~23点，身体、精神也吃不消，所以就换了一个同事重新整理execl；一周过后也是没有头绪。在这一周中，我赶完落后的项目进度，然后继续查找资料，在网上看到了一本《软件调试》的书籍，学习堆的知识，这一周客户、boss都催的紧，粗略的看完“堆”章节，里面有句话吸引到了我：123456789Heap中有两个参数1、HeapDeCommitFreeBlockThreshold2、HeapDecommitTotalFreeThreshold考虑到应用程序很可能还会立刻申请内存并减少与内存管理器的交互次数，内存释放时需要同时满足两个条件才能被立即解除提交1、释放的堆块超过HeapDeCommitFreeBlockThreshold的值（比如4KB）2、堆上的总空闲空间达到HeapDecommitTotalFreeThreshold（比如64K）否则，堆管理器会将这个块加到空闲块列表中，并更新堆管理器的总空闲值。 刚好我们的组件中有一个大小申请65535大小的空间，会不会因为刚好没到64K导致的？ 立刻把模块中的65535修改为65535+1， 经过验证后，程序还真稳定了……….其实也没根本解决问题，只是怀疑，所以内心一直觉的有所欠缺。 工作实在太忙，能力也有限，解决之后也没时间总结这个问题，还有好多事情要加班干呢……… 之后的windows上项目基本就很少出现内存碎片的问题，所以就没有这方面的分析经验。 问题再次分析刚好有程序又出现了类似问题，所以试着用dump来分析。首先我对出现问题的程序代码一点不熟悉，所以我很难去构建复现条件，只能暂时通过dump来分析。 上面截图显示了7天的内存变化，很稳定，有查看了30天的内存，基本也是一样，virtual size 还足够，Private Bytes也不高，所以问题的紧急程度不高，估摸着程序再继续运行一个月也没问题。保存了fulldump。 基础知识我们大致要了解内存申请的过程，commit、reserv、virtual size、Private Bytes的概念。堆的三个重要结构体：HEAP、Segment、Enty。不了解的话，可以先照猫画虎 来按步骤分析一遍。 dump下载下载提取码：ykgb windbgheap -s加载dump信息，输入1234567891011121314151617181920212223242526270:000&gt; !heap -sSEGMENT HEAP ERROR: failed to initialize the extentionLFH Key : 0x58b8f7f8Termination on corruption : DISABLED Heap Flags Reserv Commit Virt Free List UCR Virt Lock Fast (k) (k) (k) (k) length blocks cont. heap -----------------------------------------------------------------------------002a0000 00000002 1246976 510132 1246976 261431 2450 1382 0 5d6 LFH External fragmentation 51 % (2450 free blocks) Virtual address fragmentation 59 % (1382 uncommited ranges)00590000 00001002 3136 1636 3136 860 6 3 0 471b LFH External fragmentation 52 % (6 free blocks)00490000 00001002 256 4 256 1 1 1 0 0 004d0000 00001002 1280 420 1280 122 50 2 0 0 LFHVirtual block: 032f0000 - 032f0000 (size 00000000)Virtual block: 05310000 - 05310000 (size 00000000)00910000 00001002 1280 556 1280 136 4 2 2 0 LFH00b20000 00001002 64 12 64 4 2 1 0 0 00110000 00001002 64 4 64 2 1 1 0 0 03120000 00001002 64 4 64 2 1 1 0 0 00520000 00011002 256 4 256 1 2 1 0 0 032b0000 00001002 256 4 256 1 2 1 0 0 034d0000 00001002 3328 1996 3328 1050 49 3 0 6 LFH External fragmentation 52 % (49 free blocks)05420000 00001002 64 16 64 13 1 1 0 0 00960000 00001002 1088 212 1088 77 2 2 0 0 ----------------------------------------------------------------------------- 也可以看出 002a0000 的resevr 比 commit 大了很多。 ps:里面有“Virtual block:” 代表的是超过508K的内存是使用HeapVirtualAlloc申请的，其中（size 00000000）指的是找不到HEAP_VIRTUAL_ALLOC_ENTRY的结构体定义（不知道怎么解决）。 !heap -a 002a0000打印该堆段所有的内存信息，（截取一部分）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455Segment80 at 54790000: Flags: 00000000 Base: 54790000 First Entry: 54790040 Last Entry: 55760000 Total Pages: 00000fd0 Total UnCommit: 00000b0f Largest UnCommit:00000000 UnCommitted Ranges: (9) Heap entries for Segment80 in Heap 002a0000 address: psize . size flags state (requested size) 54790000: 00000 . 00040 [101] - busy (3f) 54790040: 00040 . 40000 [101] - busy (3fff8) Internal 547d0040: 40000 . 40000 [101] - busy (3fff8) Internal 54810040: 40000 . 40000 [101] - busy (3fff8) Internal 54850040: 40000 . 00fa0 [100] 54850fe0: 00fa0 . 00020 [111] - busy (1d) 54851000: 0063d000 - uncommitted bytes. 54e8e000: 00000 . 01000 [100] 54e8f000: 01000 . 40000 [101] - busy (3fff8) Internal 54ecf000: 40000 . 40000 [101] - busy (3fff8) Internal 54f0f000: 40000 . 40000 [101] - busy (3fff8) Internal 54f4f000: 40000 . 40fe0 [100] 54f8ffe0: 40fe0 . 00020 [111] - busy (1d) 54f90000: 000fe000 - uncommitted bytes. 5508e000: 00000 . 40000 [100] 550ce000: 40000 . 01000 [101] - busy (ff8) Internal 550cf000: 01000 . 40000 [100] 5510f000: 40000 . 20000 [101] - busy (1fff8) Internal 5512f000: 20000 . 10000 [101] - busy (fff8) Internal 5513f000: 10000 . 03fe0 [100] 55142fe0: 03fe0 . 00020 [111] - busy (1d) 55143000: 0000b000 - uncommitted bytes. 5514e000: 00000 . 40000 [100] 5518e000: 40000 . 40000 [101] - busy (3fff8) Internal 551ce000: 40000 . 00fe0 [100] 551cefe0: 00fe0 . 00020 [111] - busy (1d) 551cf000: 001ff000 - uncommitted bytes. 553ce000: 00000 . 40840 [100] 5540e840: 40840 . 40000 [101] - busy (3fff8) Internal 5544e840: 40000 . 00400 [101] - busy (3f8) Internal 5544ec40: 00400 . 003a0 [100] 5544efe0: 003a0 . 00020 [111] - busy (1d) 5544f000: 000be000 - uncommitted bytes. 5550d000: 00000 . 01000 [100] 5550e000: 01000 . 40000 [101] - busy (3fff8) Internal 5554e000: 40000 . 40fe0 [100] 5558efe0: 40fe0 . 00020 [111] - busy (1d) 5558f000: 0000e000 - uncommitted bytes. 5559d000: 00000 . 00800 [100] 5559d800: 00800 . 10000 [101] - busy (fff8) Internal 555ad800: 10000 . 10000 [101] - busy (fff8) Internal 555bd800: 10000 . 407e0 [100] 555fdfe0: 407e0 . 00020 [111] - busy (1d) 简单的含义123456789Segment80 at 54790000: ----- 第80个堆块链表 Flags: 00000000 Base: 54790000 First Entry: 54790040 Last Entry: 55760000 Total Pages: 00000fd0 Total UnCommit: 00000b0f Largest UnCommit:00000000 UnCommitted Ranges: (9) ------ 有9个未提交的内存 123456789address : psize . size [flags] state (requested size) &lt;debug flags&gt;堆块地址 前一堆块大小 当前堆块大小 状态 状态描述 用户实际分配的大小 哪种堆调试支持5544efe0: 003a0 . 00020 [111] - busy (1d)5544efe0: enty 的地址： 5544efe0+8 就是内存实际地址003a0: 上一个内存块的大小0020: 当前堆块大小busy： 使用中1d: 实际分配的大小 那么把所有链表统计一下大概出现了 1300多次的uncommitted bytes，其中大致浏览存在着1000多次的40000内存busy状态，基本上每个uncommitted 的内存附件都有一个40000的内存，那么是否可以怀疑是40000导致的呢？40000的堆块大小实际用户申请大小是 3fff8，刚好是256K-8 。逐一查看内存内容也没有找到任何线索。 至此dump的分析导致为此，剩下的过程就需要查看是哪里申请了这么大的内存？ 代码review 用gflags打开栈回溯，问题复现后，通过内存地址进行栈回溯找到内存申请的代码 总结问题其实没有被定位，后续有时间会继续跟踪此问题。事实上即使找到内存申请的地方，也不一定能解决。实际对于这种大块(&gt;4KB)的内存申请应该需要谨慎，写代码中也应该尽量避免大块内存的申请，可以考虑使用内存池；windows本身是有低块堆来解决小内存的申请，但申请的内存大小有限；偷懒可以直接使用jemalloc/tcmalloc库本文只是提供了一种分析思路。 后续分析原因 内存碎片分析(2)]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[进程状态可视化方案]]></title>
    <url>%2F2019%2F07%2F10%2F%E8%BF%9B%E7%A8%8B%E4%BF%A1%E6%81%AF%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[背景当出现问题时，我们收集无法查看历史的进程信息，比如前一小时的cpu利用率、内存使用量等信息。本方案结合大数据的elk系统提供可视化的报表数据。 elk = Elasticsearch Logstash Kibana 搭建一套集中式日志系统。 每个进程定时5s上报进程状态到elk系统，然后通过kibana进行报表输出。 状态上报协议udp + json 每个进程接入组件后，组件会定时启动一个线程以5s间隔上报进程状态，通过udp协议，json负载的格式。 采集方式使用windows性能计数器api：API介绍： 1、PdhOpenQuery：获取性能监视器数据查询句柄； 2、PdhAddCounter：添加计数器； 3、PdhCollectQueryData：查询性能监视器数据； 4、PdhGetFormattedCounterValue：获取指定计数器数值； 参考代码： https://blog.csdn.net/sqcfj/article/details/7307148 进程关键状态信息进程已处理消息数作为后台服务器，通过该数值可以评估该台服务器的负载 进程消息队列堆积数服务器采用生产、竞争消费模式设计，当消费线程无法处理时，生产队列会发生堆积，所以需要定时上报生产者队列当前数量，已评估服务器是否正常。 比如堆积 &gt;300 时，钉钉警告 ; &gt; 1000 并持续上涨时，需及时进行问题分析 进程cpu1pdh: \\Process(&quot;calc&quot;)\\% Processor Time 建议值80以内。获取的是该进程在单核下的cpu值。 进程handle count1pdh: \\Process(&quot;calc&quot;)\\Handle Count 内核对象数量。如果程序稳定，handle应该维持在一个稳定区间，持续上涨说明存在handle leak 进程提交内存1pdh: \\Process(&quot;calc&quot;)\\Private Bytes 提交内存，如果持续上涨，说明存在 memory leak 进程虚拟内存（保留空间）1pdh: \\Process(&quot;calc&quot;)\\Virtual Bytes 保留内存，vitrual bytes 和 private byte 一般保持一个相对稳定的比例关系。大Virtual size（比如1.0G）时如果他们的比例大于 &gt;2 时，需要考虑是否存在严重的内存碎片，仅参考意义 进程ID1pdh: \\Process(&quot;calc&quot;)\\ID Process 进程id号，如果发生变化则说明服务存在重启 进程客户端数量统计服务器当前tcp的连接数 进程的磁盘空间其他进程日志导致磁盘满，导致服务异常， 当磁盘空间&lt;1.0G时上报告警 和钉钉对接状态的上报只解决了历史的信息查询，对于当前紧急问题需要及时通知到钉钉群。 elk 系统和告警中心进行对接负载中的json中携带 “level” 字段，当 = “warn” 时elk转发消息给告警中心，告警中心处理钉钉消息 组件直接发送钉钉通过json中的 “level” = “warn” 时，组件直接发送告警信息到指定钉钉群 kibana报表自己是报表白痴，所以操作方式自己作为笔记写下来：1234567visualize选择“line”选择“hallgame”(自定义的）过滤器Metrics 的Y-Axis 选择“Max”, Field 选择”tcCpu”(举例)，lable 填写 &quot;cpu利用率&quot;Buckets 的X-Axis 选择”Data Histogram“Buchets 的Split Series 选择”terms“，Filed 选择&quot;svraddr&quot;(代表不同的进程）， order by 默认（指得是排序），size 填20均可然后运行，就可以看到所有服务的 cpu利用率了。 效果在kibana中配置报表消息，可看到如下效果：]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[electron学习]]></title>
    <url>%2F2019%2F07%2F05%2Felectron%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[介绍主要讲我第一次使用electron的感受，简直是非常糟心！ 安装步骤安装node.js设置npm代理1npm install -g cnpm --registry=https://registry.npm.taobao.org electron 项目npm install时经常会下载卡死，然后报错误，很是麻烦，即使设置了代理也是很慢，所以很不想用electron,要经常尝试 npm install。 安装electron123npm install -g electron --verbose--verbose 查看安装进度 输入“electron” doc ： https://electronjs.org/docs?utm_source=default_app 查看文档 repository: github 资源 api demo 如上可看可不看，我是从官网开始入门的： https://electronjs.org/ 学习下载 electron api demo下载 electron-quick-start按照提示一步步都还算正常 参考api demo尝试 糟糕的开始 自己在electron-quick-start 上怎么验证都没有任何反应，index.html、renderer.js 验证了很多次就是不行。无奈只能去github 找到electron-api-demos-master 源码下载查看，并比较了相关代码，并没有发现自己哪里有写错。上网搜索electron 提供的其他示例“simple-samples”，也未找到相关原因。 调试在main.js 中增加 ，12// Open the DevTools. mainWindow.webContents.openDevTools(); 提示”const {BrowserWindow} = require(‘electron’).remote “ 这行“Uncaught ReferenceError: require is not defined”， 还有如下提示12For more information and help, consulthttps://electronjs.org/docs/tutorial/security. 打开提示网站将网站看完，并看到“Disable the remote module”，并去electron api demo 中查找main.js 中窗口的对应设置，发现需要增加 “nodeIntegration: true” 12345678910function createWindow () &#123; // Create the browser window. mainWindow = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; preload: path.join(__dirname, &apos;preload.js&apos;), nodeIntegration: true &#125; &#125;) 测试验证增加之后，点击‘new-window’ 按钮，并弹出了一个新的对话框。 构建安装electron-builder1cnpm install -g electron-builder 设置 package.json简单设置123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;xxxx&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;main.js&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;electron .&quot;, &quot;pack&quot;: &quot;electron-builder --dir&quot;, &quot;dist&quot;: &quot;electron-builder&quot; &#125;, &quot;author&quot;: &quot;xxxx&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;build&quot;: &#123; &quot;productName&quot;:&quot;xxxx&quot;, &quot;appId&quot;: &quot;com.xxx.xxxxx&quot;, &quot;copyright&quot;:&quot;xxxx.home&quot;, &quot;directories&quot;: &#123; &quot;output&quot;: &quot;build&quot; &#125;, &quot;win&quot;: &#123; &#125; &#125;, &quot;devDependencies&quot;:&#123; &quot;electron&quot;: &quot;8.2.3&quot; //正确设置版本，否则会&quot;Cannot compute electron version from installed node&quot; &#125;&#125; 打包1electron-builder 依赖包无法下载，则直接使用浏览器下载，并放置的缓存目录1C:\Users\yourname\AppData\Local\electron\Cache 下 要下载1234electron-v8.2.3-win32-x64.zipwinCodeSign-2.6.0.7znsis-3.0.4.1.7znsis-resources-3.4.1.7z 打包完成之后，就是一个40M左右的安装包 总结别人的demo是由浅入深，electron第一个demo就困了我一天，这坑也太大了。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[禅与摩托车维修艺术]]></title>
    <url>%2F2019%2F07%2F04%2F%E7%A6%85%E4%B8%8E%E6%91%A9%E6%89%98%E8%BD%A6%E7%BB%B4%E4%BF%AE%E8%89%BA%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[时间2019/07/04 ~/07/24 介绍去年在某网站上看到有人推荐这本书，刚好自己也骑了一段时间的摩托，所以就买了这本书。今天翻开看了几页，还是非常有意思的。至于这本书有多好看，你自己来感受吧！ 书看了100多页，手贱google了一下“斐德洛”，奉劝大家不要google“斐德洛”，带着好奇看完吧。 这并不是一本如何修理摩托车的书，而是一本人生哲理书。123456在这次旅行中，我想应该注意一点，更深入地研究，看看是否能够了解究竟是什么把人和人的工作分离开来，进而了解20世纪的人究竟出了什么问题。我并不想仓促行事，因为仓促本身就是20世界最要不得的态度，当你做某件事情的时候，一旦要求快，就表示你再也不关心它，而想去做别的事。所以我想慢慢来，用我找到被剪断了的销子的态度，有了这种态度才能发现原因，这样才能仔细而且透彻地进行这件事，除此之外，别无他法。 摘录12345678骑摩托车旅游和其他的方式完全不同。坐在汽车里，你只是被局限在一个小空间之内，因为已经习惯了，你意识不到从车窗向外看风景和看电视差不多。你只是个被动的观众，景物只能呆板地从窗外飞驰而过。而摩托车可就不同了。它没有什么车窗玻璃在面前阻挡你地视野，你会感到自己和大自然紧密的结合在了一起。你就处在景致之中，而不再是观众，你能感受到那中身临其境的震撼。脚下飞驰而过的是实实在在的水泥公路，和你走过的土地没有什么两样。它结结实实地躺在那儿，虽然因为车速快而显得模糊，但是你可以随时停车，及时感受它的存在，让那份踏实感深深印在你的脑海中。 123如果人类所有已知的知识体系是一个巨大的体系，那么心灵的高山地带就出现在这个体系的最高处，它是所有思想当中最抽象也是最普遍的。很少有人到此一游，因为你不能从这一趟旅程当中获得任何实质上的利益。但是就像我们周遭的这一片高山区，它有它庄严的美感，所以对某些人来说，即使费劲九牛二虎之力到此一游也是值得的。来到心灵的高山地带，一个人必须习惯不稳定的稀薄空气，还有大量的问题以及各种假设的答案。这种情形会不断地扩大，一直到这个人几乎无法控制，因为迟疑是否接近它，因为他害怕很可能会在其中迷失，而且永远找不到出路。 结束坚持看了200页左右，等过个3、4年再来看吧。关于民哲的书籍，自身能力、知识还达不到理解的程度，看下去收获不会太大。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蛋白质]]></title>
    <url>%2F2019%2F07%2F03%2F%E8%9B%8B%E7%99%BD%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[蛋白质即使有某种神奇的功效，吃它也不能让它直接进入人体发挥作用，而是会再胃肠中被消化成氨基酸，再被人体吸收，所以不管吃的是什么蛋白质，结局都一样，都是消化成了组成蛋白质的氨基酸。组成蛋白质的氨基酸共有20种。有的蛋白质（鸡蛋、牛奶、肉类的蛋白质）含有全部的20种氨基酸，叫做完全蛋白质，营养价值高；而有的蛋白质（植物蛋白）则是不完全蛋白，缺某种氨基酸，营养价值较差；胶原蛋白缺少色氨酸和半胱胺酸，是不完全蛋白，因此营养价值不高。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[黄疸]]></title>
    <url>%2F2019%2F07%2F03%2F%E9%BB%84%E7%96%B8%2F</url>
    <content type="text"><![CDATA[黄疸通常是肝脏等器官有疾病的症状，但是婴儿则不然。90%的新生儿在出生一天后会开始出现黄疸；这是因为新生儿红细胞数量多，更新快，因此胆红素高，但是肝脏功能还不完善，处理能力很低。一般持续两周左右黄疸消失。黄疸一般来说是无害的，但是持续时间过长，有可能会造成脑损伤。因此需要治疗，国际流行方法使用的是光疗，使用蓝光照射婴儿皮肤；少数婴儿是疾病引起的，比如胆道锁闭，这就需要手术。国内的一些医院，夸大了黄疸的严重性，需要用药，对此是没有西药的，所以就只能用中药“茵（陈）栀（子）黄（芩）”。目前并没有科学依据和临床试验能证明有效，反而增加了婴儿肝脏、肾脏的药物损害。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[妙趣横生-博弈论]]></title>
    <url>%2F2019%2F07%2F03%2F%E5%A6%99%E8%B6%A3%E6%A8%AA%E7%94%9F-%E5%8D%9A%E5%BC%88%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[时间2019/06/29 ~ 2019/07/03 感想看了1/3 看不下去了，主要是没有大块的时间来阅读消化，里面讲了很多博弈的例子。剩下的估计要等以后有时间再看了。摘录了其中比较好的观点：1博弈论中最重要的教训：一个人必须理解对方的想法。在本性上，人们都倾向于以自我为中心，只关注自己的理解和自身的需要。但策略的艺术要求，不要以自我为中心，要理解他人的立场、观念以及看重什么，并运用这种理解来指导工作。 1人与人之间的博弈，对于我们普通大众来说，能够做到更加成熟，充满宽容和对他人的理解就很不错了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[信息来源介绍]]></title>
    <url>%2F2019%2F07%2F03%2F%E4%BF%A1%E6%81%AF%E6%9D%A5%E6%BA%90%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[收集了自己仅几年看到、听到、经历过的一些科学健康方法，信息来源： 卓老板聊科技（得到app、喜马拉雅） 方舟子书籍、音频节目（企鹅fm） 哈弗家庭医生全书（推荐家中必备） 默沙东诊疗手册（app、web） 科普中国（app） 丁香园 科普书籍《肠子的小心思》 《众病之王-癌》 google 比较喜欢 卓老板聊科技 的节目，听的多了，知识的收获只是一小部分，更多的学习到科学的思维方式，并让其成为日常生活思考的一部分，这对于我是收获最大的。 后面的内容会摘抄一些对我个人有帮助的一些知识。]]></content>
      <categories>
        <category>健康知识</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[几种语言的http服务框架]]></title>
    <url>%2F2019%2F06%2F25%2F%E5%87%A0%E7%A7%8D%E8%AF%AD%E8%A8%80%E7%9A%84http%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[介绍刚好需要做一个http服务，所以简单的研究了下几种语言http框架的入门使用 C++libevent+http https://github.com/yingchengpa/httpsvr 自己写了一个多线程版本的，封装了大部分功能，只要注册指定 uri的回调处理就可以了。 性能、并发性良好。 mongoose之前在某个服务里面使用，主要用于获取配置，调用频率不高，使用简单 pythonFlask使用vs2019 创建一个flask工程，然后按照提示使用pip 安装flask，就可以实现一个简单的http服务。使用起来还是挺简单的。没验证过性能、并发性如何。 gogin使用起来和flask差不多。go就是需要科学上网比较麻烦 luaopenrestrynginx.conf 配置文件12345678910111213141516171819202122232425262728293031323334 server &#123; listen 8090; server_name localhost; # 获取post 请求的body lua_need_request_body on; # 对于开发研究，可以对代码 cache 进行关闭，这样不必每次都重新加载 nginx。 lua_code_cache off; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; location /v1.0/open/ai &#123; default_type text/html; content_by_lua_file ai.lua; &#125; location /v1.0/open/action &#123; default_type text/html; content_by_lua_block &#123; dofile(&quot;action.lua&quot;) &#125; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 12345在解压根目录下创建 ai.lua、action.lua 内容如下local data = ngx.req.get_body_data()local method = ngx.req.get_method()ngx.say(&quot;the method is &quot;, method) 12nginx lua api：https://github.com/openresty/lua-nginx-module#nginx-api-for-lua 其他语言比如.net、java、js 应该有更多http服务框架，这部分不了解！]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[魔鬼经济学（4）]]></title>
    <url>%2F2019%2F06%2F21%2F%E9%AD%94%E9%AC%BC%E7%BB%8F%E6%B5%8E%E5%AD%A6%EF%BC%884%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读书时间2019/06/21~2019/06/28 讲的是作者博客里面有趣的问题，快速的就看完了。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[参数错误导致异常]]></title>
    <url>%2F2019%2F06%2F19%2F%E5%8F%82%E6%95%B0%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[背景某游戏钉钉联系我说出现dump导致模板异常，因为模板是我负责的，所以就顺便看了下 dump链接：https://pan.baidu.com/s/1pyrJXtv26zLvhvfS3Ts2rA提取码：48fo 分析过程查看异常点1234567891011121314151617181920212223240:034&gt; .ecxr;kveax=0631f54c ebx=09798e18 ecx=00000003 edx=00000000 esi=740cbc8c edi=0631f5eceip=754bc54f esp=0631f54c ebp=0631f59c iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000202KERNELBASE!RaiseException+0x58:754bc54f c9 leave *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 0631f59c 73d69339 e06d7363 00000001 00000003 KERNELBASE!RaiseException+0x58 (FPO: [Non-Fpo])0631f5dc 7402ee11 0631f5ec 740cbc8c 740db540 msvcr120!_CxxThrowException+0x5b (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]*** WARNING: Unable to verify checksum for cfddsvr.exe0631f5f0 009f89ea 0070f490 0731e5f8 0070f498 mfc120!AfxThrowInvalidArgException+0x19 (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\except.cpp @ 228]0631f608 00940e55 0999e748 00000008 00000000 cfddsvr!CHwTable::SetBottom+0xda (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_gametplserver1.0\tcghw1.0\trunk\tcghw\tcghw.cpp @ 849]0631f624 009610bb 0999e748 37cbe17c 00000000 cfddsvr!CGameTable::OnSetBottom+0x185 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_cfddsvr\common\cfdd\cfddtbl.cpp @ 880]0631f6fc 00960a48 071f8bb8 09998398 007047d8 cfddsvr!CGameServer::OnSetBottom+0x55b (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_cfddsvr\cfddsvr\server.cpp @ 709]0631f76c 00968ed4 071f8bb8 09998398 0070f498 cfddsvr!CGameServer::OnRequest+0x1f8 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_cfddsvr\cfddsvr\server.cpp @ 68]0631f794 0096da9d 00000000 02950748 029c18e0 cfddsvr!CIocpWorker::DoWorkLoop+0xa40631f7ac 0096da6b 0631f7ec 73d7c01d 0070f490 cfddsvr!CBaseWorker::WorkerThreadProc+0x2d0631f7b4 73d7c01d 0070f490 a7e5bfa1 00000000 cfddsvr!CBaseWorker::WorkerThreadFunc+0xb0631f7ec 73d7c001 00000000 0631f804 769c343d msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]0631f7f8 769c343d 029c18e0 0631f844 77109802 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]0631f804 77109802 029c18e0 e12c35d8 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])0631f844 771097d5 73d7bfb4 029c18e0 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])0631f85c 00000000 73d7bfb4 029c18e0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 出错代码1234567891011121314void CHwTable::SetBottom(LPSET_BOTTOM pSetBottom)&#123; memcpy(m_nBottomIDs, pSetBottom-&gt;nBottomIDs, sizeof(m_nBottomIDs)); for(int i = 0; i &lt; m_nBottomCards; i++)&#123; int shape = CalculateCardShape(m_nBottomIDs[i]); int value = CalculateCardValue(m_nBottomIDs[i]); m_nCardsLayIn[m_nBanker][shape * m_nLayoutMod + value]--; int x = GetCardNO(m_nBottomIDs[i]); m_aryCard[x].nStatus = CS_BOTTOM; //---- 849 m_aryCard[x].nChairNO = m_nBanker; &#125;&#125; 心中猜测应该就是 x 计算错误，导致m_aryCard(CArray)异常了 !analyze -v 查看异常原因12345678EXCEPTION_RECORD: (.exr -1)ExceptionAddress: 754bc54f (KERNELBASE!RaiseException+0x00000058) ExceptionCode: e06d7363 (C++ EH exception) ExceptionFlags: 00000001NumberParameters: 3 Parameter[0]: 19930520 Parameter[1]: 0631f5ec Parameter[2]: 740cbc8c 是一个C++异常，很符合MFC的CArray的行为，具体查看原因 123456780:034&gt; dd 740cbc8c l4740cbc8c 00000000 00000000 00000000 740cbc9c0:034&gt; dd 740cbc9c l2740cbc9c 00000005 740cbc700:034&gt; dd 740cbc70 l2740cbc70 00000001 740e0d380:034&gt; da 740e0d38 + 8740e0d40 &quot;.PAVCInvalidArgException@@&quot; 明显的一个 “InvalidArgException” 说明有的同学想看下CHwTable::SetBottom 中x 的参数内容，但是却看不到，其实是因为模板（publish_gametplserver1.0）层是开启了代码优化，所以看不到内容； 可以切换到上层CGameTable::OnSetBottom 这里查看成员变量的值（这个模块是没有开启优化的）]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[转义字符导致hiredis异常]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%BC%E8%87%B4hiredis%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[背景C++ 在使用redis时使用的是hiredis库，在项目中碰到一个问题，某天钉钉提示服务catch error，于是就分析保存的dump dump 路径链接：https://pan.baidu.com/s/1CdhOVKwtP5fabTyab8UTDw提取码：8ull 分析过程.ecxr加载符号文件，然后‘.ecxr’ ‘kv’1234567891011121314151617181920212223242526270:018&gt; .ecxr*** WARNING: Unable to verify checksum for actiksvr.exeeax=00000005 ebx=004f7228 ecx=00000001 edx=00000005 esi=e298348b edi=1002002beip=7457211c esp=062ff8a8 ebp=062ff8d4 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010202msvcr120!TrailDownVec+0x14f:7457211c 8a16 mov dl,byte ptr [esi] ds:002b:e298348b=??0:018&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 062ff8b4 011a36d6 1002002b e298348b 004f7228 msvcr120!TrailDownVec+0x14f (FPO: [3,0,2]) [f:\dd\vctools\crt\crtw32\string\i386\memcpy.asm @ 844]062ff8d4 011a2da2 00000003 e298348b 004f7228 actiksvr!sdscatlen+0x56062ff92c 011a2ae3 062ff940 0bf7d158 062ff968 actiksvr!redisvFormatCommand+0x242062ff944 011a2472 0052ce80 0bf7d158 062ff968 actiksvr!redisvAppendCommand+0x13062ff958 01181e31 0052ce80 0bf7d158 e298348b actiksvr!redisAppendCommand+0x12062ffa48 011820ca 0c6c2335 062ffa5c e2983443 actiksvr!CRedisMaster::SetPlayerInfo+0x1a1 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_gamechannel\actiksvr\redismaster.cpp @ 71]062ffa80 01189135 0c6c2335 062ffb00 e298327f actiksvr!CRedisMaster::SetPlayerInfo+0x6a (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_gamechannel\actiksvr\redismaster.cpp @ 42]062ffcbc 0118975a 07660e78 0f2f9490 03dfa5d0 actiksvr!CSockServer::OnLogon+0x215 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_gamechannel\actiksvr\socksvr.cpp @ 553]062ffd0c 0118eb84 07660e78 0f2f9490 001df010 actiksvr!CSockServer::OnRequest+0x2aa (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_gamechannel\actiksvr\socksvr.cpp @ 227]062ffd34 0119367d 00000000 04d611d0 03db0be0 actiksvr!CIocpWorker::DoWorkLoop+0xa4062ffd4c 0119364b 062ffd8c 7458c01d 001df008 actiksvr!CBaseWorker::WorkerThreadProc+0x2d062ffd54 7458c01d 001df008 53e9f2fa 00000000 actiksvr!CBaseWorker::WorkerThreadFunc+0xb062ffd8c 7458c001 00000000 062ffda4 7702336a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]062ffd98 7702336a 03db0be0 062ffde4 77559902 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]062ffda4 77559902 03db0be0 c036ffd3 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])062ffde4 775598d5 7458bfb4 03db0be0 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])062ffdfc 00000000 7458bfb4 03db0be0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 因为有类似经验（看过hiredis解析代码），猜测应该就是有特殊字符（比如 % 等）导致 查看参数通过 ‘local’ 查看CSockServer::OnLogon 对应代码的参数，发现 其中imei 字符串中包含了 ‘%’ ,然后再编写demo验证，问题必现。 解决方法知道原因，解决方法就很多了， 可以用标准的redis方法void redisCommand(redisContext c, const char *format, …); 我使用的是替换法：1234inline void redis_cmd_escape(std::string &amp;str)&#123; replace_all(str, &quot;%&quot;, &quot;%%&quot;);&#125;]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开启代码优化分析dump]]></title>
    <url>%2F2019%2F06%2F18%2F%E5%BC%80%E5%90%AF%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E5%88%86%E6%9E%90dump%2F</url>
    <content type="text"><![CDATA[背景前面都是讲解程序未开启优化时的问题定位。当程序未开启优化时，通过‘local’，‘watch’,’kv’ 的参数信息都是正确的，所以很容易可以通过变量的内容确定问题的原因。 但是如果开启了程序优化功能，那么编译器会优化代码的结构，windbg还是按照原来的方法来解析变量，那么大多情况会出现不正确的，比如最重要的this指针，未优化时都是固定在ecx寄存器中，但是开启了优化后就需要自己来查找对应的this地址。 前段时间川麻服务出现崩溃，就遇到了这么一个问题。 dump信息下载链接：链接：https://pan.baidu.com/s/1nQOksK2QLUZsQsl7PhgDCw提取码：4c1o c/c++的调用约定C 语言： cdecl、stdcall、fastcall、naked、pascal。 C++ 语言： cdecl、stdcall、fastcall、naked、pascal、thiscall，比 C 语言多出一种 thiscall 调用方式。 thiscall 调用方式是唯一一种不能显示指定的修饰符。它是C++类成员函数缺省的调用方式。由于成员函数调用还有一个this指针，因此必须用这种特殊的调用方式。 thiscall调用方式意味着： （1）参数从右向左压入栈。 （2）如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压入栈后被压入栈。参数个数不定的，由调用者清理堆栈，否则由函数自己清理堆栈。 可以看到，对于参数个数固定的情况，它类似于stdcall，不定时则类似于cdecl。 分析dump下载指定的dump，并使用windbg打开，加载好符号文件。输入命令：”.ecxr” ,显示异常上下文：123456789101112131415160:043&amp; .ecxreax=0000ffff ebx=00435a18 ecx=04921dc4 edx=060de888 esi=0d7ed468 edi=00000001eip=00b9d4e7 esp=070efde8 ebp=070efdf4 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010202xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x37:00b9d4e7 ff30 push dword ptr [eax] ds:002b:0000ffff=????????0:043&amp; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 070efdf4 00bf54dc 00435f8c 070efe74 0c8bc458 xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x37 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_xzmosvr\gamesvr\commonbase\commonbaseserver.cpp @ 218]070efe88 733dc01d 00000000 76fc49d0 00000000 xzmoSvr!CMainServer::SoapThreadProc+0x29c (FPO: [Non-Fpo]) (CONV: thiscall) [d:\jenkins\workspace\publish_gametplserver2.0\tcgame2.0\trunk\tcgsvr.cpp @ 9565]070efec0 733dc001 00000000 070efed8 75ad338a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]070efecc 75ad338a 04981c78 070eff18 77b89f72 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]070efed8 77b89f72 04981c78 75257f9b 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])070eff18 77b89f45 733dbfb4 04981c78 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])070eff30 00000000 733dbfb4 04981c78 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 大致可以猜测是访问非法指针导致的异常。然后查看代码：123456789101112131415BOOL CCommonBaseServer::DealApplyBaseWelfareEx(LPSOAP_SERVICE pSoapService, IXYSoapClientPtr&amp;amp; pSoapClient, LPCONTEXT_HEAD lpContext, LPREQUEST lpRequest)&#123; BOOL bResult = __super::DealApplyBaseWelfare(pSoapService, pSoapClient, lpContext, lpRequest); LPAPPLY_BASEWELFARE_EX lpApplyWelfare = (LPAPPLY_BASEWELFARE_EX)lpRequest-&amp;pDataPtr; if (bResult &amp;amp;&amp;amp; lpApplyWelfare &amp;amp;&amp;amp; 0 &lt;= lpApplyWelfare-&amp;nSoapReturn) &#123; if (m_pDataStats) &#123; m_pDataStats-&gt;m_datastats_onapplywelfare(lpApplyWelfare-&amp;nRoomID, lpApplyWelfare-&amp;nUserID); ---------&amp; 这行出现问题 &#125; &#125; return bResult;&#125; 并查看异常期间的参数信息： 刚开始主程序分析就以为是m_pDataStats = NULL 导致崩溃，原因可能是多线程导致，接着就开始review代码。 但是reivew之后发现m_pDataStats是不能为NULL的（除非进程关闭），然后又是一阵思考、联想、分析…….. 无果。接着猜测是否是踩内存导致（这个review代码难度就有点大了)……… 但实际这个dump发生异常的原因不是因为m_pDataStats = NULL导致，而是某个指针的值=0x0000ffff导致，这个在dump中有明确说明：12xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x37:00b9d4e7 ff30 push dword ptr [eax] ds:002b:0000ffff=???????? ds:002b::0000ffff 在访问0000ffff地址时发生异常！！！！！！ 但为何看this指针中的m_pDataStats 明明是 NULL啊？ 这就是代码开启优化的原因导致this指针不正确。 如何找到正确的this指针地址呢？通过汇编代码，看优化后的入参方式.使用命令“alt+7”可以打开汇编代码：函数原型：1BOOL CCommonBaseServer::DealApplyBaseWelfareEx(LPSOAP_SERVICE pSoapService, IXYSoapClientPtr&amp;amp; pSoapClient, LPCONTEXT_HEAD lpContext, LPREQUEST lpRequest) 首先我们先查看下this 指针存放在哪里12340:043&gt; dv /V this@ecx @ecx this = 0x04921dc4表明是放置在 ecx寄存器中 然后查看汇编代码：1234567891011121314151617181920212223242526 xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare:00b9d4b0 55 push ebp00b9d4b1 8bec mov ebp, esp00b9d4b3 53 push ebx00b9d4b4 56 push esi00b9d4b5 8b7514 mov esi, dword ptr [ebp+14h]00b9d4b8 8bd9 mov ebx, ecx --- 临时保存00b9d4ba 57 push edi00b9d4bb 56 push esi00b9d4bc ff7510 push dword ptr [ebp+10h]00b9d4bf ff750c push dword ptr [ebp+0Ch]00b9d4c2 ff7508 push dword ptr [ebp+8]00b9d4c5 e806b10300 call xzmoSvr!CMainServer::DealApplyBaseWelfare (00bd85d0)00b9d4ca 8bf8 mov edi, eax00b9d4cc 8b461c mov eax, dword ptr [esi+1Ch]00b9d4cf 85ff test edi, edi00b9d4d1 741e je xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x41 (00b9d4f1)00b9d4d3 85c0 test eax, eax00b9d4d5 741a je xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x41 (00b9d4f1)00b9d4d7 83784000 cmp dword ptr [eax+40h], 000b9d4db 7c14 jl xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x41 (00b9d4f1)00b9d4dd 8b8bf8af0000 mov ecx, dword ptr [ebx+0AFF8h] --- 被重新赋值00b9d4e3 85c9 test ecx, ecx00b9d4e5 740a je xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x41 (00b9d4f1) -- 崩溃的地方00b9d4e7 ff30 push dword ptr [eax]00b9d4e9 ff7004 push dword ptr [eax+4] 可以看到ecx的地址被临时保存到ebx中，在后续出现异常之前，ecx又被赋值成了其他值，通过之前异常的寄存器信息可以看到ebx的值1234560:043&amp; .ecxreax=0000ffff ebx=00435a18 ecx=04921dc4 edx=060de888 esi=0d7ed468 edi=00000001eip=00b9d4e7 esp=070efde8 ebp=070efdf4 iopl=0 nv up ei pl nz na po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010202xzmoSvr!CCommonBaseServer::DealApplyBaseWelfare+0x37:00b9d4e7 ff30 push dword ptr [eax] ds:002b:0000ffff=???????? ebx=00435a18， 使用’watch’查看this指针内容： 可以确定m_pDataStats 不仅指针有效，而且里面的内容也是正确的。所以异常并不是m_pDataStats异常导致。 那么问题就是lpApplyWelfare 这个指针导致。 这时候查看入参lpRequest 内容 pDataPtr=0x0000ffff和dump提示的异常指针内容相符，所以可以确定是这个指针导致的。 所以重新对lpRequest进行代码review，发现问题的本质原因：__super::DealApplyBaseWelfare(pSoapService, pSoapClient, lpContext, lpRequest);在执行过程中，会将lpRequest 指针post到B线程中执行，而B线程是会释放lpRequest指针的。 所以在低概率情况下，会出现多线程崩溃问题。 修改方式：先copy内存到局部变量，再执行super逻辑。 结论因为开启了代码优化，导致一开始在分析dump时走向了错误的道路，浪费了时间。在碰到开启代码优化时，查找正确的指针就变的有点困难。 所以不是很建议新上线的服务开启代码优化，反而增加了问题定位的难度。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ini 解析器]]></title>
    <url>%2F2019%2F06%2F13%2Fini-%E8%A7%A3%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[介绍windows 的ini读取使用 GetPrivateProfileInt等函数，需要切换到跨平台接口 比较对象 windows函数 iniDoc类 simpleini boost 属性树 测试数据 10w 次读操作 ini 大小10k 库 读性能 (ms) boost 属性树 85658 windows 自带 8600 iniDoc 28094 simpleini 34641 10w次读操作 ini大小1k 库 读性能 (ms) boost 属性树 – windows 自带 7672 iniDoc 5718 simpleini – 结论性能瓶颈应该在模式设计上，除windows以外的库，都是先把ini文件读入内存，然后解析所有的key、value；而windows应该是先查找到文件位置然后只获取附近的key、value即可。 暂时采用iniDoc，并在代码中尽量规避频繁读写ini文件。只要配置文件不要过大，完全可以用inidoc替换]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[消息队列 性能比较]]></title>
    <url>%2F2019%2F06%2F13%2F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[介绍windows下使用的是postthreadmessage、getmessage,考虑要跨平台，所以打算自己实现消息队列 无锁队列原理CAS操作——Compare &amp; Set，或是 Compare &amp; Swap，现在几乎所有的CPU指令都支持CAS的原子操作。 CAS的原子指令：12345678bool compare_and_swap (int *accum, int *dest, int newval)&#123; if ( *accum == *dest ) &#123; *dest = newval; return true; &#125; return false;&#125; GCC的CAS： 123bool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)type __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...) windows 的CAS： 123InterlockedCompareExchange ( __inout LONG volatile *Target, __in LONG Exchange, __in LONG Comperand); C++11中的CAS 123456template&lt; class T &gt;bool atomic_compare_exchange_weak( std::atomic* obj, T* expected, T desired );template&lt; class T &gt;bool atomic_compare_exchange_weak( volatile std::atomic* obj, T* expected, T desired ); 无锁队列就是基于CAS来实现的。 备选方案std::list + std::mutexboost::lockfree::queueboost::lockfree::spsc_queue其他队列 https://zhuanlan.zhihu.com/p/55583561 未比较 测试性能方法 生产500w数据 消费500w数据 串行消费耗时 测试机器1windows i5-7500 @3.4GHz 测试代码写的有点乱123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;mutex&gt;#include &lt;list&gt;#include &lt;thread&gt;#include &lt;boost/lockfree/queue.hpp&gt;#include &lt;boost/lockfree/spsc_queue.hpp&gt;#include &lt;boost/date_time/posix_time/posix_time.hpp&gt;int g_count = 0;std::mutex g_oMutex;std::list&lt;int&gt; g_oList;boost::lockfree::queue&lt;int&gt; g_queue(512);boost::lockfree::spsc_queue&lt;int, boost::lockfree::capacity&lt;5000000&gt; &gt; spsc_queue;int g_max = 5000000;int GetMs()&#123; const boost::posix_time::ptime now = boost::posix_time::microsec_clock::local_time(); // Get the time offset in current day const boost::posix_time::time_duration td = now.time_of_day(); int hh = td.hours(); int mm = td.minutes(); int ss = td.seconds(); int ms = td.total_milliseconds(); return ms;&#125;void func_producer()&#123; for (int i = 0; i &lt; g_max; i++) &#123; //g_oMutex.lock(); //g_oList.push_back(i); //g_oMutex.unlock(); spsc_queue.push(i); &#125;&#125;void func_consume()&#123; for (int i = 0; i &lt; g_max; i++) &#123; /*g_oMutex.lock(); g_oList.pop_front(); g_oMutex.unlock(); g_count++;*/ int n; if (spsc_queue.pop(n)) &#123; g_count++; &#125; &#125;&#125;int main()&#123; int dwTime = GetMs(); std::thread t2(func_producer); t2.join(); std::thread t1(func_consume); t1.join(); int diff = GetMs() - dwTime; printf(&quot;lost time is %d ,count is %d \n&quot;, diff, g_count); //system(&quot;pause&quot;); return 0;&#125; 结论 队列 时间(ms) windows 未验证 list+mutex 766 lockfree::queue 1156 lockfree::spsc_queue 47 单生产单消费模式下lockfree::spsc_queue 的确最优秀，但是我们的服务采用的是多生产单消费模式，性能上也足够了，所以还是暂时先用list+mutex。 注：单生产单消费者套在多生产单消费里面，会导致数据丢失。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vs2019 创建linux项目]]></title>
    <url>%2F2019%2F06%2F13%2Fvs2019-%E5%88%9B%E5%BB%BAlinux%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[背景计划将公司的部分稳定服务切换到linux环境下 以前linux下的开发方式是 ssh + samb + source insight + makefile + g++。在windows下用 source insight看代码，然后ssh到centos 服务器上，然后执行编译。 现在看到vs2019也可以编译，所以尝试试试。 安装centos略 安装gcc略 安装gdbserveryum install gdb-gdbserver vs2019创建linux项目可参考 https://blog.csdn.net/zyzmzm_/article/details/89044885 注意点x64 x86 切换即使gcc支持了32位版本编译，vs2019 中将解决方案平台切换为x86，也会提示错误，尝试解决不了。 规避方法就是再创建一个基于x64解决方案平台命名为(xx86)，然后在c++、lib 的“其他选项”中增加gcc x86编译选项“-m32”，这样编出来的程序是32位的 无法远程调试在“属性”“调试”，修改“调试模式”为 gdbserver 无法远程调试即使设置了gdbserver调试，仍然无法调试， 请“关闭防火墙”。 gdb编译输出内容不够丰富]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[魔鬼经济学（3）]]></title>
    <url>%2F2019%2F05%2F31%2F%E9%AD%94%E9%AC%BC%E7%BB%8F%E6%B5%8E%E5%AD%A6%EF%BC%883%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读书时间2019/05/11 ~ 2019/06/18 像魔鬼一样思考承认自己不知道下次当你面对不懂的问题时，请直说“我不知道”。当然，可以加一句—-“但或许我可以找到答案。”然后尽你所能寻找答案。你会惊讶地发现人们是多么欢迎你的坦诚。 你的问题是什么吸取两个广义的经验： 关于解决问题的一般方式。 1小林尊重新定义了问题。他的对手问了什么问题呢？基本是：我怎样才能让吃更多的热狗？小林尊问了一个不同的问题：我怎么样才能让热狗更容易下咽？这个问题引导他进行实验，不断优化策略。在重新定义问题后，他才发现了一系列新的答案。 我们接受或拒绝接受的极限 1请仔细考虑忽视一些虚无的障碍，如果事先就给自己下判定无法做到，那就是难上加难。 真相在问题的根源面对人们已经研究过的问题并找出新的解决途径，需要思考者真正具有独创精神。为什么能做到这点的人少之又少？或许因为，我们多数人在寻找答案时都倾向于最接近、最显而易见的的原因。很难说这是后天形成的习惯，还是祖先遗留的基因所致。 像孩子一样思考1寻找乐趣、浅显思考、不惧惯俗---这些都是孩子们惯常的行为，而至少我们认为，成年人若能保留住这些特质，将会受益匪浅。 尽管如此，我们并不是建议你以8岁小孩为榜样重塑一切行为习惯。这样做产生的问题肯定比它能解决的多。然而如果我们能够把一部分童年的直觉带到成人世界里，那不是很好吗？那样，我们会说更多忠于自己的话，问更多我们在乎的问题，甚至能够甩掉一部分最危险的成人特质：虚伪。 想象你是一名魔术师，那么最难欺骗的反而是儿童。 爱吃糖的孩子12如果又魔鬼式思考者赖以生存的真言，那就是：人们会对诱因做出反应。了解一个情形中针对每个当事人奏效的诱因，是解决问题的根本。诱因并不总是那么容易找到，经济、社会、道德、法律等，它们作用于不同的方向，力度也不相同。但如果你像进行魔鬼式思考，那就必须学着成为诱因大师---好的、坏的以及丑陋的。 举例：12345在某国家森林公园里写上警示牌：‘每天，自然遗产都会遭到破坏，石化木以每年14吨的速度被偷盗......’最后的结果是，被偷盗的反而更多。公园警示牌意在传达道德信息，但或许表达出来的却是：哇，石化木快没了---那我得赶紧拿一份；或者：一年14吨？那我拿几块肯定不成问题。 1人类是复杂的动物，私下或公开场合的诱因有着微妙的差别，而且人们的行为在很大程度上受到具体环境影响。你一旦了解了诱因背后的心理因素，便可以利用自己的聪明才智建起有效的诱因机制。 如何说服不想被说服的人？或许你提出了令人不适的问题，挑战了传统，或者是碰到了不该触碰的话题。因此人们开始对你颇有微词。我们能提供给你的最佳建议其实很简单：微笑并转换话题。用开创式的思维思考并解决问题很困难，然而经验告诉我们：说服不想被说服的人，难上加难。 你先要明白说服一个人是多么困难，以及背后的原因。 与我无关，都是为了你 1每次当你试图说服他人时，请记住，你只是论点的制造者，对方的意见才重要。你的论点或许无可辩驳，逻辑无懈可击，但如果没有给对方带去共鸣则丝毫不具意义。 别以为自己的论点是完美的 1如果你掩饰了计划中的缺陷，那就是给了对方怀疑整个计划的理由。 要肯定对方论点中的合理之处 对立的观点几乎总是有价值的。你可以从中学到东西并强化自己的观点。 如果对方认为自己的观点被忽视，也不太可能用心与你交谈。 把那些辱骂留在自己心里吧 1辱骂别人只会带给你一个敌人，而非盟友。 为什么你该讲故事 12最有力的说服手段：讲故事。故事能描绘出全貌。 放弃的好处 为什么你没有放弃： 我们从小到大一直被那些想当丘吉尔的人们告诫：放弃是失败的标志。 沉没成本 人们往往把过多注意力放在了实际成本而不是机会成本 1理性的人需要学会懂得放弃。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++架构优化]]></title>
    <url>%2F2019%2F05%2F30%2F%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[背景介绍公司是一家小的游戏公司，日活百万左右，同时最高在线人数30w左右。公司的核心服务使用C++开发，生产环境是windows.游戏基础服务主要职责就是承载公司游戏的登陆、业务逻辑、通知、游戏数据结算、玩家信息统计等功能，而具体的游戏逻辑在各个游戏团队的游戏服务中负责。 游戏基础服务一旦出现问题，玩家就无法游戏，因为无法登陆、无法结算…. 所以是需要高可靠的服务。 我的主要职责就是维护基础服务的稳定运行。 以上是职责介绍，下面是刚入职时基础服务的架构。 早期的架构架构基本是按照业务单元进行分服务开发，但也不像微服务那么细微。 大致讲解： 整个架构是比较清晰的，而且按照功能进行划分，所有服务都支持横向扩展，db使用分库分表设计。所以在性能上、横向扩展都没有太大问题。 但实际在维护的过程中，还是会发现很多不合理的地方。 升级一个简单的功能，需要重启很多重要的服务。每次升级都很纠结 版本发布、代码编写很不方便 出现问题定位很费时间 问题随机、随时出现，没任何预兆………… 大量的非工作时间被白白浪费！！！！！！！！ 不合理的地方1自己的备忘录里面记录了服务大致需要整改的点有100多处 生产工具落后使用的还是VC6 编译器。无法使用c++1x的语法、写代码不方便、开源库不好支持等等 没有持续集成环境版本发布依赖领导的时间。（生产环境的版本必须由领导的机器编译），有次出现问题，问题定位5分钟，版本发布却花了3个小时。 服务无法灰度升级服务升级都要在凌晨6点升级，而且升级过程中整体服务无法使用 单个服务异常影响整体整个架构里面服务相互链接构成网状，当某个服务异常时，常常会关联其他服务出现异常 整体服务容错性不足单台block、check异常，就会导致这个节点上的所有玩家和游戏出现异常 没有健康监控功能出现问题都是玩家反馈，研发自己都不知道服务是否出现异常； 没有预警机制当性能、内存、io等不足时没有提早告知进行准备 定位方法落后采用原始的vistual stdio 调试，没有分析dump的能力 msmq 功能扩展、维护、定位麻烦服务的管理、配置落后整体架构缺陷这个涉及点比较多，后续慢慢展开。 整改原因就是想做！！ 优化点升级开发工具到vs2013服务性能监控服务消息堆积数量、进程cpu、磁盘容量、提交内存大小 数据到大数据平台。出现问题时，基本都是第一时间就能够在钉钉收到预警通知。 使用jenkins进行持续集成windbg分析的持续培训C++的优化原来都采用的MFC的CMap、CString、线程、锁等都需要替换为stl、boost类型 调整架构，支持灰度发布1目前还在持续优化中 设计的方法： 模块设计“幂等性” 服务尽量无状态这样游戏、玩家可以随机指定链接，然后引入负载均衡+域名管理，就可以方便地地给服务器导流，支持灰度升级 重试次数控制 + 熔断 redis缓存、MQ 异步 隔离设计 将影响玩家的业务和统计业务，中间搭建 actik中转服务隔离开来所有下游统计业务都需要经过actik服务进行清洗，然后才能到具体的业务服务中去 玩家隔离比如将pc、移动、微信玩家连接的服务进行隔离，减少影响面。 使用rabbitmq替换msmqrabbitmq支持AMQP协议，扩展、管理、维护都非常方便 数据库的优化分库、分表；购买新硬件、数据备份、导入导出使用mqsql 替换sql server 总结无意间看到一篇服务弹力设计的文章，总结的比我好，自己就是朝这个方向在调整！ 后续计划 引入稳定的gate服务 统一配置中心 linux化 服务go语言化 效果 基础服务稳定性提高非常明显，两年就没出现过重大事故。 升级也方便了很多，大部分都可以灰度升级。 线上出现问题也能快速定位，出现问题心不慌。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[精益产品开发]]></title>
    <url>%2F2019%2F05%2F28%2F%E7%B2%BE%E7%9B%8A%E4%BA%A7%E5%93%81%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[读书时间：2019年3月 人们认识到，遵循严格生命周期的概念，把开发分割为顺序阶段构成的过程，实施起来不现实，造成了以下直接的危害。 1、希望通过各个阶段设置关卡，严格控制，以期更早地发现问题，却滞后了集成和测试，让错误的发现延迟到最后，这是很多项目失败的根源。 2、希望一开始就能设定完整和正确的需求，这对软件产品越来越不可能，因为用户也不知道或说不清楚自己想要什么。事实上，对需求的挖掘和理解，应该是一个持续的过程，需要不断的反馈。 3、把成功定义为“遵循最初的计划和范围”。为了确保项目的“成功”而避免或拒绝进行合理的变更，却忽略了“达成商业目标才是真正的成功”。这已经成为业务成功的一个严重障碍。 4、传统产品开发方法强调控制，所以一旦流程出现问题，自然的应对就是进一步加强管控，流程本身有自我复杂化的趋势，反而会压制关键软件人员的主观能动性。 ——————————————- 《丰田之道2001》—————————————- 精益生产的两大支柱： 1、持续改进 1）、挑战现状：我们构建长远的愿景，以勇气和创造力来面对挑战和实现梦想 2）、改善：我们持续改进业务运营，不断追求创新和进化 3）、现地现物：我们践行现地现物，去源头发现事实，做出正确的决策，建立共识，最快速地达成目标。 2、尊重人 1）、我们相互尊重，竭尽全力理解对方，承担责任，建立互信。 2）、我们激励个体及其职业的提升，共享发展的机会，最大化个人和团队绩效。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[未来简史]]></title>
    <url>%2F2019%2F05%2F28%2F%E6%9C%AA%E6%9D%A5%E7%AE%80%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[读书时间：2019年3月 1、研究历史，就是为了挣脱过去的桎梏，让我们能看向不同的方向，并开始注意到前人无法想象或过去不希望我们想象到的可能性。观察我们走到现在的一连串意外事件，就能了解人类的每个念头和梦想是如何变成现实的，然后我们就能开始以不同的方式思考并编织出不同的梦想。研究历史并不能告诉我们应该如何选择，但至少能给我们提供更多的选项。回首过去，很多人都会认为法老时代的结束以及“上帝已死”的概念都是社会的进步，或许人文主义的崩塌也是好事。人们之所以不愿改变，是因为害怕。但历史唯一不变的事实，就是一切都会改变。 2、人文主义三大分支 1）、正统派（自由主义）：认为每个人都是独特的，拥有独一无二的内在声音、永不重复的一连串体验。每个人都像一道不同的光线，从不同的角度照亮世界，为这个宇宙增添色彩、深度和意义。因此，我们应该让每个人都尽量自由自在地体验世界、听从自己内心地声音、表达自己心中真实地想法。不管在政治、经济还是艺术中，个人的自由意志都应该比国家利益或宗教原则更为重要。个人能享有的自由越多，整个世界就会变得越美丽、丰富、有意义。自由主义政治认为，选民能做出最好得选择。自由主义艺术认为，观看作品得人觉得美，就是美。自由主义经济学者认为，顾客永远是对的。自由主义理论认为，只要感觉对了，就该去做。自由主义教育认为，我们要为自己思考，因为从内心就能找到所有答案。 2）、xx人文主义。xx认为主义走的道路则非常不同。xx主义责怪自由主义过于注重自己的感觉，而不顾他人的感受。xx主义并不鼓励自我探索，而是主张简历强有力的集体制度（比如政党和工会），为我们解读这个世界。xx主义政治认为政党能做出最好的选择。各种权威和意义仍然来自人类的体验，但个人必须听从政党和工会的决定，而不是自己的个人感觉。 3）、进化人文主义]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[魔鬼经济学（2）]]></title>
    <url>%2F2019%2F05%2F27%2F%E9%AD%94%E9%AC%BC%E7%BB%8F%E6%B5%8E%E5%AD%A6%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读书时间：2019/05/09 – 2019/05/27 魔鬼经济学==慌谬怪诞经济学？ 酒后步行比酒后驾车还要危险！ 电视把印度女性解救了出来？ 遏制气候变暖：火山喷发，用烟囱捅破天，还是架一根18英里长的管子？恐怖分子的银行账号有什么特点？ 想长寿吗？拿个诺贝尔奖吧也有一些方式是可以延长你的寿命的，但这与去医院看病毫无关系。比如你得个诺贝尔奖或者选入名人堂。但是，既没能在科学领域取得卓越的成绩，也没能成为一流的运动员，对于普通人最好就是去买份养老保险—确保你退休后每年可以领取固定数额的收入，直至你去世。养老保险提供娟娟细流般的稳定收入，使这些老人多了那么一点点动机—要努力活得更久一些。 如果你的病情很严重，去医院看病会略微提高你存活下来的概率；但如果病情并不严重，那么去看病就会提高你死亡的概率。生活中很多清形之反常、之不可理喻。 难以置信：犯罪率升高时因为电视看多了？行为经济学 疫苗、安全带和飓风：不一样的事情、一样的逻辑1看来毫无头绪的大难题，其解决方案竟如此称奇 接生时发生的产褥热 &lt;劳动法&gt;也会损害劳动者 硝酸铵养活了整个世界 没有什么医疗手段比疫苗更简单 安全带有多安全 儿童座椅的安全效应 从预防重伤的情形来看，标配安全带与2-6岁儿童用的安全座椅表现同样出色。但是从轻伤的情况看，儿童座椅的表现更好：受伤的概率大约下降了25%。儿童座椅还能带来另外一个好处，这可是无法用价格来衡量的—父母内心的安宁。 相比起儿童座椅，还有简单且便宜的方案，就是针对儿童体型设计的安全带。总所周知：政府不喜欢寻求更便宜、更简单的解决方案，相反，往往倾向于选择价格昂贵、麻烦棘手的对策。 街头妓女与百货商店圣诞老人有何相似之处可以了解到妓女的真实生活、收入情况；适合从业人员好好研究，学习！]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[醉汉的脚步]]></title>
    <url>%2F2019%2F05%2F10%2F%E9%86%89%E6%B1%89%E7%9A%84%E8%84%9A%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[读书时间2019/02/11 - 未完 摘要顶着人类的直觉破浪而行，是一件困难的事。如所要看到的那样，人类头脑至构造，是要给每一个事情找出确定理由，因为它难以接受无关或随机因素所造成的影响。因此，我们首要要认识到，成败有时并非来自于过人的能力或无能，而是来自于如经济学家艾智仁所说的“幸运的环境”。 随机过程就本性而言非常基本，再日常生活中也无所不在，但不多数人却不了解它，或者很少想到它。 一部伟大小说的创作—或说一件珠宝或一块洒上了巧克力碎块的曲奇饼，和这部小说印刷成书后在数以万计的零售店前高高堆起的书堆—或说成套的珠宝或成袋的曲奇饼，这两者间有着移到随机性和不确定性的鸿沟。之所以各领域的成功人士都几乎无例外地属于特定的一类人—-那些从不放弃的人，其原因就在于此。 许多发生在我们身上的事情—职场上、投资上以及在生活中或大或小决策方面的成功—–都是随机因素的结果，这些因素的影响一点儿也不比我们的能力、勤奋与为把握机会而做好准备的影响来得小。因此，我们所认识得现实，并不是人或环境得直接反映，而是被不可预见或不断变化的外部力量所随机化后的模糊映像。这并非说能力无关紧要—能力正是增加成功机会的因素之一—但行动与结果之间的联系，可能并非如我们所乐于相信地那么直接。因此，理解过去不容易，预测未来同样不容易。在这两种情况下，如果能超越肤浅地解释去观察问题，我们将受益匪浅。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从杭州到长白山滑野雪]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%BB%8E%E6%9D%AD%E5%B7%9E%E5%88%B0%E9%95%BF%E7%99%BD%E5%B1%B1%E6%BB%91%E9%87%8E%E9%9B%AA%2F</url>
    <content type="text"><![CDATA[心血来潮2017年初突然心血来潮想去北方滑野雪，比较了几个北方的滑雪场，再考虑到春节时机票太贵，所以决定四月去长白山天池滑雪，顺便还可以看看天池美景。长白山万达度假村的滑雪场是在3月底关闭，天池滑雪是在4月底关闭，所以4月份去滑天池雪性价比高，当时价格是500/人。具体信息可以关注微信公众号“长白山天池雪”。 交通杭州没有直达长白山的航班，只能选择上海浦东国际机场的春秋航空。事实证明最方便快捷，而且淡季出行机票价格大都在199. 周五中午从杭州出发，上沪昆高速、申嘉湖高速抵达茂莜停车场，然后bus接送到机场T2航站楼，办理登机手续。 17:50飞机起飞，20:45抵达长白山机场。 坐上万达度假村的直到bus 21：30 到达酒店。 由于刚下过雨，路上看到很多人在抓雪蛤，对我来说挺新奇的。 温度出发时还担心会太冷，淘宝了雪地靴、帽子其实都用不到；真正有用的是手套，在天池上冷风很大，不带手套手几乎瞬间就冻僵。4月的长白山温度大概在7-8度，比杭州多穿一件衣服就可以了。 之前准备的雪地靴、帽子、厚衣服完全用不到。 酒店乘坐万达度假村的bus到达万达喜来登酒店，偌大的酒店只有二三十个客人。酒店设施还是不错，只是淡季这里的交通不太方便， 礼宾给我们联系了出租车， 第二天包车出发去西坡滑雪。 滑雪第二天吃完早餐，前往长白山西坡，一路上白雪还在融化，万物都在等待着5、6月份的复苏。4月份其实风景真不怎么样，雪也没有、绿树也没有。 达到西坡门口，在滑雪窗口领了滑雪票，然后坐上景区环保车，同车的还有6个专业滑雪人士。 汽车一路盘旋从980M的海拔一直颠簸到了1700M的海拔，到达滑雪小屋。此时的风景已经和山下大不同了，一片片白茫茫的雪景，心中激动万分。这么久的等待和准备就是为了见到这样的雪景。山上并不冷，一件羊绒衫、一件冲锋衣已经足够了。换上滑雪装备，坐上雪地摩托，冲锋到了2200M的海拔给我们这两个初学者准备的雪场。之间有个插曲，滑雪最好自带好干粮（一定要有牛肉，体能消耗很大）、温水，山顶自行解决午饭问题。而我没带东西饿到不行，后来还是到了滑雪小屋吃了碗面重新上来，浪费了不少时间。雪地摩托过于刺激，期间有个大叔为了展示他的技术，我差点被他从车上甩下来。滑雪过程不多描述，体验非常不错。 休息时刻，我们去了2600M高的天池，山顶风好大，如果不带手套，一会儿就可以让你的手冻僵，所以照片拍的不多。4月的天池还都是冰，阳光很好、蓝天白云、白雪，站在天池边，凝视着这个经过几百万年岁月洗礼还如此安静的美景，感受那种空旷的美，绝对值得留恋 …… 4月份的季节长白上除了滑雪其实风景也没什么好看的，所以周日我们就在酒店休息，等待回家，本想再滑一天，无奈摔的太疼起不来了。 周日晚上20：00的飞机回到上海，然后取车开回杭州。 其实可以周五去，周六回，时间全完足够。 机场离酒店很近的…… 费用1、机票去410，回199, 加上50的机场建设费，30的保险费 总共 1500（两人）注意：春秋航空托运是要另外收费的哦。 2、酒店万达喜来登 710/晚（含双早） 总共：1420 3、交通费茂莜停车场：90杭州到浦东机场的汽油和过路费 总共：550 4、长白山交通费总共 300 5、滑雪两人 999，包含了景区门票和环保车费吃饭 100总共 1099 6、其他总共 500 两人总共 5500 左右。 景色这就是初学滑雪场，就我们两个人玩。 从下往上看，对于初学者还是比较陡的。 专业的滑道是从天池开始往下滑的，偷拍的一张。 在天池边拍的全景，中间那个冰池就是天池了。 下雨时当地居民抓的雪蛤。]]></content>
      <categories>
        <category>走走看看</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中老年人麻将消消游戏]]></title>
    <url>%2F2019%2F05%2F09%2F%E4%B8%AD%E8%80%81%E5%B9%B4%E4%BA%BA%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[自己用cocoscreate 做的一款中老年麻将消消游戏，发现爸爸、妈妈、老婆很喜欢，有版权证书！！ 游戏入口麻将消消PC版 玩法说明通过查找最上层相同的麻将点击消除，其中左上角有三张交换牌。]]></content>
      <categories>
        <category>小游戏</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[魔鬼经济学（1）]]></title>
    <url>%2F2019%2F05%2F09%2F%E9%AD%94%E9%AC%BC%E7%BB%8F%E6%B5%8E%E5%AD%A6%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读书时间2019/04/24 – 2019/05/09 摘要《教师与相扑力士有何共同点》 探讨动机的优点及阴暗面—-作弊 《为何三K党和房地产中介是一路货色》论证了信息的力量无可比拟，这种力量一旦遭到滥用，则更显露无疑 《为何毒贩还在与母亲同住》发现传统观念往往是由捏造信息、自身利益和方便之词共同构成的。其实大多毒贩并不是很有钱 《罪犯都去那儿了》分析了有关犯罪的说法哪些是真，哪些是假 《怎样才算完美的父母》从多个角度提出了一个迫切的问题：父母真的重要吗？ “童年早期的纵向研究”中与学校考试成绩相关的8个因素： 父母学历高父母在生育第一胎时的年龄为30或30岁以上出生体重低父母在家讲英语父母参加家长教师联谊会家中藏书多 以及8个无关的因素： 家庭完整父母最近搬入了条件较好的小区母亲在孩子出生后至上幼儿园之前不工作参加过启智计划定期随父母去博物馆经常被打经常看电视几乎每天都听父母读书 笼统来讲，前8个因素是对父母特点的描述，后8个因素是对父母行为的描述。高学历、事业有成、身体健康的父母所生育的子女往往能在学校取得优异成绩；但儿童是否去博物馆、是否被打、是否参加启智计划、是否经常听父母读书，或是否坐在电视机前不离身视乎并无影响。 对于喜欢钻研养儿育女之道的父母——和育儿专家—-来说，这或许是值得深思的发现。事实上，这些育儿知道视乎被严重高估了。 但这并不是说父母毫无影响，显然，父母对育儿而言关系重大。难点在于，当多数人准备拾起育儿经的时候，为时已晚，因为真正重要的因素—-身份、配偶、生活方式—–早已注定。如果你天资聪慧、踏实肯干、教育水平高、收入颇丰且配偶也条件相当，那你的孩子就有更大的概率能在生活中有所成就（正直诚实、体贴周到、富有爱心、对世界充满好奇心想必也不会有害处）。 而至于你的所作所为则并无太大影响，重要的是你本身的特质。 《完美的父母序章》分析了正式为人父母后的第一件事—给孩子起名—-究竟有多重要。 总结作者通过数据分析，理性并有理有据的证明一些有趣的观点，虽然事实并非真的如此，但也是从一个客观地角度考虑事实。对我印象比较深的，就是《怎样才算完美的父母》：儿童早期的学习成绩大概率在父母结婚时就决定了，50%是基因，剩下最重要的就是父母本身的特质，而后天的行为（比如上培训班）影响并不大。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ EH exception]]></title>
    <url>%2F2019%2F05%2F08%2FC-EH-exception%2F</url>
    <content type="text"><![CDATA[介绍某个代理服务器在压力测试时发生异常，以下是定位过程 保存dump因为提早有知道程序会出现异常，所以中间省去了很多步骤，在服务启动时就已经使用windbg attach到了服务进程上，这样一旦程序触发异常windbg立即就会捕获。dump下载：链接：https://pan.baidu.com/s/1Ntm3MRQnbMqGtLkAushSvg 提取码：nvu1 分析过程程序异常在程序运行了15小时之后，程序触发了异常，windbg 上使用 命令 !analyze -v 分析异常原因123456789101112131415161718192021222324252627282930313233343536Failed calling InternetOpenUrl, GLE=12002FAULTING_IP: KERNELBASE!RaiseException+5876dcc42d c9 leaveEXCEPTION_RECORD: ffffffff -- (.exr 0xffffffffffffffff)ExceptionAddress: 76dcc42d (KERNELBASE!RaiseException+0x00000058) ExceptionCode: e06d7363 (C++ EH exception) ExceptionFlags: 00000001NumberParameters: 3 Parameter[0]: 19930520 Parameter[1]: 026ffa68 Parameter[2]: 746dc7fcDEFAULT_BUCKET_ID: APPLICATION_FAULTSTACK_TEXT: 026ffa18 746c9339 e06d7363 00000001 00000003 KERNELBASE!RaiseException+0x58026ffa58 7470da6a 026ffa68 746dc7fc 746dd1cc msvcr120!_CxxThrowException+0x5b [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]026ffa78 009ba351 00004400 03d95cc8 03d95d20 msvcr120!operator new+0x50 [f:\dd\vctools\crt\crtw32\heap\new.cpp @ 62]026ffa8c 009c9c01 00004400 03d95cc8 009c9824 roommpsvr!std::vector&lt;unsigned char,std::allocator&lt;unsigned char&gt; &gt;::_Buy+0x41026ffad4 009c9b9f 0324d520 00621598 2cf7d616 roommpsvr!std::vector&lt;unsigned char,std::allocator&lt;unsigned char&gt; &gt;::vector&lt;unsigned char,std::allocator&lt;unsigned char&gt; &gt;+0x21026ffb08 009c2858 08cb66d8 2cf7d606 045aad60 roommpsvr!mp::MPSocket::create_ssl+0x5f026ffb9c 009c5987 026ffbf8 0000020f 026ffc18 roommpsvr!mp::WSSConnection::handle_judge_protocol+0x248026ffbac 009c5341 026ffbe8 026ffbe8 2cf7d6de roommpsvr!boost::asio::asio_handler_invoke&lt;boost::asio::detail::binder2&lt;boost::_bi::bind_t&lt;void,boost::_mfi::mf2&lt;void,mp::WSConnection,boost::system::error_code const &amp;,unsigned int&gt;,boost::_bi::list3&lt;boost::_bi::value&lt;boost::shared_ptr&lt;mp::WSSConnection&gt; &gt;,boost::arg&lt;1&gt;,boost::arg&lt;2&gt; &gt; &gt;,boost::system::error_code,unsigned int&gt; &gt;+0x17026ffc18 009b603d 00643940 045aad60 026ffc4c roommpsvr!boost::asio::detail::win_iocp_socket_recv_op&lt;boost::asio::mutable_buffers_1,boost::_bi::bind_t&lt;void,boost::_mfi::mf2&lt;void,mp::WSConnection,boost::system::error_code const &amp;,unsigned int&gt;,boost::_bi::list3&lt;boost::_bi::value&lt;boost::shared_ptr&lt;mp::WSSConnection&gt; &gt;,boost::arg&lt;1&gt;,boost::arg&lt;2&gt; &gt; &gt; &gt;::do_complete+0x101026ffc78 009b5ba7 2cf7d166 026ffcc8 2cf7d1aa roommpsvr!boost::asio::detail::win_iocp_io_service::do_one+0x17d026ffcb4 009b63fa 026ffcc8 00647e70 00647e70 roommpsvr!boost::asio::detail::win_iocp_io_service::run+0xc7026ffcd0 00b182de 2cf7d1e6 00000000 00651090 roommpsvr!boost::asio::io_service::run+0x2a026ffcf8 746dc01d 00647e70 ff4a9697 00000000 roommpsvr!boost::`anonymous namespace&apos;::thread_start_function+0x5e026ffd30 746dc001 00000000 026ffd48 769f337a msvcr120!_callthreadstartex+0x1b [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]026ffd3c 769f337a 00650900 026ffd88 77389882 msvcr120!_threadstartex+0x7c [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]026ffd48 77389882 00650900 a6a6cb5f 00000000 kernel32!BaseThreadInitThunk+0xe026ffd88 77389855 746dbfb4 00650900 ffffffff ntdll!__RtlUserThreadStart+0x70026ffda0 00000000 746dbfb4 00650900 00000000 ntdll!_RtlUserThreadStart+0x1b 查看堆栈从堆栈信息中可以看到，在mp::MPSocket::create_ssl 中new了对象，然后new.cpp@62 抛出了一个异常1234567891011void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc) &#123; // try to allocate size bytes void *p; while ((p = malloc(size)) == 0) if (_callnewh(size) == 0) &#123; // report no memory _THROW_NCEE(_XSTD bad_alloc, ); ----------&gt;&gt;&gt; @62 &#125; return (p); &#125; 查看内存信息使用工具processxp 查看对应服务的内存状态，虚拟内存、提交内存 都是很低的，不太可能会出现内存申请失败。 进一步确认原因12345678EXCEPTION_RECORD: ffffffff -- (.exr 0xffffffffffffffff)ExceptionAddress: 76dcc42d (KERNELBASE!RaiseException+0x00000058) ExceptionCode: e06d7363 (C++ EH exception) ExceptionFlags: 00000001NumberParameters: 3 Parameter[0]: 19930520 Parameter[1]: 026ffa68 Parameter[2]: 746dc7fc google 搜索 “e06d7363 (C++ EH exception)”， 查看链接：https://blogs.msdn.microsoft.com/oldnewthing/20100730-00/?p=13273按照它的步骤进一步确认C++ 异常原因：123456780:008&gt; dd 746dc7fc l4 ---&gt; 是小写的“L&quot;746dc7fc 00000000 746e3cc0 00000000 746dc80c0:008&gt; dd 746dc80c l2746dc80c 00000002 746dd1ac0:008&gt; dd 746dd1ac l2746dd1ac 00000010 74790d380:008&gt; da 74790d38 + 874790d40 &quot;.?AVbad_alloc@std@@&quot; 发现的确是 “bad_alloc@std” 导致的异常。 仔细观察物理机器的状态，发现其中一个redis服务吃了大概2G多的内存，会不会是这个原因导致服务进程在申请pagefile时失败呢？ 杀掉异常进程继续观察。 总结长时间观察程序正常。本文的目的主要是介绍如何解码c++异常的具体原因。 附其他操作1026ffa58 7470da6a 026ffa68 746dc7fc 746dd1cc msvcr120!_CxxThrowException+0x5b (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152] 123__CxxThrowException( void* pExceptionObject, // The object thrown _ThrowInfo* pThrowInfo // Everything we need to know about it 746dc7fc 其实就是_ThrowInfo 结构体的指针信息，通过watch查看1234567typedef const struct _s__ThrowInfo&#123;unsigned int attributes;_PMFN pmfnUnwind;int (__cdecl*pForwardCompat)(...);_CatchableTypeArray *pCatachableTypeArray;&#125; _ThrowInfo; 结构体中重要的成员是_CatchableTypeArray。它包含了程序运行时抛出对象的类新信息(RTTI).如果你的程序运行时抛出一个my_exception类型的对象，那么抛出的数据参数pCatchableTypeArray包含了两个重要子数据信息。一个是typeid(my_exception)，另外一个是typeid(std::exception)。 所以通过watch查看：12345(ThrowInfo*)0x746dc7fc 0x746dc7fc struct _s_ThrowInfo *-attributes 0-pmfnUnwind 0x746e3cc0-pForwardCompat 0x00000000-pCatchableTypeArray 0x746dc80c struct _s_CatchableTypeArray * 123dd 0x746dc80c 746dc80c 00000002 746dd1ac 746e3b04 eb0cc483746dc81c be575612 7478fcb0 790d68bf 047e8374 12345678910watch 中查看(_s_CatchableType*)0x746dd1ac(_s_CatchableType*)0x746dd1ac 0x746dd1ac struct _s_CatchableType *-properties 0x10-pType 0x74790d38 struct TypeDescriptor *--hash 0x746bec94-spare 0x00000000--name char [] &quot;.?AVbad_alloc@std@@&quot;-thisDisplacement struct PMD-sizeOrOffset 0n12-copyFunction 0x746dd190]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windows下c++反射功能]]></title>
    <url>%2F2019%2F05%2F08%2Fwindows%E4%B8%8Bc-%E5%8F%8D%E5%B0%84%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[背景c++开发的软件在生产环境中运行出现一些bug，比如参数错误等问题，通过日志只能打印异常的行号或函数，但具体的结构体/类的参数内容打印却非常麻烦，无法做到一些更高级语言的反射功能。要做到能够通过变量地址就打印变量的内容信息，就需要依赖ms提供的msdia120.dll和程序编译后的pdb文件。 原理msdia120.dll 需要注册到目标机器，通过提供的接口函数可以解析pdb文件中的结构体、类，并提供这个成员变量的类型、相对的地址偏移。 效果demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;typeinfo&gt;#include &quot;tcDump.h&quot;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;list&gt;struct STTEST&#123; int a; double b; float c; short d; char szName[32]; void *p;&#125;;class CClassTest&#123;public: std::string m_strName; std::vector&lt;int&gt; m_oVec; std::map&lt;int, std::string&gt; m_oMap; //std::list&lt;int&gt; m_oList; // 不支持，慢慢完善&#125;;int _tmain(int argc, _TCHAR* argv[])&#123; if (0 == TCDUMP_INIT(&quot;ConsoleApplication1.pdb&quot;))&#123; return false; &#125; //结构体 &#123; STTEST st = &#123; 0 &#125;; st.a = 1; st.b = 1.2; st.c = 2.3; st.d = 655; memcpy(st.szName, &quot;hello world&quot;, 12); st.p = (void*)0x123456; auto json = TCDUMP(st); if (NULL == json)&#123; return false; &#125; printf(&quot;%s\n&quot;, json); &#125; //类对象 &#123; CClassTest oTest; oTest.m_strName = &quot;this is a test for string&quot;; oTest.m_oVec.push_back(6); oTest.m_oVec.push_back(7); oTest.m_oVec.push_back(8); oTest.m_oMap[0] = &quot;this is 0&quot;; oTest.m_oMap[1] = &quot;this is 1&quot;; oTest.m_oMap[2] = &quot;this is 2&quot;; auto json = TCDUMP(oTest); if (NULL == json)&#123; return false; &#125; printf(&quot;%s\n&quot;, json); &#125; return 0;&#125; 输出效果123456789101112131415161718&#123; &quot;a&quot; : 1, &quot;b&quot; : 1.2, &quot;c&quot; : 2.2999999523162842, &quot;d&quot; : 655, &quot;p&quot; : &quot;[0x00123456]&quot;, &quot;szName&quot; : &quot;hello world&quot;&#125;&#123; &quot;m_oMap&quot; : &#123; &quot;0&quot; : &quot;this is 0&quot;, &quot;1&quot; : &quot;this is 1&quot;, &quot;2&quot; : &quot;this is 2&quot; &#125;, &quot;m_oVec&quot; : [ 6, 7, 8 ], &quot;m_strName&quot; : &quot;this is a test for string&quot;&#125; 后续在每个关键函数的入口增加一个宏定义，就可以轻松的定位参数错误的问题，而省去了大量的远程调试时间。 二次开发visual studio 的安装路径下存在一个demo程序：DIA SDK 。可以通过修改其中的代码实现，当然我的百度网盘有封装后的sdk更加容易使用。 https://pan.baidu.com/s/1takuuHhxGt_WkLQWGDeacQ msdia120.dll tcDump.dll tcDump.h tcDump.lib tcDumpD.lib tcDumpD.dll 使用说明.txt]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[搭建pdb服务器]]></title>
    <url>%2F2019%2F05%2F08%2F%E6%90%AD%E5%BB%BApdb%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[背景目前使用jenkins进行每日编译、部署，但是一旦程序出现异常后，查找正确的pdb文件也是件麻烦的事情，所以希望能有微软符号服务器一样的功能。 步骤通过google 查找一些资料，自己尝试了下，还是比较简单的. 安装windbg环境变量path 中设置windbg路径。 准备一块大硬盘会保存很多历史版本的pdb，所以有必要准备一块大硬盘 测试管理员方式运行cmd 1234567symstore add /r /f d:\public_game\*.pdb /s e:\symstore /t "gamechannel"其中 'd:\public_game\*.pdb' 为编译后的pdb路径'e:\symstore' pdb服务器路径"gamechannel" 产品名称更多参数说明 symstore -help 搭建http服务我们需要提供对外访问符号文件的途径，最简便的方式就是使用IIS创建一个HTTP服务并对外开放。使用搭SII建HTTP服务器的教程网上很多，这里简述以下: 打开IIS，选择网站-&gt;右键“添加网站” 输入网站名称，如Symbols，选择刚创建的符号文件存储目录为物理路径，端口为6776 ,其他保持默认，点击确定。 在网站主页中打开MIME类型，右侧添加，文件扩展名输入PDB,MIME类型输入application/octet-stream。这一步是为了允许从该站点访问读取PDB类型的文件。 设置权限。我们创建的网站默认情况下是不允许匿名用户访问的，为了允许调试器下载符号，我们需要添加一定的权限。点击右键我们的网站-&gt;编辑权限-&gt;选择安全选项卡-&gt;添加IIS_IUSRS用户或everyone用户并赋予Read &amp; execute，List folder contents和Read三项权限。 左侧右键刚创建的网站-&gt;管理网站-&gt;重新启动。 jenkins 设置在jenkins 原本保存exe、pdb 的命令下 增加 以上命令即可 windbg 设置12SRV*e:\mylocalsymbols*http://msdl.microsoft.com/download/symbolsSRV*e:\companysymbols*http://192.168.1.7:1234/ 好了，pdb 就可以自动获取了]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[踩内存（内存溢出）的异常定位]]></title>
    <url>%2F2019%2F05%2F07%2F%E8%B8%A9%E5%86%85%E5%AD%98%EF%BC%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%89%E7%9A%84%E5%BC%82%E5%B8%B8%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[介绍某天晚上11点，钉钉预警提示某服务catch到一个异常导致服务重启，因为是上线了一个多月的服务，半夜遇到这样的问题，整个人有点懵，立刻打开电脑下载dump文件进行分析，不幸的是在分析的过程中，又连续的出现了几次崩溃，在这么反复崩溃、重启折腾了1小时左右，服务终于正常了。 分析dump下载路径：链接：https://pan.baidu.com/s/1GPzzipmxWyIr5WKNq11pIQ 提取码：6dsn 分析[11-13 20-53-03]full.dmp 使用windbg打开dmp，并加载符号文件 使用命令 .ecxr 切换到异常上下文 1234567891011121314151617181920212223242526272829303132330:061&gt; .ecxreax=00000000 ebx=dfa477a6 ecx=0000020c edx=00000000 esi=10171adc edi=dfa40000eip=77bee41b esp=08c8f51c ebp=08c8f550 iopl=0 nv up ei pl nz na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010206ntdll!RtlInitUnicodeString+0x1f3:77bee41b 8930 mov dword ptr [eax],esi ds:002b:00000000=????????0:061&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.08c8f550 77bee023 00936e28 00936e28 08c8f5b4 ntdll!RtlInitUnicodeString+0x1f3*** ERROR: Symbol file could not be found. Defaulted to export symbols for kernel32.dll - 08c8f568 774414ad 008e0000 00000000 1065fd28 ntdll!RtlFreeHeap+0x7e*** ERROR: Symbol file could not be found. Defaulted to export symbols for msvcr120.dll - 08c8f57c 70fdecfa 008e0000 00000000 1065fd28 kernel32!HeapFree+0x14*** WARNING: Unable to verify checksum for topsvr.exe08c8f590 00315e35 1065fd28 0f611df0 002cef01 msvcr120!free+0x1a08c8f5a8 00315f4a 00936e28 00000000 00000000 topsvr!redisBufferWrite+0xb508c8f5bc 003160b7 00936e28 08c8f5d0 1033f5e8 topsvr!redisGetReply+0x4a08c8f5d4 0034ae42 00936e28 0f813270 69b2eb38 topsvr!redisCommand+0x3708c8f6dc 0034ee4f 08c8f764 08c8f818 69b2ea74 topsvr!CRedisBase::RedisCommand+0x92 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\redisbase.cpp @ 217]08c8f790 0034d24a 08c8f9fc 08c8f818 69b2e5d4 topsvr!CRedisMaster::GetYQWRoomInfo+0x5f (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\redismaster.cpp @ 623]08c8f830 00378957 08c8f9fc 08c8f924 69b2e414 topsvr!CRedisMaster::GetYQWRoomInfo+0x4a (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\redismaster.cpp @ 636]08c8f9f0 0036bab4 08c8fafc 00048e0f 69b2e604 topsvr!ToPSvrThriftHandler::GetYQWRoomByNo+0xc7 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\thirdpart\thrift-0.10.0\gen-cpp\topsvrthrift_server.skeleton.cpp @ 86]08c8fbe0 0036b31f 00000000 100e3170 100e30e0 topsvr!Tcy::ToPSvr::Thrift::ToPSvrThriftProcessor::process_GetYQWRoomByNo+0x1e4 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\thirdpart\thrift-0.10.0\gen-cpp\topsvrthrift.cpp @ 1823]08c8fcec 00375429 100e3170 100e30e0 08c8fd64 topsvr!Tcy::ToPSvr::Thrift::ToPSvrThriftProcessor::dispatchCall+0x28f (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\thirdpart\thrift-0.10.0\gen-cpp\topsvrthrift.cpp @ 1742]08c8fd90 002dcf11 100e3170 0f611e08 100e30e0 topsvr!apache::thrift::TDispatchProcessor::process+0xd9 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\svn143\library\thrift-0.10.0\lib\cpp\src\thrift\tdispatchprocessor.h @ 121]08c8fe44 002cab31 0093f988 002cadde 69b2e34c topsvr!apache::thrift::server::TConnectedClient::run+0x12108c8fea8 002cf00c 69b2e334 0093fed0 0093efa8 topsvr!apache::thrift::concurrency::ThreadManager::Task::run+0x1108c8fed0 002cfcd1 0093efa8 0093fed0 69b2e2e8 topsvr!apache::thrift::concurrency::StdThread::threadMain+0x5c*** ERROR: Symbol file could not be found. Defaulted to export symbols for msvcp120.dll - 08c8ff0c 7196f33c 432a8f49 00000000 009817d8 topsvr!std::_LaunchPad&lt;std::_Bind&lt;1,void,void (__cdecl*const)(boost::shared_ptr&lt;apache::thrift::concurrency::StdThread&gt;),boost::shared_ptr&lt;apache::thrift::concurrency::StdThread&gt; &gt; &gt;::_Run+0x7108c8ff34 70ffc01d 0377f764 432a8da9 00000000 msvcp120!std::_Pad::_Release+0x6c 异常来自CRedisBase::RedisCommand,最终是kernel32!HeapFree 导致异常 使用 !analyze -v 查看错误原因 123456789101112131415SYMBOL_NAME: heap_corruption!heap_corruptionFOLLOWUP_NAME: MachineOwnerMODULE_NAME: heap_corruptionIMAGE_NAME: heap_corruptionDEBUG_FLR_IMAGE_TIMESTAMP: 0STACK_COMMAND: ~61s; .ecxr ; kbFAILURE_BUCKET_ID: HEAP_CORRUPTION_c0000005_heap_corruption!heap_corruptionBUCKET_ID: APPLICATION_FAULT_HEAP_CORRUPTION_INVALID_POINTER_WRITE_NULL_POINTER_WRITE_heap_corruption!heap_corruption 基本可以确定是 heap被破坏导致的。 heap异常对于heap异常，在溢出或被踩时不一定会在第一时间出现问题。那么如何才能让heap被破坏时就产生异常呢？ 就是通过之前介绍的 “windows的应用验证机制” 使用appverif.exe页堆有两种运行模式： 普通页堆 完全页堆 普通页堆通过填充模式（增加元数据）检测堆块异常。完全页堆则多增加了一个防护页。 普通页堆因为没有将元数据和内存分离开，那么当元数据被破坏时，异常也是无法第一时间捕获。 完全页堆的缺点是需要大量的内存，会使原来的程序内存使用量提高一个数量级。 一般建议方案是在测试环境使用普通页堆方式，然后定期的检查中使用完全页堆。只有在条件允许的生产环境下采用完全页堆方式；也可以通过检测dll或基于内存分配大小来缩小内存检测范围。 full: 普通页堆 or 完全页堆 dlls: 可以指定堆测试中包含哪些dll。dll名字包括扩展名，如果有多个dll，那么用空格来分隔dll size：可以指定测试大小指定范围内的内存 backward： 完全页堆默认防止下溢的异常； 那么这个开关增加上溢的异常检测…… 分析[11-13 21-10-08]full 开启heap检测.dmp在第二天晚上蹲点，出现异常时立刻给服务开启heap检测，服务运行几分钟后又出现崩溃。 使用windbg打开该dmp .ecxr 切换到异常上下文 1234567891011121314151617180:119&gt; .ecxr eax=22ac1000 ebx=08de9ce8 ecx=22ac1000 edx=22ac0fff esi=1c8c0fe0 edi=08de9ce0eip=00bb6e31 esp=17d7f258 ebp=17d7f2ac iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010246*** WARNING: Unable to verify checksum for topsvr.exetopsvr!Base64encode+0x1c1:00bb6e31 c60000 mov byte ptr [eax],0 ds:002b:22ac1000=??0:119&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 17d7f2ac 00bbc06e 22ac0fa8 22d3ee58 00000042 topsvr!Base64encode+0x1c1 (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\base64.cpp @ 207]17d7f50c 00bb83d1 22d3e198 22d3ed80 17d7f620 topsvr!CBillDB::MakeParam_PushPlayerInfo+0x19e (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\billdb.cpp @ 625]17d7f668 00bb8842 22d3e198 22d3e390 00000000 topsvr!CBillDB::PushBill2DB+0x351 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\billdb.cpp @ 102]17d7f718 00bec143 22d3e198 22d3e390 11588718 topsvr!CBillDB::PushBill+0xe2 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\billdb.cpp @ 154]17d7f884 00be7695 21df6fe8 22528fe0 1732cfb8 topsvr!CSockServer::OnYQWResultEx+0x4a3 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\socksvr.cpp @ 1733]17d7f91c 00c1ac94 21df6fe8 22528fe0 08de9ce8 topsvr!CSockServer::OnRequest+0x3b5 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\topsvr\socksvr.cpp @ 293]17d7f944 00c1efeb 00000000 17324c40 17070c40 topsvr!CIocpWorker::DoWorkLoop+0xa417d7f95c 00c1efbb 17d7f99c 70ffc01d 08de9ce0 topsvr!CBaseWorker::WorkerThreadProc+0x2b 可以很容易看到是Base64encode导致异常 通过windbg的watch 查看入参参数，定位到原因： nikename数组只分配了128字节，但是某个玩家是156字节，导致转换溢出。 长度修改为256，服务发布后，就不再出现问题。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windbg分析内存泄漏]]></title>
    <url>%2F2019%2F05%2F07%2Fwindbg%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍本文主要介绍一种通过windbg分析内存泄漏的方法。 现象后台检测程序在某天上报了告警，大概就是某程序的提交内存达到了1.0G。登陆后台查看，该进程已经运行了90天，提交内存每天都在持续上涨，从启动到目前为止大概累计上升了800M。应该是存在内存泄漏。让运维通过工具保存了fulldump 准备工作 下载地址（提取码：11bg） 设置好系统的pdb1e:\mylocalsymbols;SRV*e:\mylocalsymbols*http://msdl.microsoft.com/download/symbols 查找堆块打印所有堆块信息1!heap -s 显示如下12345678910111213141516171819202122230:000&gt; !heap -sHEAPEXT: Unable to read ntdll!RtlpDisableHeapLookaside Heap Flags Reserv Commit Virt Free List UCR Virt Lock Fast (k) (k) (k) (k) length blocks cont. heap -----------------------------------------------------------------------------006f0000 00000002 1246976 1241928 1246976 982 236 81 0 a LFH00190000 00001002 3136 1564 3136 390 7 3 0 0 LFH External fragmentation 24 % (7 free blocks)00110000 00001002 256 4 256 1 1 1 0 0 02050000 00001002 256 176 256 1 18 1 0 0 LFH02240000 00001002 256 4 256 2 1 1 0 0 006a0000 00001002 64 12 64 4 2 1 0 0 044f0000 00001002 256 216 256 7 4 1 0 0 LFH119d0000 00001002 7424 5820 7424 134 133 4 0 c8 LFH14290000 00001003 256 4 256 2 1 1 0 bad 141d0000 00001003 256 4 256 2 1 1 0 bad 17f20000 00001003 256 4 256 2 1 1 0 bad 19030000 00001003 256 4 256 2 1 1 0 bad 191b0000 00001003 256 4 256 2 1 1 0 bad 19380000 00001003 256 4 256 2 1 1 0 bad 19300000 00001003 256 4 256 2 1 1 0 bad 155f0000 00001003 256 4 256 2 1 1 0 bad ----------------------------------------------------------------------------- 通过观察，我们知道了是006f0000堆块占用了大量内存12345HEAPEXT: Unable to read ntdll!RtlpDisableHeapLookaside Heap Flags Reserv Commit Virt Free List UCR Virt Lock Fast (k) (k) (k) (k) length blocks cont. heap -----------------------------------------------------------------------------006f0000 00000002 1246976 1241928 1246976 982 236 81 0 a LFH 查看堆块内存百分比内存持续上涨可能是某块固定大小内存被重复申请，所以统计下该堆块中各个内存大小的分配次数1!heap -stat -h 006f0000 查找堆中各个内存大小占用的百分比 123456789101112131415161718192021222324250:000&gt; !heap -stat -h 006f0000unable to resolve ntdll!RtlpStackTraceDataBase heap @ 006f0000group-by: TOTSIZE max-display: 20 size #blocks total ( %) (percent of total busy bytes) 14 23acbbe - 2c97ead8 (92.78) a4 2ba0c - 1bf2fb0 (3.63) 1000 8f5 - 8f5000 (1.16) 1a4 3b9c - 61cbf0 (0.79) 20c 15fb - 2cfdc4 (0.37) 25 b77d - 1a8511 (0.22) 64 3ba0 - 174a80 (0.19) 24 75ae - 108c78 (0.13) 11c e4a - fda18 (0.13) 84c 164 - b89b0 (0.09) 400 172 - 5c800 (0.05) 234 265 - 54684 (0.04) 1c 2c2e - 4d508 (0.04) 1c0 287 - 46c40 (0.04) c00 4b - 38400 (0.03) 20 1a12 - 34240 (0.03) 3bc ce - 30148 (0.02) 50 8da - 2c420 (0.02) 800 4c - 26000 (0.02) 2ba d2 - 23c94 (0.02) 12size #blocks total ( %) (percent of total busy bytes)14 23acbbe - 2c97ead8 (92.78) TOP 20 中显示，最多的一个大小为 0x014 的分配次数为 0x23acbbe 次， 总共大概有700M左右。基本接近内存泄漏的总数。那么我们就需要来确定这个内存是谁申请的。 定位内存来源找到了大量的内存是0x014字节大小的，但是根据这个条件我们也找不到具体的代码啊？下面是几个思路 思路1 根据大小根据内存大小（0x14）去代码中查找大小为（0x14）的类、结构体、宏等等相关代码，然后找到原因。难！！！1）、进程包含了很多其他组的dll，有的我没代码权限，无法遍历2）、结构体、类太多了，人眼遍历太难了（针对这个问题我开发了一个工具，后续章节讲解） 思路2 内存内容显示所有大小为（0x14）内存的地址，看它的地址内容有没有什么特点，比如是否有特殊的字符串、固定的二进制头？？？ 显示所有分配大小为 0x14的内存1!heap -flt s 14 12345678910111213141516171819202122232425262728290:000&gt; !heap -flt s 14 unable to resolve ntdll!RtlpStackTraceDataBase _HEAP @ 6f0000 HEAP_ENTRY Size Prev Flags UserPtr UserSize - state 0071c038 0004 0000 [00] 0071c040 00014 - (busy) 0071c2e8 0004 0004 [00] 0071c2f0 00014 - (busy) 0071e498 0004 0004 [00] 0071e4a0 00014 - (busy) 0071e4f8 0004 0004 [00] 0071e500 00014 - (busy) 0071e518 0004 0004 [00] 0071e520 00014 - (busy) 0071e5f8 0004 0004 [00] 0071e600 00014 - (busy) 0071e638 0004 0004 [00] 0071e640 00014 - (busy) 0071e658 0004 0004 [00] 0071e660 00014 - (busy) 0071e798 0004 0004 [00] 0071e7a0 00014 - (busy) 007374f0 0004 0004 [00] 007374f8 00014 - (busy) 00737510 0004 0004 [00] 00737518 00014 - (busy) 00737530 0004 0004 [00] 00737538 00014 - (busy) 00737550 0004 0004 [00] 00737558 00014 - (busy) 00737570 0004 0004 [00] 00737578 00014 - (busy) 00737590 0004 0004 [00] 00737598 00014 - (busy) 007375b0 0004 0004 [00] 007375b8 00014 - (busy) 007375d0 0004 0004 [00] 007375d8 00014 - (busy) 007375f0 0004 0004 [00] 007375f8 00014 - (busy) 00737610 0004 0004 [00] 00737618 00014 - (busy) 00737630 0004 0004 [00] 00737638 00014 - (busy) 00737650 0004 0004 [00] 00737658 00014 - (busy) 00737670 0004 0004 [00] 00737678 00014 - (busy) 00737690 0004 0004 [00] 00737698 00014 - (busy) .............. .............. 随机抽查几个地址，看下地址内存 大都是这样的值，实在是看不出规律。 建议一般公司都会封装malloc、new函数，并分配一个模块号，每个内存地址头部都会携带id号，如下：1xxx_malloc(int nModleID,size_t size); 这样通过地址空间内容也可以找到分配的模块。 思路3 分配次数大小0x14的内存在90天时间内总共分配了23acbbe 次， 0x23acbbe = 37407678/(90(天)*24(小时) ≈ 17318次/小时。 这个内存几乎每小时被申请17318次。公司的服务器有个基本功能：每个小时会统计收到的消息次数，那分析下数量级在1w~3w左右的消息即可，大概是4个消息类型，然后通过代码review发现内存泄漏点123456if(total_fee)&#123; LPADD_FEE pAddFee = new ADD_FEE; ZeroMemory(pAddFee, sizeof(ADD_FEE)); pAddFee-&gt;nFee = total_fee; gdt.nTotalFee = total_fee;&#125; 结构体 ADD_FEE ,刚好是20字节1234typedef struct _tagADD_FEE&#123; int nFee; int nReserved[4];&#125;ADD_FEE, *LPADD_FEE; 完全符合！！ 问题解决 总结这个一个低级错误导致的。为了避免类视问题，引入代码静态检测1）、cppcheck2）、pclint最后选了pclint。配合jenkins，每天凌晨进行代码静态检查，并输出和上个版本的diff文件，下次就不会出现这么低级的问题。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windbg分析临界区死锁]]></title>
    <url>%2F2019%2F05%2F07%2Fwindbg%E5%88%86%E6%9E%90%E4%B8%B4%E7%95%8C%E5%8C%BA%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[介绍多线程编程中，对于资源同步导致的死锁问题，应该是开发过程中经常碰到的，同时在问题定位过程中也会花费大量的时间，这里就介绍下如何通过windbg来分析死锁问题。 资源同步windows下资源同步的方法主要是 原子访问 临界区 读写锁 旋转锁 等待函数 事件 信号量 互斥量 其中最常用的应该是临界区了（性能开销小），所以我也是拿临界区作为分析对象，其他资源同步不在此讨论。 临界区保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么 在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操 作共享资源的目的。临界区包含两个操作原语：EnterCriticalSection（） 进入临界区LeaveCriticalSection（） 离开临界区EnterCriticalSection（） 语句执行后代码将进入临界区以后无论发生什么，必须确保与之匹配的 LeaveCriticalSection（）都能够被执行到。否则临界区保护的共享资源将永远不会被释放。虽然临界区同步速度很快，但却只能用来同步本 进程内的线程，而不可用来同步多个进程中的线程。 结构体定义12345678typedef struct _RTL_CRITICAL_SECTION &#123; PRTL_CRITICAL_SECTION_DEBUG DebugInfo; LONG LockCount; LONG RecursionCount; HANDLE OwningThread; HANDLE LockSemaphore; ULONG_PTR SpinCount;&#125; RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION; 各个参数的解释如下：第一个参数：PRTL_CRITICAL_SECTION_DEBUG DebugInfo;//调试用的第二个参数：LONG LockCount;//初始化为-1，n表示有n个线程在等待第三个参数：LONG RecursionCount;//表示该临界区的拥有线程对此资源获得临界区次数，初为0第四个参数：HANDLE OwningThread;//即拥有该临界区的线程句柄第五个参数：HANDLE LockSemaphore;//实际上是一个自复位事件第六个参数：DWORD SpinCount;//旋转锁的设置，单CPU下忽略 由这个结构可以知道：临界区会记录拥有该临界区的线程句柄，即临界区是有“线程所有权”概念的。事实上它会用第四个参数OwningThread来记录获准进入临界区的线程句柄，如果这个线程再次进入，EnterCriticalSection()会更新第三个参数RecursionCount以记录该线程进入的次数并立即返回让该线程进入。其它线程调用EnterCriticalSection()则会被切换到等待状态，一旦拥有线程所有权的线程调用LeaveCriticalSection()使其进入的次数为0时，系统会自动更新临界区并将等待中的线程换回可调度状态。 问题出现服务器工作线程每5s会定时上报当前还有多少消息堆积未处理，正常情况应该都是&lt;=10左右。如果出现cpu不足、io、死锁、假死等问题导致工作线程无法正常消费，那么消息堆积数量会逐渐上升。某天在告警群里面提示某服务的消息堆积从100、400、1000、3000、5000 逐渐上升，第一感觉就是服务出问题了，立刻让运维查看服务器cpu、内存、io，均正常，而且同物理主机的其他服务正常运行，所以问题应该是该服务程序出现了某些状况，可能是死锁、也可能是死循环、也可能是长时间sleep….. 立刻保存fulldump，然后重启服务，先恢复线上服务，以免给客户带来更大损失。 分析过程下载dump下载地址(提取码：33lg) 步骤1使用windbg 打开dump，并设置好pdb、操作系统pdb；使用命令 “~*kv” 显示所有线程当前的函数调用栈，效果如下（大部分省略） 123456789101112131415161718192021222324250:021&gt; ~*kv 0 Id: 173c.16d8 Suspend: 3 Teb: 7efdd000 UnfrozenChildEBP RetAddr Args to Child 0035b6b8 775514ab 000000d0 00000000 00000000 ntdll!NtWaitForSingleObject+0x15 (FPO: [3,0,0])0035b724 77441194 000000d0 ffffffff 00000000 KERNELBASE!WaitForSingleObjectEx+0x98 (FPO: [Non-Fpo])0035b73c 77441148 000000d0 ffffffff 00000000 kernel32!WaitForSingleObjectExImplementation+0x75 (FPO: [Non-Fpo])0035b750 75777be6 000000d0 ffffffff 0e9c9dd4 kernel32!WaitForSingleObject+0x12 (FPO: [Non-Fpo])0035b7f4 75778040 0070b1b8 000000d0 00000000 sechost!ScSendResponseReceiveControls+0xea (FPO: [Non-Fpo])0035b8a8 75778553 0035b8bc 00000000 00000001 sechost!ScDispatcherLoop+0xc2 (FPO: [Non-Fpo])*** WARNING: Unable to verify checksum for MatchSvr.exe0035b8c0 012432cb 0035b8cc 0035b938 012431a0 sechost!StartServiceCtrlDispatcherA+0x68 (FPO: [Non-Fpo])0035b8dc 01218689 fc7e3c0d 00000000 00000001 MatchSvr!CNTService::StartServiceA+0x2b0035f928 01253f2a 00000001 00708280 006ff620 MatchSvr!main+0x139 (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\main.cpp @ 190]0035f968 7744338a 7efde000 0035f9b4 77bf9f72 MatchSvr!__tmainCRTStartup+0xfd (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\dllstuff\crtexe.c @ 626]0035f974 77bf9f72 7efde000 85371315 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])0035f9b4 77bf9f45 01253f92 7efde000 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])0035f9cc 00000000 01253f92 7efde000 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 1 Id: 173c.290 Suspend: 3 Teb: 7ef9f000 UnfrozenChildEBP RetAddr Args to Child 02aef948 76fa7c1d 02aef9cc 00000000 00000000 user32!NtUserGetMessage+0x15 (FPO: [4,0,0])02aef968 0122d9ad 02aef9cc 00000000 00000000 user32!GetMessageA+0xa1 (FPO: [Non-Fpo])02aef9ec 0124326d 00000000 00712b08 00000000 MatchSvr!CMainService::Run+0x7d (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\service.cpp @ 65]02aefa0c 757775a8 00000001 00712b18 00000000 MatchSvr!CNTService::ServiceMain+0xcd 步骤2观察所有线程的函数调用。 这个服务并不复杂，总共只有二十几个线程（以前分析的都是至少100个线程的dump），然后重点查看服务进程的主要工作线程（是因为工作线程不工作才导致消息堆积）。 这个服务的工作线程有4个分别是10、11、12、13， 至于怎么确定的？1、看日志。良好的编码习惯，程序中的每个线程启动、退出都会在日志中记录2、对代码逻辑的熟悉 步骤3切换到其中任意一个工作线程，比如10号线程~10skv1234567891011121314151617181920212223242526272829303132330:010&gt; ~10seax=00000000 ebx=03020f70 ecx=00000000 edx=00000000 esi=7fffffff edi=ffffffffeip=77bdf8d1 esp=03bcf10c ebp=03bcf14c iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!NtWaitForSingleObject+0x15:77bdf8d1 83c404 add esp,40:010&gt; kvChildEBP RetAddr Args to Child 03bcf10c 74a06f1f 00000330 00000001 03bcf134 ntdll!NtWaitForSingleObject+0x15 (FPO: [3,0,0])03bcf14c 74a06d40 00000330 000001a4 00000001 mswsock!SockWaitForSingleObject+0x1ba (FPO: [Non-Fpo])03bcf238 75796a28 000001a5 00000000 03bcf2ec mswsock!WSPSelect+0x3a6 (FPO: [Non-Fpo])03bcf2b8 744d7787 000001a5 00000000 03bcf2ec ws2_32!select+0x494 (FPO: [Non-Fpo])WARNING: Stack unwind information not available. Following frames may be wrong.03bcf3f4 744d75f0 000001a4 00000004 ffffffff rabbitmq_4!amqp_open_socket+0x34703bcf600 744d76ca 00720ae8 000021e0 ffffffff rabbitmq_4!amqp_open_socket+0x1b003bcf620 744d9693 00720ae8 000021e0 00000000 rabbitmq_4!amqp_open_socket+0x28a03bcf638 744d7e26 0497bdc8 00720ae8 000021e0 rabbitmq_4!amqp_parse_url+0x3c303bcf650 01250550 0497bdc8 00720ae8 000021e0 rabbitmq_4!amqp_socket_open+0x1603bcf728 01250e97 fff73d65 0070b3d8 071ca950 MatchSvr!CRabbitMQ::connect+0xd003bcf840 01250870 0071ecf4 0071ecc4 03bcfa28 MatchSvr!CRabbitMQ::_publish_str_+0x18703bcf8a4 01250100 0071ecf4 0071ecc4 03bcfa28 MatchSvr!CRabbitMQ::sendmsg+0x2003bcf908 01218d48 0071ecf4 0071ecc4 03bcfa28 MatchSvr!CRabbitmqProc::sendmsg+0x2003bcf96c 01231fbc 03bcfa28 fff7382d 0070b3d8 MatchSvr!CProducerMQ::RabbitMQPublish_log+0x28 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\producermq.cpp @ 62]03bcfd08 0122eb98 071cae70 08c6c368 007022a8 MatchSvr!CSockServer::OnGameUserArenaResult+0xc3c (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\socksvr.cpp @ 1096]03bcfda4 012392e4 071cae70 08c6c368 0070b3e0 MatchSvr!CSockServer::OnRequest+0x718 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\socksvr.cpp @ 309]03bcfdcc 0123d1bb 00000000 00715868 007141b8 MatchSvr!CIocpWorker::DoWorkLoop+0xa403bcfde4 0123d18b 03bcfe24 70ffc01d 0070b3d8 MatchSvr!CBaseWorker::WorkerThreadProc+0x2b03bcfdec 70ffc01d 0070b3d8 0d15d467 00000000 MatchSvr!CBaseWorker::WorkerThreadFunc+0xb03bcfe24 70ffc001 00000000 03bcfe3c 7744338a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]03bcfe30 7744338a 007141b8 03bcfe7c 77bf9f72 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]03bcfe3c 77bf9f72 007141b8 86be14dd 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])03bcfe7c 77bf9f45 70ffbfb4 007141b8 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])03bcfe94 00000000 70ffbfb4 007141b8 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 从中，我们看到调用栈并没有什么问题，大概意思就是收到了一个GameUserArenaResult消息，然后通过mq publish出去，然后mq模块正在进行connect。感觉没有问题，接着看11号线程 ~11skv 1234567891011121314151617181920212223240:010&gt; ~11seax=00000001 ebx=00000000 ecx=00000000 edx=00000000 esi=007124f8 edi=00000000eip=77bdf8d1 esp=03ccf4cc ebp=03ccf530 iopl=0 nv up ei pl zr na pe nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246ntdll!NtWaitForSingleObject+0x15:77bdf8d1 83c404 add esp,40:011&gt; kvChildEBP RetAddr Args to Child 03ccf4cc 77bf8e44 00000e0c 00000000 00000000 ntdll!NtWaitForSingleObject+0x15 (FPO: [3,0,0])03ccf530 77bf8d28 00000000 00000000 0070b3e0 ntdll!RtlpWaitOnCriticalSection+0x13e (FPO: [Non-Fpo])03ccf558 01216e48 007124f8 0070b3d8 030c7658 ntdll!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo])03ccf5b4 0121525e 0070b3d8 030c7658 0070b3e0 MatchSvr!JMutex::Lock+0x28 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\jmutex.cpp @ 71]03ccf60c 01214b6a 007124f8 ff873359 0070b3d8 MatchSvr!JMutexAutoLock::JMutexAutoLock+0x1e (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\jmutexautolock.h @ 39]03ccf67c 01231c00 03ccf790 ff873f3d 0070b3d8 MatchSvr!CDelaySendMsg::AddMsg+0x3a (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\delaysendmsg.cpp @ 14]03ccfa18 0122eb98 05ebbe68 088d7790 00702348 MatchSvr!CSockServer::OnGameUserArenaResult+0x880 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\socksvr.cpp @ 1071]03ccfab4 012392e4 05ebbe68 088d7790 0070b3e0 MatchSvr!CSockServer::OnRequest+0x718 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\socksvr.cpp @ 309]03ccfadc 0123d1bb 00000000 00715ff8 007154a0 MatchSvr!CIocpWorker::DoWorkLoop+0xa403ccfaf4 0123d18b 03ccfb34 70ffc01d 0070b3d8 MatchSvr!CBaseWorker::WorkerThreadProc+0x2b03ccfafc 70ffc01d 0070b3d8 0d65d177 00000000 MatchSvr!CBaseWorker::WorkerThreadFunc+0xb03ccfb34 70ffc001 00000000 03ccfb4c 7744338a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]03ccfb40 7744338a 007154a0 03ccfb8c 77bf9f72 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]03ccfb4c 77bf9f72 007154a0 86ce112d 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])03ccfb8c 77bf9f45 70ffbfb4 007154a0 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])03ccfba4 00000000 70ffbfb4 007154a0 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 这个堆栈就有意思了，大概就是收到了OnGameUserArenaResult消息，然后AddMsg，进入一个AutoLock，然后RtlEnterCriticalSection，看到这个说明很可能有死锁问题。我们继续观察这个临界区的具体信息103ccf558 01216e48 007124f8 0070b3d8 030c7658 ntdll!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo]) 注意其中的第三列、第四列、第五列， 分别代表了这个函数的第一个入参、第二个入参、第三个入参， 之前看过临界区的结构体，所以使用以下命令1!cs 007124f8 12345678910110:011&gt; !cs 007124f8-----------------------------------------Critical section = 0x007124f8 (+0x7124F8)DebugInfo = 0x007184b8LOCKEDLockCount = 0x2WaiterWoken = NoOwningThread = 0x00001188RecursionCount = 0x1LockSemaphore = 0xE0CSpinCount = 0x00000000 这个临界区正在被 0x00001188 的线程占用，所以导致11s线程无法进入临界区，那么我们就去 0x00001188 线程在做什么。通过线程id显示线程号命令~~[0x00001188]12340:011&gt; ~~[0x00001188] 4 Id: 173c.1188 Suspend: 3 Teb: 7ef96000 Unfrozen Start: msvcr120!_threadstartex (70ffbfb4) Priority: 0 Priority class: 32 Affinity: 3 4号线程，然后我们切换~4skv1234567891011121314151617180:004&gt; kvChildEBP RetAddr Args to Child 02fdf4b0 77bf8e44 00000dcc 00000000 00000000 ntdll!NtWaitForSingleObject+0x15 (FPO: [3,0,0])02fdf514 77bf8d28 00000000 00000000 00713298 ntdll!RtlpWaitOnCriticalSection+0x13e (FPO: [Non-Fpo])02fdf53c 01253666 00720b68 00000000 00713df0 ntdll!RtlEnterCriticalSection+0x150 (FPO: [Non-Fpo])02fdf598 0125232e 00000000 00713df0 00713298 MatchSvr!CJMutex::Lock+0x2602fdf5f0 01250d6a 00720b68 feb63229 00000000 MatchSvr!CJAutoLock::CJAutoLock+0x1e02fdf70c 01250870 0071ecf4 0071ecdc 061b729c MatchSvr!CRabbitMQ::_publish_str_+0x5a02fdf770 01250100 0071ecf4 0071ecdc 061b729c MatchSvr!CRabbitMQ::sendmsg+0x2002fdf7d4 01218d88 0071ecf4 0071ecdc 061b729c MatchSvr!CRabbitmqProc::sendmsg+0x2002fdf838 01214ccd 061b729c feb63ded 00000000 MatchSvr!CProducerMQ::RabbitMQPublish_Award+0x28 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\producermq.cpp @ 72]02fdf8c8 012172b9 00000000 00713df0 00713298 MatchSvr!CDelaySendMsg::Thread+0x11d (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\delaysendmsg.cpp @ 46]02fdf924 70ffc01d 007124a0 0c54d31f 00000000 MatchSvr!JThread::TheThread+0x39 (FPO: [Non-Fpo]) (CONV: stdcall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\matchsvr\jthread.cpp @ 175]02fdf95c 70ffc001 00000000 02fdf974 7744338a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]02fdf968 7744338a 00713298 02fdf9b4 77bf9f72 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]02fdf974 77bf9f72 00713298 87ff1315 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])02fdf9b4 77bf9f45 70ffbfb4 00713298 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])02fdf9cc 00000000 70ffbfb4 00713298 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 4号线程MQ正在publish一个消息，而这个消息中有一个临界区，这个临界区可能又正在被其他线程占用。 继续查看临界区12345678910110:004&gt; !cs 00720b68 -----------------------------------------Critical section = 0x00720b68 (+0x720B68)DebugInfo = 0x0071e070LOCKEDLockCount = 0x3WaiterWoken = NoOwningThread = 0x00001590RecursionCount = 0x2LockSemaphore = 0xDCCSpinCount = 0x00000000 这个临界区正在被0x00001590 线程占用，再看看这个线程号是多少~~[0x00001590]12340:004&gt; ~~[0x00001590] 10 Id: 173c.1590 Suspend: 3 Teb: 7ef81000 Unfrozen Start: msvcr120!_threadstartex (70ffbfb4) Priority: 0 Priority class: 32 Affinity: 3 ？？？？ 怎么又回到10号线程了， 再仔细看看10s线程之前我们看的时候觉的没问题，但这里肯定是有问题的，会不会’connect’ 阻塞了呢? 带着疑问查看了下消息堆积时段的日志，有MQ断开的日志。带着猜测自己重现现场试试看，在本地启动服务，然后重启mq服务，发现问题必现。解决方法就是使用非阻塞式的connect函数，问题解决。 总结这里介绍了几个windbg的常用命令，讲解了死锁的一般分析方法，对于这类问题更多的是观察、思考。希望能带给你帮助，如果觉的有用，请帮忙打赏下吧！后续还有一些有意思的dump来分享，比如内存泄漏、死锁+崩溃、踩内存、高cpu等。现在的dump素材没有以前的多了，不然我可以把很多案例都写出来，有些问题没有案例还是挺难讲的。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[异常引起的死锁]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%BC%82%E5%B8%B8%E5%BC%95%E8%B5%B7%E7%9A%84%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[介绍一个json异常导致的死锁分析。同事某天求助帮忙分析一个死锁dump，按照之前查找临界区的方法，他已经具体定位到了某个线程，但是线程打印的堆栈信息却令他没有头绪。 准备工作dump下载地址（提取码：ndel） 步骤1按照之前的方法1）、~*kv 打印所有线程堆栈2）、遍历线程内容，找到可疑点3）、可疑线程为52、53、54…… 2通过查看临界区的OwningThread 找到线程 56切换到~56 线程。 3查看56线程堆栈（kv）1234567891011121314151617181920212223240:056&gt; kvChildEBP RetAddr Args to Child 08ccd8d4 76ddd846 00000000 00000000 00000000 user32!NtUserWaitMessage+0x15 (FPO: [0,0,0])08ccd910 76ddda5c 06f400d2 00000000 00000000 user32!DialogBox2+0x222 (FPO: [Non-Fpo])08ccd93c 76e0f7d0 76da0000 09f6fe90 00000000 user32!InternalDialogBox+0xe5 (FPO: [Non-Fpo])08ccd9f0 76e0faac 00012010 00000000 ffffffff user32!SoftModalMessageBox+0x757 (FPO: [Non-Fpo])08ccdb48 76e0fbaf 08ccdb54 00000028 00000000 user32!MessageBoxWorker+0x269 (FPO: [Non-Fpo])08ccdbb4 76e0fc2e 00000000 0084acf8 09ee8d38 user32!MessageBoxTimeoutW+0x52 (FPO: [Non-Fpo])08ccdbe8 76e0fd81 00000000 08ccdd84 0028f764 user32!MessageBoxTimeoutA+0x76 (FPO: [Non-Fpo])08ccdc08 76e0fdc6 00000000 08ccdd84 0028f764 user32!MessageBoxExA+0x1b (FPO: [Non-Fpo])*** WARNING: Unable to verify checksum for XYSoapClient.dll*** ERROR: Symbol file could not be found. Defaulted to export symbols for XYSoapClient.dll - 08ccdc24 0028cdd9 00000000 08ccdd84 0028f764 user32!MessageBoxA+0x18 (FPO: [Non-Fpo])WARNING: Stack unwind information not available. Following frames may be wrong.08ccde24 0028bf49 0000000a 00289e54 0028ba37 XYSoapClient!DllUnregisterServer+0x6bae08ccde5c 769a03bb 08ccdf14 9616d04a 00000000 XYSoapClient!DllUnregisterServer+0x5d1e08ccdee4 77d65be7 08ccdf14 77d65ac4 00000000 kernel32!UnhandledExceptionFilter+0x127 (FPO: [Non-Fpo])08ccdeec 77d65ac4 00000000 08ccfe1c 77d1c620 ntdll!__RtlUserThreadStart+0x62 (FPO: [SEH])08ccdf00 77d65951 00000000 00000000 00000000 ntdll!_EH4_CallFilterFunc+0x12 (FPO: [Uses EBP] [0,0,4])08ccdf28 77d53529 fffffffe 08ccfe0c 08cce064 ntdll!_except_handler4+0x8e (FPO: [Non-Fpo])08ccdf4c 77d534fb 08cce014 08ccfe0c 08cce064 ntdll!ExecuteHandler2+0x26 (FPO: [Uses EBP] [5,3,1])08ccdf70 77d5349c 08cce014 08ccfe0c 08cce064 ntdll!ExecuteHandler+0x24 (FPO: [5,0,3])08ccdffc 77d00143 01cce014 08cce064 08cce014 ntdll!RtlDispatchException+0x127 (FPO: [Non-Fpo])08ccdffc 00000000 01cce014 08cce064 08cce014 ntdll!KiUserExceptionDispatcher+0xf (FPO: [2,0,0]) (CONTEXT @ 00000008) 疑惑同事按照方法找到了导致死锁的线程，但从堆栈中却看不出原因，都是系统函数，有点无从下手。从这个堆栈信息大致猜测是该线程触发了一个异常并弹出了异常框导致线程阻塞（由于是服务模式所以看不到这个异常框），但是锁资源却没有释放，从而导致了其他线程也出现了死锁。接下来，我们需要从这个堆栈信息切换到异常发生时的堆栈信息。 切换异常上下文函数原型1KiUserExceptionDispatcher( PEXCEPTION_RECORD pExcptRec, CONTEXT * pContext ) KiUserExceptionDispatcher 的第二个参数其实就是上下文地址108ccdffc 00000000 01cce014 08cce064 08cce014 ntdll!KiUserExceptionDispatcher+0xf (FPO: [2,0,0]) (CONTEXT @ 00000008) 可以通过如下命令，切换上下文1.cxr 08cce064 最终得到的异常堆栈1234567891011121314151617181920212223240:056&gt; .cxr 08cce064 eax=08cce4c8 ebx=00792f90 ecx=00000003 edx=00000000 esi=00f3de44 edi=08cce570eip=7767c54f esp=08cce4c8 ebp=08cce518 iopl=0 nv up ei pl nz ac po nccs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000212KERNELBASE!RaiseException+0x58:7767c54f c9 leave0:056&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 08cce518 6f799339 e06d7363 00000001 00000003 KERNELBASE!RaiseException+0x58 (FPO: [Non-Fpo])08cce558 00ee5f9b 08cce570 00f3de44 419ffac3 msvcr120!_CxxThrowException+0x5b (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]08cce5a0 00ee3852 08cce660 419ff9eb 00f1be7d gssssvr!Json::throwLogicError+0x7b08cce688 00ee42c4 00f1be7c 00f1be83 00792f88 gssssvr!Json::Value::find+0x8208cce6a0 00e1d5a5 00f1be7c 419fe277 09f03cd0 gssssvr!Json::Value::isMember+0x2408ccfd14 00e1bc40 007c5b50 09f04018 0084eb60 gssssvr!CGameServer::OnSendSysMsgToServer+0x985 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gssssvr\gssssvr\server.cpp @ 675]08ccfd44 00ed9124 007c5b50 09f04018 00792f90 gssssvr!CGameServer::OnRequest+0x90 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gssssvr\gssssvr\server.cpp @ 162]08ccfd6c 00eccf1b 00000000 045f7f30 008295e8 gssssvr!CIocpWorker::DoWorkLoop+0xa408ccfd84 00ecceeb 08ccfdc4 6f7ac01d 00792f88 gssssvr!CBaseWorker::WorkerThreadProc+0x2b08ccfd8c 6f7ac01d 00792f88 961623f0 00000000 gssssvr!CBaseWorker::WorkerThreadFunc+0xb08ccfdc4 6f7ac001 00000000 08ccfddc 7696336a msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]08ccfdd0 7696336a 008295e8 08ccfe1c 77d29902 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]08ccfddc 77d29902 008295e8 ab5803ad 00000000 kernel32!BaseThreadInitThunk+0xe (FPO: [Non-Fpo])08ccfe1c 77d298d5 6f7abfb4 008295e8 ffffffff ntdll!__RtlUserThreadStart+0x70 (FPO: [Non-Fpo])08ccfe34 00000000 6f7abfb4 008295e8 00000000 ntdll!_RtlUserThreadStart+0x1b (FPO: [Non-Fpo]) 这个堆栈信息就可以看清楚触发异常的具体代码，结合windbg的‘watch’‘local’功能查看变量信息，找到具体原因。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用CMap导致服务高CPU]]></title>
    <url>%2F2019%2F05%2F07%2F%E4%BD%BF%E7%94%A8CMap%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E9%AB%98CPU%2F</url>
    <content type="text"><![CDATA[某天某服务预警一直提示某服务性能不足，cpu已满负荷。很是纳闷，这个服务是纯内存数据，没有io操作；而且都运行了快3个月了，怎么突然就性能不足了？ 步骤1半夜从睡梦中被叫醒，先自己缕一缕思路（整个人都是懵的，基本缕不出思路），先解决线上问题， 让运维保存了一份fulldump，然后重启服务，线上正常，回去睡觉。 异常出现时需要哪些现场信息，比如日志、dump、cpu、内存状态……;因为平时有积累，比如cpu、内存信息主机是有程序在定时生成的；版本（svn、pdb、exe)是自动化编译自动保存的；…… 步骤2向运维取了当时的dump文件(提取码: q5kx)，向版本服务器获取了匹配的pdb、svn记录，获取了当时的日志、cpu、内存信息。使用windbg 打开dump，发现是一个64位dump。 步骤3加载pdb，将64位dump切换到32位，然后打印所有线程。12340:000&gt; .load wow64exts0:000&gt; !swSwitched to 32bit mode0:000:x86&gt; ~*kv 123456789101112131415161718192021222324252627282930313233 0 Id: c2c.a4c Suspend: 0 Teb: 7efdb000 Unfrozen*** ERROR: Symbol file could not be found. Defaulted to export symbols for ntdll.dll - *** ERROR: Symbol file could not be found. Defaulted to export symbols for kernel32.dll - ChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.0015f260 75dd1194 000000e4 ffffffff 00000000 ntdll_77b80000!NtWaitForSingleObject+0x150015f278 75dd1148 000000e4 ffffffff 00000000 kernel32!WaitForSingleObjectEx+0x43*** ERROR: Symbol file could not be found. Defaulted to export symbols for sechost.dll - 0015f28c 77717be6 000000e4 ffffffff e15460f0 kernel32!WaitForSingleObject+0x120015f330 77718040 0059f808 000000e4 00000000 sechost!I_ScIsSecurityProcess+0x8a70015f3e4 77718553 0015f3f8 00000000 00000001 sechost!RegisterServiceCtrlHandlerExA+0x27a*** WARNING: Unable to verify checksum for kubsvr.exe0015f3fc 001dd97b 0015f408 0015f438 001dd850 sechost!StartServiceCtrlDispatcherA+0x680015f418 001c76ad 7aed560b 0002001d 00000000 kubsvr!CNTService::StartServiceA+0x2b0015f91c 001de205 00000001 005938e0 0058cc28 kubsvr!main+0x28d (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\kubsvr\main.cpp @ 165]0015f95c 75dd338a 7efde000 0015f9a8 77bb9902 kubsvr!__tmainCRTStartup+0xfd (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\dllstuff\crtexe.c @ 626]0015f968 77bb9902 7efde000 ec718eae 00000000 kernel32!BaseThreadInitThunk+0x120015f9a8 77bb98d5 001de26d 7efde000 ffffffff ntdll_77b80000!RtlInitializeExceptionChain+0x630015f9c0 00000000 001de26d 7efde000 00000000 ntdll_77b80000!RtlInitializeExceptionChain+0x36 1 Id: c2c.dfc Suspend: 0 Teb: 7ef9d000 Unfrozen*** ERROR: Symbol file could not be found. Defaulted to export symbols for user32.dll - ChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.0265fef4 001cf23b 0265ff0c 00000000 00000000 user32!DispatchMessageW+0x5c0265ff2c 001dd91d 00000000 005a6b00 00000000 kubsvr!CMainService::Run+0x4b (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\kubsvr\service.cpp @ 68]0265ff4c 777175a8 00000001 005a6b10 00000000 kubsvr!CNTService::ServiceMain+0xcd0265ff60 75dd338a 005a6b00 0265ffac 77bb9902 sechost!I_ScIsSecurityProcess+0x2690265ff6c 77bb9902 005a6b00 ee0188aa 00000000 kernel32!BaseThreadInitThunk+0x120265ffac 77bb98d5 77717587 005a6b00 ffffffff ntdll_77b80000!RtlInitializeExceptionChain+0x630265ffc4 00000000 77717587 005a6b00 00000000 ntdll_77b80000!RtlInitializeExceptionChain+0x36................................................ 步骤4分析各个线程。从线程中可以看到总共有24个线程，其中有部分能看到代码，有部分不能看到代码。我们只能先从有代码的线程开始分析，因为这部分线程才是自己程序的主要处理模块。可以看到大多线程都在处理 CSockServer::OnPlayerLogon 函数，查看对应的代码，理了下大概逻辑：服务程序使用8个线程接收用户登陆请求，并将用户信息保存在一个全局CMap中，CMay的key是用户id，value是一个类。这个dump线程反应出来的就是当时在处理很多用户的登陆信息，没有什么异常点啊？？？？ 当时就觉的碰到坎了，认为导的dump可能不是引起cpu高时的运行栈， 后悔应该让运维多导几个dump，通过比较应该找的到高cpu时线程运行栈。暂时没辙就打开看下当时的参数信息，慢慢的就看到了CMap的大小 切换到9号线程~9s123456789101112131415160:009:x86&gt; kvChildEBP RetAddr Args to Child 0377f87c 001b3a7d 0addba3c 0377f898 0377f890 kubsvr!CMap&lt;int,int,_tagPLAYER_LOGON_MINI,_tagPLAYER_LOGON_MINI &amp;&gt;::GetAssocAt+0x61 (FPO: [Non-Fpo]) (CONV: thiscall) [c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\afxtempl.h @ 1542]0377f8a8 001bad38 0addba3c 005a1a58 200d99a8 kubsvr!CMap&lt;int,int,_tagPLAYER_LOGON_MINI,_tagPLAYER_LOGON_MINI &amp;&gt;::operator[]+0x1d (FPO: [Non-Fpo]) (CONV: thiscall) [c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\afxtempl.h @ 1589]0377f8c0 001b7a53 0addba3c 0377f8e0 798f5637 kubsvr!CMap&lt;int,int,_tagPLAYER_LOGON_MINI,_tagPLAYER_LOGON_MINI &amp;&gt;::SetAt+0x18 (FPO: [Non-Fpo]) (CONV: thiscall) [c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\afxtempl.h @ 1349]0377f920 001cfc90 1c8d1540 2008cb20 00593ee8 kubsvr!CSockServer::OnPlayerLogon+0xb3 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\kubsvr\folder.cpp @ 1602]0377f950 001d1904 1c8d1540 2008cb20 005a1a60 kubsvr!CSockServer::OnRequest+0x660 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\kubsvr\socksvr.cpp @ 166]0377f978 001d818b 00000000 005be950 005bd800 kubsvr!CIocpWorker::DoWorkLoop+0xa40377f990 001d815b 0377f9d0 7347c01d 005a1a58 kubsvr!CBaseWorker::WorkerThreadProc+0x2b0377f998 7347c01d 005a1a58 e2366994 00000000 kubsvr!CBaseWorker::WorkerThreadFunc+0xbWARNING: Stack unwind information not available. Following frames may be wrong.0377f9d0 7347c001 00000000 0377f9e8 75dd338a MSVCR120!_get_flsindex+0x6f0377f9dc 75dd338a 005bd800 0377fa28 77bb9902 MSVCR120!_get_flsindex+0x530377f9e8 77bb9902 005bd800 ef138d2e 00000000 kernel32!BaseThreadInitThunk+0x120377fa28 77bb98d5 7347bfb4 005bd800 ffffffff ntdll_77b80000!RtlInitializeExceptionChain+0x630377fa40 00000000 7347bfb4 005bd800 00000000 ntdll_77b80000!RtlInitializeExceptionChain+0x36 打开windbg菜单“view”中的“local”、“calls” 可以看到CMap的m_nCount = 0n770036,放置了大约70w用户，调用CMap.SetAt()。难道SetAt性能不好？？ 由于是前人的历史代码，我对CMap基本不熟悉，所以就抱着这个疑问写了个demo进行验证，果然，在CMap达到40w左右时，SetAt性能急剧下降，到70w左右插入可能需要10秒的时间。更换了std::map ，长期观察程序很稳定。 结论在分析高cpu时有几个操作不对的地方，1）没有让运维多导几个fulldump2）CMap性能差真没想到，吃一堑长一智，看来都得用std::map 才行 后续的任务1）全部门代码替换CMap为std::map]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[捕获异常并自动保存dump]]></title>
    <url>%2F2019%2F05%2F07%2F%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E5%B9%B6%E8%87%AA%E5%8A%A8%E4%BF%9D%E5%AD%98dump%2F</url>
    <content type="text"><![CDATA[SetUnhandledExceptionFilter 捕获的异常有限，比如ctr异常、栈溢出的异常就无法捕获。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/************************************************************************//* 之所以应用程序捕获不到栈溢出异常，原因是因为新版本的CRT实现在异常处理中强制删除所有应用程序先前设置的捕获函数，如下所示：__crtUnhandledException()&#123;SetUnhandledExceptionFilter(NULL);UnhandledExceptionFilter(&amp;ExceptionPointers);&#125;解决方法是拦截CRT调用SetUnhandledExceptionFilter函数，使之无效。在X86平台下，可以使用以下代码 * //************************************************************************/void DisableSetUnhandledExceptionFilter()&#123; void *addr = (void*)GetProcAddress(LoadLibrary(_T("kernel32.dll")), "SetUnhandledExceptionFilter"); if (addr) &#123; unsigned char code[16]; int size = 0; code[size++] = 0x33; code[size++] = 0xC0; code[size++] = 0xC2; code[size++] = 0x04; code[size++] = 0x00; DWORD dwOldFlag, dwTempFlag; (void)VirtualProtect(addr, size, PAGE_READWRITE, &amp;dwOldFlag); (void)WriteProcessMemory(GetCurrentProcess(), addr, code, size, NULL); (void)VirtualProtect(addr, size, dwOldFlag, &amp;dwTempFlag); &#125;&#125;void WriteMiniDMP(struct _EXCEPTION_POINTERS *pExp)&#123; CString strDumpFile; TCHAR szFilePath[MAX_PATH]; GetModuleFileName(NULL, szFilePath, MAX_PATH); *strrchr(szFilePath, '\\') = 0; SYSTEMTIME stTime; GetLocalTime(&amp;stTime); // 保存fulldump &#123; strDumpFile.Format("%s\\[%02d-%02d %02d-%02d-%02d]full.dmp", szFilePath, stTime.wMonth, stTime.wDay, stTime.wHour, stTime.wMinute, stTime.wSecond); HANDLE hFile = CreateFile(strDumpFile, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile != INVALID_HANDLE_VALUE) &#123; MINIDUMP_EXCEPTION_INFORMATION ExInfo; ExInfo.ThreadId = ::GetCurrentThreadId(); ExInfo.ExceptionPointers = pExp; ExInfo.ClientPointers = NULL; // write the dump (void)MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), hFile, (MINIDUMP_TYPE)0x9b67, &amp;ExInfo, NULL, NULL); CloseHandle(hFile); &#125; &#125;&#125;LONG WINAPI ExpFilter(struct _EXCEPTION_POINTERS *pExp)&#123; static bool flag = false; if (!flag)&#123; // 防止多个线程同时写dump导致系统函数死锁 flag = true; WriteMiniDMP(pExp); flag = false; &#125; return EXCEPTION_EXECUTE_HANDLER;&#125;int main(int argc, char* argv[])&#123; ::SetUnhandledExceptionFilter(ExpFilter); //捕获crt的栈溢出异常 if ("10" != getOSName()) // win10 系统不生效 &#123; DisableSetUnhandledExceptionFilter(); &#125; ........&#125; 如上基本可以捕获大部分异常]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单分析minidump(2)]]></title>
    <url>%2F2019%2F05%2F07%2F%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90minidump-2%2F</url>
    <content type="text"><![CDATA[有了前几节的准备工作，我们的程序已经可以自动捕获异常了，那么我们开始通过windbg来分析dump解决实际问题。先从简单入手，CString大小写转化导致的异常（提取码ffk6）。 步骤1使用windbg打开minidump，设置好应用程序的pdb， 执行命令 “.ecxr” 、”kv” ,打印如下栈信息 1234567891011121314151617181920212223242526272829300:121&gt; .ecxreax=0e16eea8 ebx=00160768 ecx=00000000 edx=00000001 esi=0e16ef38 edi=0e16ef48eip=7c80bef7 esp=0e16eea4 ebp=0e16eef8 iopl=0 nv up ei pl nz na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000206Unable to load image C:\WINDOWS\system32\kernel32.dll, Win32 error 0n2*** WARNING: Unable to verify timestamp for kernel32.dll*** ERROR: Module load completed but symbols could not be loaded for kernel32.dllkernel32+0xbef7:7c80bef7 ?? ???*** ERROR: Module load completed but symbols could not be loaded for mfc120.dll0:121&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child WARNING: Stack unwind information not available. Following frames may be wrong.0e16eea0 1028bc8c e06d7363 00000001 00000000 kernel32+0xbef7*** WARNING: Unable to verify timestamp for msvcr120.dll*** ERROR: Module load completed but symbols could not be loaded for msvcr120.dll0e16eef8 005a9339 e06d7363 00000001 00000003 mfc120+0x28bc8c0e16ef38 101eee11 0e16ef48 1028bc8c 1029b540 msvcr120+0x193390e16ef4c 100566d4 00160760 0b139848 004a67d2 mfc120+0x1eee11*** WARNING: Unable to verify timestamp for BlockSvr.exe0e16ef8c 004dc703 0b224248 ec476e15 00000002 mfc120+0x566d40e16fea0 004c2bcf 0b139e10 0b167c20 001dfe60 BlockSvr!CSockServer::OnLogonUserV2+0x723 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\user.cpp @ 11713]0e16ff2c 005041e4 0b139e10 0b167c20 00160768 BlockSvr!CSockServer::OnRequest+0x90f (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\socksvr.cpp @ 424]0e16ff54 0050c04b 00000000 0b088970 0b2ec408 BlockSvr!CIocpWorker::DoWorkLoop+0xa40e16ff6c 0050c01b 0e16ffac 005bc01d 00160760 BlockSvr!CBaseWorker::WorkerThreadProc+0x2b0e16ff74 005bc01d 00160760 9835355e 00000000 BlockSvr!CBaseWorker::WorkerThreadFunc+0xb0e16ffac 005bc001 00000000 0e16ffec 7c82482f msvcr120+0x2c01d0e16ffb8 7c82482f 0b2ec408 00000000 00000000 msvcr120+0x2c0010e16ffec 00000000 005bbfb4 0b2ec408 00000000 kernel32+0x2482f 步骤2显示了应用程序的代码行号，但我们希望看到更仔细点，就需要加载windows的系统符号文件 1e:\mylocalsymbols;SRV*e:\mylocalsymbols*http://msdl.microsoft.com/download/symbols 步骤3设置后，重新“kv” 查看堆栈信息，显示如下 12345678910111213141516170:121&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 0e16eef8 005a9339 e06d7363 00000001 00000003 kernel32!RaiseException+0x53 (FPO: [Non-Fpo])0e16ef38 101eee11 0e16ef48 1028bc8c 1029b540 msvcr120!_CxxThrowException+0x5b (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\eh\throw.cpp @ 152]0e16ef4c 100566d4 00160760 0b139848 004a67d2 mfc120!AfxThrowInvalidArgException+0x19 (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\vc7libs\ship\atlmfc\src\mfc\except.cpp @ 228]*** WARNING: Unable to verify timestamp for BlockSvr.exe0e16ef58 004a67d2 ec477f39 00000000 49bf1ce1 mfc120!ATL::CStringT&lt;char,StrTraitMFC_DLL&lt;char,ATL::ChTraitsCRT&lt;char&gt; &gt; &gt;::MakeLower+0x23 (FPO: [0,0,0]) (CONV: thiscall) [f:\dd\vctools\vc7libs\ship\atlmfc\include\cstringt.h @ 1796]0e16ef8c 004dc703 0b224248 ec476e15 00000002 BlockSvr!IsTempLogonToken+0x52 (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\main.cpp @ 2277]0e16fea0 004c2bcf 0b139e10 0b167c20 001dfe60 BlockSvr!CSockServer::OnLogonUserV2+0x723 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\user.cpp @ 11713]0e16ff2c 005041e4 0b139e10 0b167c20 00160768 BlockSvr!CSockServer::OnRequest+0x90f (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\blocksvr\socksvr.cpp @ 424]0e16ff54 0050c04b 00000000 0b088970 0b2ec408 BlockSvr!CIocpWorker::DoWorkLoop+0xa40e16ff6c 0050c01b 0e16ffac 005bc01d 00160760 BlockSvr!CBaseWorker::WorkerThreadProc+0x2b0e16ff74 005bc01d 00160760 9835355e 00000000 BlockSvr!CBaseWorker::WorkerThreadFunc+0xb0e16ffac 005bc001 00000000 0e16ffec 7c82482f msvcr120!_callthreadstartex+0x1b (FPO: [Non-Fpo]) (CONV: cdecl) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 376]0e16ffb8 7c82482f 0b2ec408 00000000 00000000 msvcr120!_threadstartex+0x7c (FPO: [Non-Fpo]) (CONV: stdcall) [f:\dd\vctools\crt\crtw32\startup\threadex.c @ 354]0e16ffec 00000000 005bbfb4 0b2ec408 00000000 kernel32!BaseThreadStart+0x34 (FPO: [Non-Fpo]) 结论可以看到是由于CString 触发了_CxxThrowException。 服务从VC6版本切换到VS2013，CString 的MakeLower 函数检查变的更加严格，部分特殊用户名在VC6中正确转化，但是在vs2013中会抛出异常，将大小写转化函数替换为CharLower ，问题解决]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单分析minidump(1)]]></title>
    <url>%2F2019%2F05%2F07%2F%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90minidump-1%2F</url>
    <content type="text"><![CDATA[有了前几节的准备工作，我们的程序已经可以自动捕获异常了，那么我们开始通过windbg来分析dump解决实际问题。先从简单入手，一个index过大导致数组越界引发的崩溃。 1、使用windbg 打开dump，设置pdb、系统pdb。 2、设置完成后，执行命令”.ecxr”。 因为是程序自动截获异常，所以dump中已保存了异常的上下文，直接使用”.ecxr” 切换即可。1234560:135&gt; .ecxreax=0dea0048 ebx=0016ae18 ecx=7ff22000 edx=004b38e8 esi=0aba40b8 edi=0016ae10eip=004448cd esp=0ba9ebfc ebp=0ba9ec08 iopl=0 nv up ei pl zr na pe nccs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010246CheckSvr!CalcKubIndexByGameID+0x1d:004448cd ?? ??? 3、“kv”。打印异常上下文的栈信息123456789100:135&gt; kv *** Stack trace for last set context - .thread/.cxr resets itChildEBP RetAddr Args to Child 0ba9ec08 0040d9c4 0dea0048 af7220ac 0016ae10 CheckSvr!CalcKubIndexByGameID+0x1d (FPO: [Non-Fpo]) (CONV: cdecl) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\checksvr\main.cpp @ 1082]0ba9fcd4 0040bcb4 0db37c10 0db41a88 0aae48c0 CheckSvr!CSockServer::OnRefreshResultExFromKub+0x1ce4 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\checksvr\cmpaqpro.cpp @ 1081]0ba9feb4 0045ca88 0db37c10 0db41a88 0aae48c0 CheckSvr!CSockServer::OnRefreshResultEx+0x134 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\checksvr\cmpaqpro.cpp @ 419]0ba9ff2c 00477674 0db37c10 0db41a88 0016ae18 CheckSvr!CSockServer::OnRequest+0xd38 (FPO: [Non-Fpo]) (CONV: thiscall) [d:\program files (x86)\jenkins\workspace\publish_gamechannel\checksvr\socksvr.cpp @ 1931]0ba9ff54 0047e7db 00000000 0aae5e68 0a9c23a0 CheckSvr!CIocpWorker::DoWorkLoop+0xa40ba9ff6c 0047e7ab 0ba9ffac 0050c01d 0016ae10 CheckSvr!CBaseWorker::WorkerThreadProc+0x2b0ba9ff74 0050c01d 0016ae10 876c3023 00000000 CheckSvr!CBaseWorker::WorkerThreadFunc+0xb 4、异常函数为CalcKubIndexByGameID， 入参的值为0dea0048。 回到代码查看CalcKubIndexByGameID的实现， 1234int CalcKubIndexByGameID(int nGameID )&#123; return g_kub[nGameID];&#125; 明显nGameID 过大导致访问数组越界。 然后排查代码，发现nGameID未使用默认值，某些条件下使用了随机值导致。在代码编译中关闭“代码优化”，才可以使用这种方式。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何错过异常第一现场找到异常上下文]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%A6%82%E4%BD%95%E9%94%99%E8%BF%87%E5%BC%82%E5%B8%B8%E7%AC%AC%E4%B8%80%E7%8E%B0%E5%9C%BA%E6%89%BE%E5%88%B0%E5%BC%82%E5%B8%B8%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
    <content type="text"><![CDATA[介绍前面的章节都在讲解通过SetUnhandledExceptionFilter 设置程序自动捕获异常dump，这类dump通过.ecxr 命令或者 !analyze -v 就可以找到异常，但是在有些情况下（比如别人的项目），没有自动保存异常dump时应该怎么分析呢？ 现象某个新项目在测试环境出现了异常，弹出了一个异常框，这是windows下比较常见的异常框，是因为程序遇到了异常，但是没有设置用户自定异常处理函数，从而触发了windows默认异常处理函数“弹出一个异常提示框”。这种情况下：1、不要关闭对话框。使用windbg attach 到该异常程序2、通过命令 .dump /ma d:\xx.dmp 保存fulldump分析方法通过windbg打开xx.dmp,加载系统符号文件。输入命令1~*er?$t1=((ntdll!_NT_TIB*)@$teb)-&gt;StackLimit;r?$t2=((ntdll!_NT_TIB*)@$teb)-&gt;StackBase;!teb;dps@$t1@$t2 这个命令是打印所有线程的调用栈，通过查找“KiUserExceptionDispatcher”来找到异常上下文。 注意：因为如上命令会打印很多信息，所以windbg ui界面是无法显示的，好的办法是将输出都保存到日志文件中, windbg-&gt;”edit”-&gt;”open/close log file”。1在输出的log文件中查找&quot;KiUserExceptionDispatcher&quot;,如下 123456789101112044bed64 044ba000044bed68 00000000044bed6c 044bf288044bed70 77a70133 ntdll!KiUserExceptionDispatcher+0xf044bed74 014bed84044bed78 [044bedd4]044bed7c 044bed84044bed80 044bedd4044bed84 e06d7363044bed88 00000001044bed8c 00000000044bed90 769cc42d KERNELBASE!RaiseException+0x58 注意其中“[]”的内容，这个地址就是异常上下文地址，最后通过命令.cxr 044bedd4 kv 就可以找到异常点。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[windbg分析准备工作]]></title>
    <url>%2F2019%2F05%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[1、可以上网的电脑。用于下载系统符号文件，没有也没有太大关系。 2、应用程序关闭优化。 关闭优化是方便通过windbg查找内存数据的准确性； 3、匹配的应用程序/dll 的pdb文件。有匹配的pdb才可以找到对应的代码行数、内存参数。很重要 4、windbg软件，32位 下载 5、设置系统符号文件路径。 1e:\mylocalsymbols;SRV*e:\mylocalsymbols*http://msdl.microsoft.com/download/symbols 6、设置应用符号文件路径 PS： win10 的windows商店有款 windbg priview 更加推荐。 下一节如何保存dump。]]></content>
      <categories>
        <category>工作笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[肠子的小心思]]></title>
    <url>%2F2018%2F05%2F28%2F%E8%82%A0%E5%AD%90%E7%9A%84%E5%B0%8F%E5%BF%83%E6%80%9D%2F</url>
    <content type="text"><![CDATA[读书时间：2018年底 从嘴巴到胃的路途虽然仅仅是万里长征第一步，却是从主观的感知世界到自主神经控制的无意识世界的必经过渡，需要两个世界最大限度得集中注意力和团队合作。团队的默契合作可不是一天两天就能练成的，而是打娘胎里就开始练习了。作为练习，胎儿每天在子宫内都会吞咽下大概半升的羊水，即使有时候失败了也没什么大碍，因为胎儿整个（包括肺）都是浸在水里的，所以自然也不会担心会被“呛到”。 反酸：很好的介绍了胃酸返流的现象、原因和一些解决方法。 睡觉的时候上半身抬高30度的卧位对身体有好处。 古今中午外都适用的防吐窍门： 1、远眺 2、让自己尽量放松 3、吃生姜 4、吃晕车晕船药 5、按摩内关穴 其中生姜、晕车晕船药、内关穴对于情绪性呕吐最有效。放松和催眠可以训练神经的任性，训练的越多，神经就会变得越强健，对抗个普通的考试或者工作压力便不在话下。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微服务设计]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[读书时间：2018 微服务的主要好处：1、技术异构型在一个由多个相互协作的系统中，可以在不同的服务中使用最适合该服务的技术。微服务可以帮助我们更快的采用新技术。 2、弹性 3、扩展庞大的单块服务只能作为一个整体进行扩展。即使系统中只有一小部分存在性能问题，也需要对整个服务进行扩展。 4、简化部署在有几百万行代码行的单块应用程序中，即使只修改一行代码，也需要重新部署整个应用程序才能够发布该变更。这种部署影响很大、风险很高，因此相关干系人不敢轻易做部署。 5、与组织结构相匹配 6、可组合型 7、对可替代性的优化 很多人把城市比作生物，因为城市会时不时地发生变化。当居民对城市的使用方式有所变化，或者收到外力的影响时，城市就会相应地演化。城市规划师应该尽量去预期可能发生的变化，但是也需要明白一个事实：尝试直接对各个方面进行控制往往不会奏效。 建设团队对于一个胸痛技术愿景的主要负责人来说，执行愿景不仅仅等同于做技术决定，和你一起工作的那些自然会做这些决定。对于技术领导人来说，更重要的事情是帮助你的队友成长，帮助他们理解这个愿景，并保证他们可以积极地参与到愿景的实现和调整中来。 微服务架构本身能够提供一种很好的形式。在单块系统中，人们为某些事情负责的机会非常有限，而在微服务架构中存在多个自治的代码库，每个代码库都有着自己独立的生命周期，这就给更多人提供了对单个服务负责的机会，而当这些人在单个服务上面得到足够锻炼之后，就可以给他们更多的责任，从而帮助他们逐步达成自己的职业目标，同时通过分担职责也可以防止某一个人的负担过重。 我坚定地相信，伟大的软件来自于伟大的人。所以如果你只是担心技术问题，那么恐怕你看到的问题远远不及一半。 消息队列使用的bug系统运行起来，感觉很棒。但是在某一次发布后，我们遇到了一个很令人讨厌的问题。我们的消费者不停的崩溃、不停的崩溃、不停的崩溃。最终我们发现了问题所在。代码中存在一个bug，某一种特定请求会导致工作者崩溃。我们当时使用了事务处理队列（类似rabbitmq的持久化），如果在处理过程中崩溃，那么这个消息是不会被消费掉的，然后其他的消费者就会来消费这个消息，然后又崩溃…… 灾难性故障转移的一个典型例子。 处了代码中的bug外，我们还忘了设置一个作业最大重试次数。所以后面不但修复了bug本身，还设置了这个最大重试次数。但是我们也意识到需要又一种方法来查看甚至是重发这些有问题的消息。所以最后实现了一个消息医院（或者叫死信队列），所有失败的消息都会被发送到这里。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[加密解密-软件保护的若干忠告]]></title>
    <url>%2F2018%2F05%2F28%2F%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%BF%A0%E5%91%8A%2F</url>
    <content type="text"><![CDATA[读书时间：2018 尽量开发自己的保护机制，不要过分依赖不是自己开发的任何代码。在不影响效率的情况下，保护的核心代码用虚拟机保护软件处理一下，如vmprotect等。 不要太依赖壳的保护，加密壳都能被解开或脱壳，现在许多壳转向虚拟机加密方向，多利用这方面的功能。 增加对软件自身的完整性检查 不要采用一目了然的名字来命名函数和文件 尽可能少地给用户提示信息 将注册码和安装时间记录在多个不同的地方 检查注册信息和时间的代码越分散越好 不要依赖getlocaltime()和getsystemtime（）这种众所周知的函数获取系统时间 如果有可能，可以采用联网检查注册码的方法，并且数据在网上传输时要加密 编程时在软件中嵌入反跟踪的代码，已增加安全性 在检查注册信息的时候插入大量无用的运算以误导解密者 给软件保护加入一定的随机性 如果采用注册码的保护方式，最好时一机一码 如果试用版和正式版是分开两个版本，不要仅仅使相关菜单变灰，而是彻底删除代码 如果软件中包含驱动程序，则最好将保护判断加在驱动程序中 如果采用keyfile的保护方式，则keyfile尺寸不能太小 自己设计的检查注册信息的算法不能过于简单，最好采用比较成熟的密码学算法。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[众病之王]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%BC%97%E7%97%85%E4%B9%8B%E7%8E%8B%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 那些没有经过化学或药学训练的人，可能不会意识到治疗癌症到底有多难。程度几乎——并不完全是，只是几乎——像是要找到一种溶剂，它既可以溶解掉左耳，又能使右耳完好无损。癌细胞与其前身正常细胞之间的差异，竟是如此地微小。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[卓有成效的管理者]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%8D%93%E6%9C%89%E6%88%90%E6%95%88%E7%9A%84%E7%AE%A1%E7%90%86%E8%80%85%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 管理者的有效性，强调的是“做正确的事情，把事情做正确”；强调的是“按时做完自己该做的事情并产生成果”;强调的是把“知识转化为成果”。管理者工作的失效、乃至失败，往往是因为没有足够的时间区思考如何做正确的事情或把事情做正确。他们的时间往往被掠夺，使自己陷于日常事务和内部复杂的关系中，疲于奔命，被现实的压力牵着鼻子走，以致忽略了产生成果的方向，忽略了产生成果的外部联系。进而，随着企业规模的扩大，以及内部专业化分工体系的深化，使他们更看不到外部的机会以及协同的必要。 一、重视贡献 二、着眼明日 三、时间管理 四、有效决策 五、用人所长]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[终极算法]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%BB%88%E6%9E%81%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 https://zhuanlan.zhihu.com/p/26512893 比较好的介绍 算法五大流派： ①符号主义：使用符号、规则和逻辑来表征知识和进行逻辑推理，最喜欢的算法是：规则和决策树 ②贝叶斯派：获取发生的可能性来进行概率推理，最喜欢的算法是：朴素贝叶斯或马尔可夫 ③联结主义：使用概率矩阵和加权神经元来动态地识别和归纳模式，最喜欢的算法是：神经网络 ④进化主义：生成变化，然后为特定目标获取其中最优的，最喜欢的算法是：遗传算法 ⑤Analogizer：根据约束条件来优化函数（尽可能走到更高，但同时不要离开道路），最喜欢的算法是：支持向量机]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自控力]]></title>
    <url>%2F2018%2F05%2F28%2F%E8%87%AA%E6%8E%A7%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 我们该怎么做才能减少孩子的学习障碍发生率呢？第一：脑外伤跟病变。对应措施是，家长要注意再孩子做剧烈运动的时候给他们戴头盔保护头部；脑膜炎不要耽误治疗。 第二：就是遗传因素，所以结婚前要了解一下对方的家庭和病史。 第三：孩子在早期教育中缺少成年人的指导，所以在孩子8岁之前要尽量多花时间陪伴他们，多参与孩子的活动。 第四：贫困的家庭环境，所以对于父母来说，要尽量地让自己收入丰厚，并且稳定。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[让问题到你为止]]></title>
    <url>%2F2018%2F05%2F28%2F%E8%AE%A9%E9%97%AE%E9%A2%98%E5%88%B0%E4%BD%A0%E4%B8%BA%E6%AD%A2%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 1、我要把他提拔为销售副经理，我必须通过他才能和整个销售团队联系；从今以后我要尊重每一个销售人员，如何发现任何问题，要先和他沟通，不能随意公开批评或指责他们。 你对待员工的方式及你的一言一行，都会影响他们的情感，这一点对于调动员工的积极性和充分发挥他们的效能来说至关重要，要比你接收的任何教育、你所拥有的智慧或你在工作中积累的经验都重要的多。 在商业对话中，你能够做出的最重大的改变就是用“贡献”一词替代“成功”。在思考时，一旦你开始关注贡献，你的转变就开始了。 2、在人类所有的行为背后，潜在的基本情感动机是什么呢?“对幸福的渴望” 3、微笑只需要牵动我们面部13块肌肉，但皱眉却需要牵动112块肌肉。因为每天冲员工微笑要比皱眉容易得多。 4、深入了解员工的思想、情感和情绪，非常有利于刺激员工提高生产效率，其力量远远大于对工作环境做出的硬性改变。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[秦谜]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%A7%A6%E8%B0%9C%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 天意：统一天下民意：秦灭六国，残酷的强暴了各国人心，违逆大众民意 天意无情，民意人性，天意和民意的离合，左右了历史的动向。秦统一天下 是一部顺天逆民的历史。 天意和民意，是我们观察历史的两束光源，评价历史和历史人物的两个观点。体察天意和民意，方能通古今之变。古代社会，天意重而民意轻；现代社会，民意重而天意薄。天意超前，民意滞后；天意难测而识者少，民意可察而变数多。以史为鉴，当权者顺天重民，调和天意和民意，可谓是须臾而不可忘记。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[丑陋的中国人]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 中国人有这么多丑陋面，只有中国人才能改造中国人。我们中国人口太多，中国人的苦难是多方面的，必须每一个人都要觉醒。如果我们每一个人都成为鉴赏家，我们就能鉴赏自己，鉴赏朋友，鉴赏国家领导人物。这是中国人目前应该走的一条路，也是唯一的一条路。 中国人的陋习：1、不认真，不敬业，悠悠忽忽，吊儿郎当地“混”，是大多数中国人的生活特征。2、只我例外。 我反对闯红灯，只是反对别人闯，我自己却可以闯。3、缺少敢讲敢想的灵性4、见风转陀，人人变成了滑不溜丢的琉璃蛋。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从优秀到卓越]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%BB%8E%E4%BC%98%E7%A7%80%E5%88%B0%E5%8D%93%E8%B6%8A%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 5级领导人体系 第一级： 能力突出的个人。 用自己的智慧、知识、技能和良好的工作作风作出巨大贡献 第二级：乐于奉献的团队成员。为实现集体目标贡献个人才智，与团队成员通力合作 第三级：富有实力的经理人。组织人力资源，高效地朝既定目标前进 第四级：坚强有力的领导人。全身心投入、执著追求清晰可见，催人奋发的愿景，向更高业绩标准努力 第五级：经理人。 将个人的谦虚品质和职业化的坚定意志相结合，建立持续的卓越业绩。 我们以为会是这样的表现：将一个公司从优秀推向卓越的第一步是为公司设定一个新的方向、新的愿景和战略，然后找到合适的人，再朝这个新的方向前进。但我们发现有时情况恰恰相反。他们首先会让合适的人上车，然后才决定去向何处。用他们经典的话语来说：看，我真的不清楚应将这辆车驶向何处。但有有一点毋庸置疑：如果我们和合适的人在车上，并各就其位，而不合适的人已下车，然后我们就可以确定如何将车开向某个卓越之地。 “弱将强兵“模式： 如果在重要位置上安排能干的将军，那么他在公司内的竞争对手就会离开；但若是挑选一个能力一般的将军，那么他周围的校尉们很可能就会留下来。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中国历代政治得失]]></title>
    <url>%2F2018%2F05%2F28%2F%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 1、政府的组织：政府的权利分配 2、考试和选举 3、赋税制度 4、国防和兵役制度 中国社会不分阶级，却分流派。 清流： 进士、翰林院 称为清流 浊流：举人、秀才为浊流， 永远无法当大官]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[继承者们]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%BB%A7%E6%89%BF%E8%80%85%E4%BB%AC%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 最佳TOP51、汉文帝 刘恒2、唐太宗 李世民不需要做什么完人，情商高点儿，学会起码的自制，就不会做的太糟。3、清太宗 皇太极4、宋太宗 赵光义5、魏文帝 曹丕 最差TOP51、西晋惠帝 司马衷2、秦二世 胡亥3、北齐 高氏4、隋炀帝 杨广5、后唐庄宗 李存勖]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[集装箱改变世界]]></title>
    <url>%2F2018%2F05%2F28%2F%E9%9B%86%E8%A3%85%E7%AE%B1%E6%94%B9%E5%8F%98%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[读书时间：2018年 马儿科姆.麦克莱恩的根本性认识在于，航运业的业务是运货而不是航道。这种认识让他形成了与以往完全不同的集装箱运输的新概念。麦克莱恩认识到，降低货运成本所要求的不仅仅是一只金属箱子，而是一整套货物处理的新方法。这个系统的每一个组成部分，港口、轮船、起动机、存储设备、卡车、火车以及发货人自身的操作等等，都必须做出改变。 集装箱不是改变了航运的时间，而在在系统上 在货运装卸、码头存储提供了全面的新的认识。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最有效的五步推销法]]></title>
    <url>%2F2018%2F05%2F28%2F%E6%9C%80%E6%9C%89%E6%95%88%E7%9A%84%E4%BA%94%E6%AD%A5%E6%8E%A8%E9%94%80%E6%B3%95%2F</url>
    <content type="text"><![CDATA[读书时间2018年 很多场合，我们需要说服别人。比如，说服客户购买产品，说服风投投钱。 如果你只有一次 PPT 演讲的机会，怎么才有最大的说服力？ 第一步，提出一个当今世界的变化趋势不要首先谈论你的产品、你的顾客、你的投资者等等，任何你自己的事情都不要首先谈。第一件事是要介绍世界的趋势。 你要以一种显而易见的、不可否认的、正在发生的世界趋势来开场。这种趋势跟你的产品必须是相关的，可以为你的产品带来重大利益，或者使得你的产品具有重大的急迫性。 你要让对方意识到，这种趋势会影响到他们。如果正确反应的话，他们就能获得机会。 开场即使不能打动听众，也要获取他们的注意力，让他们愿意听你讲下去。注意力是最关键的。 第二步，提出会有赢家和输家即使对方从上面的趋势看到了机会，但是如果同时需要承担巨大风险，他们很可能会选择维持现状。 为了克服这种”风险厌恶”，你需要明确提出，这种趋势会带来大赢家和大输家。如果顺应变化，前景一片光明；如果抵抗变化，前景一片灰暗。也就是说，你要给对方提供巨大的诱因，让他们愿意参与变化。如果保持现状，他们可能会有巨大损失。 第三步，描绘美好的未来到了这个时候，你大概已经忍不住要推销自己产品了。但是，还没到时候，你需要再忍一下。如果太快引入产品，跟前面好不容易营造的上下文可能脱节，对方感到突兀的话，就前功尽弃了。 这时，你要做的是，描绘使用你的产品之后的美好未来，但不要提到你的产品。比如，你可以说”如果发生 xxx 的改变，我们的社会就会出现 xxx 的情景”。你描绘的未来应该非常诱人，同时也应该是很难达到的，否则你的产品就没有存在的理由了。 第四步，介绍克服困难、到达未来所需要的那个关键步骤最成功的推销方法，很像英雄电影或者童话故事。主角达成目标之前，总是需要学会某种技能，或者获得某种宝物。你这时要介绍的，就是那种技能或宝物。 正是因为有了前面那些上下文，你才能在这个部分谈一些细节，否则那些细节就会变得相当乏味和无趣。你这时可以详细解释，为什么传统方法无法达到美好的未来，新的方法如何克服现存的困难。 第五步，提出证据，你能让这一切变成现实既然你已经描述了未来，现在是时候告诉大家，怎样才能到达那里，也就是你的产品跟这一切到底有何相关。 因为前面你已经说了到达那里很困难，所以听众对于你的能力是有怀疑的。你必须举出证据，让人相信你能让这一切成真。 最好的证据莫过于举出一个例子，你已经帮助其他人成功了。如果你还没有成功案例，那可以演示一下产品，演示的重点应该是如何达到你描述的未来。 说服对方，一般很难只靠一次推销演讲。但是，如果你按照上面的结构来做推销，会使得你的机会最大化。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[成大事者不纠结]]></title>
    <url>%2F2017%2F05%2F28%2F%E6%88%90%E5%A4%A7%E4%BA%8B%E8%80%85%E4%B8%8D%E7%BA%A0%E7%BB%93%2F</url>
    <content type="text"><![CDATA[读书时间：2017年 破纠结最好的法门：专注于当下 为人处世忌“目光远大”，一定要“鼠目寸光”，把眼下该办的事办好。这样所有的矛盾，都会在你往前走的过程中自然化解掉了。 “未来不迎，当时不杂，过往不恋“ “不问是非，埋头业务，屁股干净，尽力协调” 一个历史人物，不管他被供奉为神，还是被描述为鬼，当你了解到更多事实的时候，你会发现，只要承认人性是多元的，他的所作所为就是可以理解的。 这个时代，过去的经验没用了，对未来的预测基本都是瞎扯，基于原来人际关系获得的所有巧妙几乎也都失效了。 迷茫时代，如何当一个明白人]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[大型网站技术架构 核心原理与案例分析]]></title>
    <url>%2F2017%2F05%2F28%2F%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[读书时间：2017年 创新的业务发展模式对网站架构逐步提出更高的要求，才使得创新的网站架构得以发展成熟。是业务成就了技术，是事业成就了人，而不是相反。所以网站架构师应该对自己技术成绩的网站事业心存感恩，并努力提高技术回馈业务，才能在快速发展的互联网领域保持持续的进步。、 网站架构设计误区： 1、一味追随大公司的解决方案 2、为了技术而技术 3、企图用技术解决所有问题技术是用来解决业务问题的， 而业务问题，也可以通过业务的手段去解决。 我们的现实生活中充斥着几乎千篇一律的人生架构模式：读重点学校，选热门专业，进稳定高收入的政府部门和企业，找门当户对的配偶，生一个孩子继续这个模式………… 但是人生不同于软件，精彩的人生绝不会来自于复制。 大型网站架构演化发展历程单机LAMP（linux、apache、mysql、php） 应用服务和数据服务分离 应用服务需要更强的cpu 数据库服务需要快速磁盘检索和数据缓存，需要更快的硬盘 文件服务器需要大硬盘 使用缓存改善网站性能 80%的业务访问集中在20%的数据上。 如何缓存一小部分数据提高访问速度 使用应用集群改善网站并发性能 通过负载均衡服务器，将访问请求分发到机器中 数据库读写分离 读写分离 使用cdn和反向代理加速网站响应使用分布式文件系统和分布式数据库系统 分库分表 业务分库 使用NOSQL和搜索引擎业务拆分 分而治之将业务分成不同的产品线 分布式服务 重新聚合不同产品线相同功能的服务，独立部署提供共用业务服务 分布式服务调用共用业务服务完成具体业务 大型网站架构演化的价值观网站的价值在于它能为客户提供什么价值，在于网站能做什么，而不在于它是怎么做的，所以在网站还是很小的时候就去追求网站的架构是舍本逐末，得不偿失。小型网站最需要做的就是为用户提供好的服务来创造价值，得到用户的认可，活下去，野蛮生长。 大型网站架构技术的核心价值不是从无到有搭建一个大型网站，而是能够伴随小型网站业务的逐步发展，慢慢地演化成一个大型网站。在这个漫长地技术演化过程中，不需要放弃什么，不需要推翻什么，不需要剧烈的革命，就那么润物细无声地把一个只有一台服务器，几百个用户的小网站演化成一个几十万台服务器，数十亿用户的大网站。 模式为了解决大型网站面临的高并发访问、海量数据处理、高可靠运行等一系列问题与挑战，大型互联网公司再实践中提出了许多解决方案。 分层将系统在横向维度切分为几个部分，每个部分负责一部分相对比较单一的职责。 应用层：负责具体业务和视图展示服务层：为应用层提供服务支持，比如用户管理服务、购物车服务数据层：提供数据存储访问服务，如数据库、缓存、文件等 分割将系统在纵向方面对软件进行切分。 比如在应用层，将不同业务进行分割，将购物、论坛、搜索广告分割成不同的应用，由独立团队负责，部署在不同的服务器上；同样在服务层也可以按需进行分割 分布式对于大型网站，分层和分割的一个主要目的就是为了切分后的模块便于分布式部署，即将不同的模块部署在不同的服务器。 分布式在解决网站高并发问题的同时也带来了其他问题： 分布式意味着服务调用必须通过网络，这可能对性能造成比较严重的影响 服务器越多，服务器宕机的概率也就越大，一台服务异常导致的服务不可用可能会导致许多应用不可访问 数据在分布式的环境中保持一致性也非常困难，分布式事务也难以保证 分布式还导致网站依赖错综复杂，开发管理维护困难。 常用的分布式方案有以下几种： 分布式应用和服务 分布式静态资源 分布式数据和存储 分布式计算 集群多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务。所以在网站应用中，即使是访问量很小的分布式应用和服务，也至少要部署两台服务器构成一个小的集群，目的就是提供系统的可用性 缓存 CDN 反向代理 本地缓存 分布式缓存 异步优点： 提供系统可用性 加快网站响应速度 消除并发访问高峰 缺点：处理业务可能会对用户体验、业务流程造成影响，需要产品设计方面的支持。 冗余网站需要7*24连续运行，但是服务器随时可能出现故障，就需要一定程度的服务器冗余运行，数据冗余备份。数据库除了定期备份，存档保存，实现冷备份外，为了保证在线业务高可用，还需要对数据库进行主从分离，实现同步实现热备份。 为了抵御地震、海啸等不可抗力，某些大型网站会对数据中心进行备份，部署灾备数据中心。 自动化devops运维管理类似 自动化管理、测试、发布、监控、报警、转移等等 安全 通过密码和手机校验码进行身份认证 登陆、交易等操作需要对网络通信进行加密 为了防止机器人程序滥用网络资源攻击网站，网站使用验证码进行识别 常见的xss攻击、sql注入，进行编码转换等相应处理 对于垃圾信息、敏感信息进行过滤 对于交易等重要操作根据交易模式和交易信息进行风险控制 大型网站核心架构要素性能常用系统操作响应时间 操作 响应时间 数据中查询一条记录（有索引） 十几毫秒 机械硬盘一次寻址定位 4毫秒 从机械硬盘顺序读取1M数据 2毫秒 从SSD顺序读取1M数据 0.3毫秒 从redis读取一个数据 0.5毫秒 从内存读取1M数据 十几微秒 网络传输2KB数据 1微秒 测试指标 响应时间 并发数 吞吐量 性能计数器 测试方法 性能测试 负载测试 压力测试 稳定性测试 优化策略 性能分析 ：检查请求处理得各个环节得日志，分析哪个环节响应时间不合理、超出预期；然后检查监控数据，分析影响性能得主要因素是内存、磁盘、网络还是CPU，是代码问题还是架构设计不合理，或者系统资源确实不足。 性能优化 web前端性能优化 减少http请求 使用浏览器缓存 启用压缩 CSS放上面，js放下面 减少cookie传输 cdn 加速 反向代理 应用服务器性能优化 分布式缓存: 优先考虑使用缓存优化性能 数据不一致与脏读 缓存可用性 缓存预热 缓存穿透 异步操作 使用集群 代码优化 多线程 资源复用 数据结构：原始字符串—&gt;md5—&gt;hashcode ,散列效果好 垃圾回收 存储性能优化 机械硬盘or固态硬盘：机械硬盘特点快速顺序读写、慢速随机读写。 B+树 vs LSM 树 RAID VS HDFS 总结性能优化的最终目的就是改善用户的体验，使他们感觉网站很快。离开这个目的，追求技术上的所谓高性能，是舍本逐末。 而用户体验的快或是慢，可以通过技术手段改善，也可以通过优化交互体验改善。 即使再技术层面，性能优化也需要全面考虑，综合权衡：性能提示一倍，但服务器数量也增加了一倍；或者响应时间缩短，同时数据一致性也下降，这样的优化是否可以接受？ 技术是为业务服务的，离开了业务发展的支持和驱动，技术走不远，甚至还会迷路。 可用性 负载均衡 集群session管理 高可用服务 分级管理 超时设置 异步调用 服务降级 幂等性设计 高可用数据 CAP 原理 数据备份 失效转移 软件质量保证 无影响用户发布方式 自动化测试 预发布验证 代码控制 自动化发布 灰度发布 网站运行监控 监控数据采集 用户行为日志采集 服务器性能监控 运行数据报告 监控管理 系统报警 失效转移 自动优雅降级 总结1工程师对架构做了许多优化、对代码做了很多重构，对性能、扩展性、伸缩性做了很多改善，但别人未必能直观得感受到，也许你地直接领导都不知道你做的这些意义何在。但如果你负责的产品出了重大故障，CEO都会知道你的名字。 伸缩性应用服务器的集群伸缩 http 重定向负载均衡 DNS域名解析负载均衡（优势基于地理位置的域名解析） 反向代理负载均衡 ip负载均衡 数据链接层负载均衡（三角传输） 分布式缓存集群的伸缩 一致性hash算法 数据存储服务器的伸缩 关系型数据库集群 amoeba cobar NOSQL 总结1遇到问题，分析问题，最后总能解决问题。许多问题只是看起来一样，具体问题总是要具体对待的，没有银弹，没有救世主。 扩展性降低系统耦合度，构建可扩展的网站架构。 利用分布式消息队列降低系统耦合性 可以复杂用mq，也可以简单用mysql 微服务 大型网站分布式服务的需求和特点 服务注册和发现 负载均衡 失效转移 高效的远程调用 整合异构系统 对应用少侵入 版本管理 实时监控 总结1马克思的劳动价值理论告诉我们，产品的内在价值在于劳动的时间，劳动的时间不在于个体付出的劳动时间，而在于行业一般劳动时间，资本家只会为行业一般劳动时间买单，如果你的效率低于行业一般劳动时间，对不起，请自愿加班。反之，如果你有一个更有效率的架构，可以更加快速地开发出产品，你至少在这个全行业都加班的领域，你能够按时下班，陪陪家人，看看星星。 安全性攻与防 XSS攻击 —&gt; 消毒、httponly 注入攻击 –&gt; 消毒、参数绑定 CSRF攻击–&gt; 表单token、验证码、referer check 其他漏洞：error code、html注释、文件上传、路径遍历 应用防火墙 开源的 modsecurity 安全漏洞扫描信息过滤与反垃圾 文本匹配： trie算法、降噪预处理 分类算法：贝叶斯算法 黑名单：布隆过滤器 风控 规则引擎 统计模型 总结没有绝对的安全。网站的相对安全是通过提高攻击门槛达到的。让攻击者为了获得有限的利益必须付出更大的代价，致使得不偿失，望而却步。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[打开量化投资的黑箱]]></title>
    <url>%2F2017%2F05%2F28%2F%E6%89%93%E5%BC%80%E9%87%8F%E5%8C%96%E6%8A%95%E8%B5%84%E7%9A%84%E9%BB%91%E7%AE%B1%2F</url>
    <content type="text"><![CDATA[读书时间：2017年 1、本质上，由情绪、无纪律性、激情、贪婪和恐惧驱使的决策，能够在量化投资过程被消除，而这些心理因素被许多人认为是市场投资中出现重大失误的原因。这些心理因素被例行分析和系统化的方法所取代。 一般的，衡量资产质量的指标可以分为五大类1、杠杆比率。 杠杆低的企业要比高的企业更加靠谱 2、收入来源的多样性。 具有多种潜在增长渠道的国家或公司比渠道单一的国家或公司质量要高 3、管理水平。正如你可能想到的那样，从所需要的信息角度去衡量，这是最难以量化的一类指标，但也有些指标可用来度量管理水平，如公司的财务报表中操纵性应计利润的变化。有观点认为，操纵性应计利润的变化越大，公司高层的管理能力越值得质疑。 4、欺诈风险。警示人们：有时候上市公司的高管更专注公司的财报是否漂亮，而不是兢兢业业地管理公司业务。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[活出生命的意义]]></title>
    <url>%2F2017%2F05%2F28%2F%E6%B4%BB%E5%87%BA%E7%94%9F%E5%91%BD%E7%9A%84%E6%84%8F%E4%B9%89%2F</url>
    <content type="text"><![CDATA[读书时间：2017年 1、一些不可控的力量可能会拿走你很多东西，但它唯一无法剥夺的是你自主选择如何应对不同处境的自由。你无法控制生命中会发生什么，但你可以控制面对这些事情时自己的情绪与行动。 2、本书认为，生活是充满意义的，人们要摒弃环境的侵扰，学会追寻生活的意义。它还强调，生活是有终极目的存在的。 3、不要只想着成功—你越想成功，就越容易失败。成功就像幸福一样，可遇而不可求。它是一种自然而然的产物，是一个人无意识地投身于某一伟大的事业时产生的衍生品，或者是为他人奉献时的副产品。幸福总会降临的，成功也同样：常常是无心插柳柳成荫。我希望你们一切行为服从良心，并用知识去实现它，总有一天你会发现，当然是相当长的时间之后—-注意，我说的是很长一段时间后！—正是由于这种不关注，成功将降临于你。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[稀缺]]></title>
    <url>%2F2017%2F05%2F28%2F%E7%A8%80%E7%BC%BA%2F</url>
    <content type="text"><![CDATA[读书时间：2017 （一）管窥会令人们想要同时做几件事情，因为这样可以节省时间，这是在“管子”视野之内获得的收益；而节省时间的同时可能会出现的问题，则出在“管子”视野之外。 有时，当我们有了管窥之见时，就会完全忽略其他事情。当我们手头有一项急需完成的工作时，就会缩短与家人共度的时光，将理财计划向后推，甚至是例行的体检也要改期。时间特别紧张时，我们就会想：“下周也能陪孩子玩。”而不会想：“孩子现在真的需要我，要等到什么时候我才能真的有时间呢？”对于我们来说，“管子”视野之外的事物并不容易看清，更容易被我们忽略，而且也更容易遗忘。注：“管子”视野，指专注于一些事情。 所谓的因小失大…………………. （二）在面对数额较小的财务问题时，穷人和富人表现没有太大区别；但数额较大的财务问题严重改变了穷人的表现，他们变得更加冲动。 需要控制自己对财务的把控力度，在多大范围内能保持理智…… 穷人的“有效”能力的确比富人要弱一些。这并不是因为穷人的能力差，而是因为他们的一部分大脑早已被稀缺所俘获了。 （大脑的一部分智力和执行力被贫穷干扰了） （三）稀缺，不仅仅会令我们入不敷出，不知如何分配资源，而且还会让我们在生活的其他方面手足无措。稀缺会使人变笨，变得更加冲动。我们不得不在执行控制力和智力被减弱的情况下，依靠更为有效的脑力去勉强度日。生活，就这样变得举步维艰起来。 （四）我们在小物件上连几毛几分钱都会计较，而在大物件上却汇金如土。这样看来，我们所谓的节俭根本派不上用场。我们会花好几个小时在网络上查找，就只是为了从150的鞋子上省去50,；但我们却不会为了一辆价值2w的汽车上省出几百元，而花费几个小时时间去做信息收集。 （五）节俭和穷人的区别。 节俭之人对金钱怀有一种保证富余的责任感，而穷人则需要随时进行权衡。 购买时，节俭之人会思考的是该商品的价格是否“实惠”，相比之下，穷人则会思考，为了付出相应的金钱，他们要放弃什么。 所以说节俭之人并不需要进行真正的权衡，他们与生活在资源充裕条件下的人一样，很难体会到1元钱的真正意义。缺乏清晰价值观会导致可以预见的失误：同样的情况下，富人会放错误，而穷人却能够避免。 （六）可能会让人认为，在资源充裕阶段，我们会精打细算，充满远见卓识。事实当然并非如此。数十年的研究显示，在资源最为充裕的时期，而且特别是在这样的时期，我们尤其容易犯下拖延的毛病。 （七）也许问题并不出在这些项目所提供的扶助内容上，而在于提供扶助的方法。就像第二次世界大战期间的轰炸机驾驶舱一样，也许我们只要通过更加优质的设计，就能提高这些项目的成功率。而更为优质的设计，需要将稀缺心里中所体现的专注力和带宽问题等根本性见解囊括进来。优化设计]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[万历十五年]]></title>
    <url>%2F2017%2F05%2F28%2F%E4%B8%87%E5%8E%86%E5%8D%81%E4%BA%94%E5%B9%B4%2F</url>
    <content type="text"><![CDATA[读书时间：2017年 生命的真意义，要在历史上获得。 全书的精华在最后一段： 当一个人口众多的国家，各人行动全凭儒家简单粗浅而又无法固定的原则所限制，而法律又缺乏创造性，则其社会发展的程度，必然受到限制。即便是宗旨善良，也不能补助技术之不及。1587年，是为万历十五年，丁亥次岁，表面上视乎是四海升平，无事可记，实际上我们的大明帝国却已经走到了它发展的尽头。在这个时候，皇帝的励精图治或者宴安耽乐，首辅的独裁或者调和，高级将领的富于创造或者习于苟安，文官的廉洁奉公或者贪污舞弊，思想家的极端进步或者绝对保守，最后的结果，都是无分善恶，统统不能再事业上取得有意义的发展，有的身败，有的名裂，还有的人则身败名裂。因此我们的故事只好在这里作悲剧性的结束。万历丁亥年的年鉴，是为历史上一部失败的总记录。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读书笔记 开始]]></title>
    <url>%2F2016%2F05%2F09%2F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E5%AF%BC%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[读书笔记其实就是将自己看过的一些书，将其中有感触的东西记下来。16年前也经常看一些书，但我总感觉自己记忆力太差，看完之后过段时间几乎都想不起来，就和没看过一样，所以希望能够做一些笔记，提醒自己曾经看过。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
</search>
